{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Table Of Content Python What is Python Variables Data Types Operators Lists Tuples Sets Dictionaries Conditional Statements For Loop While Loop Functions Exception Handling Modules File Handling Database Third Party Packages OOP","title":"Table Of Content"},{"location":"#table-of-content","text":"Python What is Python Variables Data Types Operators Lists Tuples Sets Dictionaries Conditional Statements For Loop While Loop Functions Exception Handling Modules File Handling Database Third Party Packages OOP","title":"Table Of Content"},{"location":"django/authentication-and-user-pages/","text":"","title":"Authentication and User Pages"},{"location":"django/build-models-and-database/","text":"","title":"Build Models and Database"},{"location":"django/class-based-views/","text":"","title":"Class-Based Views (CBV)"},{"location":"django/crud-operations/","text":"","title":"CRUD Operations"},{"location":"django/deploy-and-finalizations/","text":"","title":"Deploy and Finalizations"},{"location":"django/designing-and-frontend/","text":"","title":"Designing and Frontend"},{"location":"django/django-admin-panel/","text":"","title":"Django Admin Panel"},{"location":"django/django-authentication-system/","text":"","title":"Django Authentication System"},{"location":"django/django-forms/","text":"","title":"Django Forms"},{"location":"django/django-messages-framework/","text":"","title":"Django Messages Framework"},{"location":"django/django-orm-and-models/","text":"","title":"Django ORM and Models"},{"location":"django/django-project-structure/","text":"\ud83c\udf10 DJANGO WEB FRAMEWORK ASOSLARI \ud83e\udde9 DJANGO PROJECT STRUCTURE Django loyihasi MTV (Model-Template-View) arxitekturasiga asoslanadi: Model: Ma'lumotlar bazasi bilan ishlash uchun jadvallar va logikani belgilaydi. Template: Foydalanuvchi interfeysi uchun HTML shablonlar. View: So\u2018rovlar va javoblar o\u2018rtasidagi mantiqiy bog\u2018lovchi. \u2705 LOYIHA TUZILMASI \ud83d\udccc Django loyihasi(project) va ilovasi(app) yaratilganda quyidagi fayl va papkalar hosil bo\u2018ladi: project_folder/ \u2502\u2500\u2500 manage.py \u2502\u2500\u2500 project_name/ \u2502 \u2502\u2500\u2500 __init__.py \u2502 \u2502\u2500\u2500 settings.py \u2502 \u2502\u2500\u2500 urls.py \u2502 \u2502\u2500\u2500 asgi.py \u2502 \u2514\u2500\u2500 wsgi.py \u2502\u2500\u2500 app_name/ \u2502 \u2502\u2500\u2500 __init__.py \u2502 \u2502\u2500\u2500 admin.py \u2502 \u2502\u2500\u2500 apps.py \u2502 \u2502\u2500\u2500 models.py \u2502 \u2502\u2500\u2500 tests.py \u2502 \u2502\u2500\u2500 views.py \u2502 \u2502\u2500\u2500 migrations/ \u2502 \u2502\u2500\u2500 templates/ \u2502 \u2514\u2500\u2500 static/ \u2705 DJANGO LOYIHA(PROJECT) YARATISH \ud83d\udccc Django loyihasini yaratish uchun quyidagi buyruq ishlatiladi: django-admin startproject project_name . \ud83c\udfaf Bu buyruq project_name nomli loyiha papkasini yaratadi. Loyiha ichida asosiy konfiguratsiya fayllari joylashadi. \u2705 DJANGO ILOVA(APP) YARATISH \ud83d\udccc Loyiha ichida ilova yaratish uchun quyidagi buyruq ishlatiladi: python manage.py startapp app_name \ud83c\udfaf Bu buyruq myapp nomli ilova yaratadi va loyiha tuzilmasiga yangi papka qo\u2018shadi. Har bir ilova o\u2018ziga xos funksionallikni ta'minlaydi (masalan, blog, base yoki foydalanuvchi boshqaruvi). \u2705 ILOVA(APP)NI LOYIHA(PROJECT)GA ULASH \ud83d\udccc Yangi yaratilgan ilovani loyihaga qo\u2018shish uchun settings.py faylidagi INSTALLED_APPS ro\u2018yxatini oxiriga ilova nomi qo\u2018shiladi: INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app_name', # Yangi ilova \u2705 ILOVA(APP) URLSNI LOYIHA(PROJECT) URLSGA ULASH Djangoda project va app urls.py fayllari marshrutlashni (URL routing) boshqaradi: Project urls.py \u2013 butun loyiha uchun asosiy URL xaritasi App urls.py \u2013 faqat shu app ichidagi URL manzillarni boshqaradi from django.contrib import admin from django.urls import path, include # include() import qilinadi urlpatterns = [ path('admin/', admin.site.urls), path('', include('myapp.urls')), # MyApp URL\u2019larini qo\u2018shish ] \ud83c\udfaf include Djangoda project urls.py ichida boshqa URL konfiguratsiyalarni qo\u2018shish uchun ishlatiladi, shuning uchun uni import qilish shart. \u2747\ufe0f include() nima qiladi? include() Djangoga \u201cborib, boshqa urls.py faylini ichiga qo\u2018sh\u201d deb aytadi. Bu kattaroq loyihalarda tartibni saqlash va URLlarni modullar bo\u2018yicha ajratish uchun juda foydali. \u2705 LOYIHANING ASOSIY FAYLLARI VA PAPKALARI \u2747\ufe0f manage.py \ud83d\udccc manage.py fayli \u2014 bu Django loyihasining asosiy boshqaruv fayli, ya\u2019ni u orqali turli xil buyruqlarni bajarish mumkin. Siz aytgan uchta (runserver, startapp, migrate) eng ko\u2018p ishlatiladigani, lekin bundan tashqari juda ko\u2018p imkoniyatlar bor. \ud83d\udccc Django manage.py yordamida qo\u2018shimcha buyruqlar \u2733\ufe0f 1. Superuser yaratish \ud83d\udccc Admin paneliga kirish uchun foydalanuvchi yaratadi: python manage.py createsuperuser \u2733\ufe0f 2. Yangi migration fayl yaratish \ud83d\udccc Modeldagi o\u2018zgarishlarni migration fayliga yozib qo\u2018yadi: python manage.py makemigrations \u2733\ufe0f 3. Shell rejimiga kirish \ud83d\udccc Django muhitida Python interaktiv shellini ishga tushiradi: python manage.py shell \u2733\ufe0f 4. Baza ma\u2019lumotlarini ko\u2018chirish (dumplar) \ud83d\udccc Ma\u2019lumotlarni JSON faylga saqlash: python manage.py dumpdata > data.json \ud83d\udccc Saqlangan ma\u2019lumotni bazaga qayta yuklash: python manage.py loaddata data.json \u2733\ufe0f 5. Statik fayllarni yig\u2018ish \ud83d\udccc Barcha statik fayllarni bitta joyga yig\u2018ib beradi (deploymentda kerak bo\u2018ladi): python manage.py collectstatic \u2733\ufe0f 6. Buyruqlar ro\u2018yxatini ko\u2018rish \ud83d\udccc Django\u2019da mavjud barcha buyruqlarni ko\u2018rish: python manage.py help \u2733\ufe0f 7. Migrationlarni tekshirish \ud83d\udccc Bazaga migration qo\u2018llanadimi yoki yo\u2018qmi, tekshiradi: python manage.py showmigrations \u2733\ufe0f 8. Parolni o\u2018zgartirish (foydalanuvchi uchun) python manage.py changepassword username \u2733\ufe0f 9. Serverni boshqa port yoki IP da ishga tushirish \ud83d\udccc Masalan, 8001-portda: python manage.py runserver 8001 \ud83d\udccc yoki lokal tarmoqdagi boshqa qurilmalardan ham kirish uchun: python manage.py runserver 0.0.0.0:8000 \u2733\ufe0f 10. O\u2018z buyruqlaringizni yaratish \ud83d\udccc management/commands/ papkasi ichida yangi buyruq yozish mumkin. Masalan: python manage.py mycommand \u2733\ufe0f 11. migrate bu fayldagi o\u2018zgarishlarni real ma\u2019lumotlar bazasiga qo\u2018llaydi. python manage.py migrate \u2747\ufe0f Loyiha papkasi (myproject/) \ud83d\udccc Bu papka loyihaning asosiy konfiguratsiyalarini o'z ichiga oladi. \u2733\ufe0f __init__.py \ud83d\udccc Bu fayl papkani Python paketi sifatida belgilaydi. \u2733\ufe0f settings.py \ud83d\udccc Loyiha konfiguratsiyalari shu yerda. - Muhim bo\u2018limlar: - DATABASES \u2013 ma\u2019lumotlar bazasi sozlamalari - INSTALLED_APPS \u2013 ulanishi kerak bo\u2018lgan app\u2019lar ro\u2018yxati - MIDDLEWARE \u2013 request/response jarayonlarini boshqaruvchi qavatlar - STATIC_URL , MEDIA_URL \u2013 statik va media fayllar yo\u2018llari \u2733\ufe0f urls.py \ud83d\udccc Loyiha darajasida URL'larni boshqarish uchun ishlatiladi. from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('myapp/', include('myapp.urls')), # myapp URL'larini ulash ] \u2733\ufe0f asgi.py va wsgi.py wsgi.py \u2013 WSGI server uchun loyiha konfiguratsiyasi (Apache, Gunicorn uchun kerak). asgi.py \u2013 ASGI server uchun loyiha konfiguratsiyasi (async, WebSocket'lar uchun). \u2747\ufe0f Django application tuzilmasi (myapp/) \ud83d\udccc Har bir app odatda quyidagi fayllardan iborat bo\u2018ladi: \u2733\ufe0f models.py \ud83d\udccc Ma\u2019lumotlar bazasi jadvallari shu yerda yoziladi. from django.db import models class UserProfile(models.Model): name = models.CharField(max_length=100) email = models.EmailField(unique=True) created_at = models.DateTimeField(auto_now_add=True) \u2733\ufe0f views.py \ud83d\udccc Brauzerdan kelgan so'rovlarni qayta ishlaydi. from django.http import HttpResponse def home(request): return HttpResponse(\"Hello, World!\") \u2733\ufe0f urls.py \ud83d\udccc Ilova darajasidagi URL'larni boshqaradi. from django.urls import path from .views import home urlpatterns = [ path('', home, name='home'), ] \u2733\ufe0f admin.py \ud83d\udccc Django admin paneliga modellarning ro'yxatga olinishi uchun ishlatiladi. from django.contrib import admin from .models import UserProfile admin.site.register(UserProfile) \u2733\ufe0f migrations/ \ud83d\udccc Ma'lumotlar bazasi o'zgarishlarini saqlovchi fayllar joylashgan. python manage.py makemigrations \ud83d\udccc Migratsiyalarni bajarish uchun: python manage.py migrate \u2733\ufe0f apps.py \ud83d\udccc Django applarni konfiguratsiyalarini saqlaydi. \u2733\ufe0f tests.py \ud83d\udccc Djangoda test yozish uchun ishlatiladi. from django.test import TestCase class SimpleTest(TestCase): def test_basic(self): self.assertEqual(1 + 1, 2) \u2733\ufe0f templates/ \ud83d\udccc HTML shablonlar joylashadigan papka. \u2733\ufe0f static/ \ud83d\udccc CSS, JavaScript va media fayllar saqlanadigan joy. Django loyihasi qanday ishlaydi? Brauzer foydalanuvchi so\u2018rov yuboradi.\u2b07\ufe0f Django urls.py orqali mos keluvchi view ni topadi.\u2b07\ufe0f views.py da mos keluvchi funksiya ishlaydi. \u2b07\ufe0f Agar ma'lumotlar kerak bo'lsa, models.py orqali ma'lumotlar bazasidan olinadi.\u2b07\ufe0f Natija foydalanuvchiga HttpResponse yoki render orqali qaytariladi.","title":"Django Project Structure"},{"location":"django/django-project-structure/#django-web-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO WEB FRAMEWORK ASOSLARI"},{"location":"django/django-project-structure/#django-project-structure","text":"Django loyihasi MTV (Model-Template-View) arxitekturasiga asoslanadi: Model: Ma'lumotlar bazasi bilan ishlash uchun jadvallar va logikani belgilaydi. Template: Foydalanuvchi interfeysi uchun HTML shablonlar. View: So\u2018rovlar va javoblar o\u2018rtasidagi mantiqiy bog\u2018lovchi.","title":"\ud83e\udde9 DJANGO PROJECT STRUCTURE"},{"location":"django/django-project-structure/#loyiha-tuzilmasi","text":"\ud83d\udccc Django loyihasi(project) va ilovasi(app) yaratilganda quyidagi fayl va papkalar hosil bo\u2018ladi: project_folder/ \u2502\u2500\u2500 manage.py \u2502\u2500\u2500 project_name/ \u2502 \u2502\u2500\u2500 __init__.py \u2502 \u2502\u2500\u2500 settings.py \u2502 \u2502\u2500\u2500 urls.py \u2502 \u2502\u2500\u2500 asgi.py \u2502 \u2514\u2500\u2500 wsgi.py \u2502\u2500\u2500 app_name/ \u2502 \u2502\u2500\u2500 __init__.py \u2502 \u2502\u2500\u2500 admin.py \u2502 \u2502\u2500\u2500 apps.py \u2502 \u2502\u2500\u2500 models.py \u2502 \u2502\u2500\u2500 tests.py \u2502 \u2502\u2500\u2500 views.py \u2502 \u2502\u2500\u2500 migrations/ \u2502 \u2502\u2500\u2500 templates/ \u2502 \u2514\u2500\u2500 static/","title":"\u2705 LOYIHA TUZILMASI"},{"location":"django/django-project-structure/#django-loyihaproject-yaratish","text":"\ud83d\udccc Django loyihasini yaratish uchun quyidagi buyruq ishlatiladi: django-admin startproject project_name . \ud83c\udfaf Bu buyruq project_name nomli loyiha papkasini yaratadi. Loyiha ichida asosiy konfiguratsiya fayllari joylashadi.","title":"\u2705 DJANGO LOYIHA(PROJECT) YARATISH"},{"location":"django/django-project-structure/#django-ilovaapp-yaratish","text":"\ud83d\udccc Loyiha ichida ilova yaratish uchun quyidagi buyruq ishlatiladi: python manage.py startapp app_name \ud83c\udfaf Bu buyruq myapp nomli ilova yaratadi va loyiha tuzilmasiga yangi papka qo\u2018shadi. Har bir ilova o\u2018ziga xos funksionallikni ta'minlaydi (masalan, blog, base yoki foydalanuvchi boshqaruvi).","title":"\u2705 DJANGO ILOVA(APP) YARATISH"},{"location":"django/django-project-structure/#ilovaappni-loyihaprojectga-ulash","text":"\ud83d\udccc Yangi yaratilgan ilovani loyihaga qo\u2018shish uchun settings.py faylidagi INSTALLED_APPS ro\u2018yxatini oxiriga ilova nomi qo\u2018shiladi: INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app_name', # Yangi ilova","title":"\u2705 ILOVA(APP)NI LOYIHA(PROJECT)GA ULASH"},{"location":"django/django-project-structure/#ilovaapp-urlsni-loyihaproject-urlsga-ulash","text":"Djangoda project va app urls.py fayllari marshrutlashni (URL routing) boshqaradi: Project urls.py \u2013 butun loyiha uchun asosiy URL xaritasi App urls.py \u2013 faqat shu app ichidagi URL manzillarni boshqaradi from django.contrib import admin from django.urls import path, include # include() import qilinadi urlpatterns = [ path('admin/', admin.site.urls), path('', include('myapp.urls')), # MyApp URL\u2019larini qo\u2018shish ] \ud83c\udfaf include Djangoda project urls.py ichida boshqa URL konfiguratsiyalarni qo\u2018shish uchun ishlatiladi, shuning uchun uni import qilish shart.","title":"\u2705 ILOVA(APP) URLSNI LOYIHA(PROJECT) URLSGA ULASH"},{"location":"django/django-project-structure/#include-nima-qiladi","text":"include() Djangoga \u201cborib, boshqa urls.py faylini ichiga qo\u2018sh\u201d deb aytadi. Bu kattaroq loyihalarda tartibni saqlash va URLlarni modullar bo\u2018yicha ajratish uchun juda foydali.","title":"\u2747\ufe0f include() nima qiladi?"},{"location":"django/django-project-structure/#loyihaning-asosiy-fayllari-va-papkalari","text":"","title":"\u2705 LOYIHANING ASOSIY FAYLLARI VA PAPKALARI"},{"location":"django/django-project-structure/#managepy","text":"\ud83d\udccc manage.py fayli \u2014 bu Django loyihasining asosiy boshqaruv fayli, ya\u2019ni u orqali turli xil buyruqlarni bajarish mumkin. Siz aytgan uchta (runserver, startapp, migrate) eng ko\u2018p ishlatiladigani, lekin bundan tashqari juda ko\u2018p imkoniyatlar bor. \ud83d\udccc Django manage.py yordamida qo\u2018shimcha buyruqlar","title":"\u2747\ufe0f manage.py"},{"location":"django/django-project-structure/#1-superuser-yaratish","text":"\ud83d\udccc Admin paneliga kirish uchun foydalanuvchi yaratadi: python manage.py createsuperuser","title":"\u2733\ufe0f 1. Superuser yaratish"},{"location":"django/django-project-structure/#2-yangi-migration-fayl-yaratish","text":"\ud83d\udccc Modeldagi o\u2018zgarishlarni migration fayliga yozib qo\u2018yadi: python manage.py makemigrations","title":"\u2733\ufe0f 2. Yangi migration fayl yaratish"},{"location":"django/django-project-structure/#3-shell-rejimiga-kirish","text":"\ud83d\udccc Django muhitida Python interaktiv shellini ishga tushiradi: python manage.py shell","title":"\u2733\ufe0f 3. Shell rejimiga kirish"},{"location":"django/django-project-structure/#4-baza-malumotlarini-kochirish-dumplar","text":"\ud83d\udccc Ma\u2019lumotlarni JSON faylga saqlash: python manage.py dumpdata > data.json \ud83d\udccc Saqlangan ma\u2019lumotni bazaga qayta yuklash: python manage.py loaddata data.json","title":"\u2733\ufe0f 4. Baza ma\u2019lumotlarini ko\u2018chirish (dumplar)"},{"location":"django/django-project-structure/#5-statik-fayllarni-yigish","text":"\ud83d\udccc Barcha statik fayllarni bitta joyga yig\u2018ib beradi (deploymentda kerak bo\u2018ladi): python manage.py collectstatic","title":"\u2733\ufe0f 5. Statik fayllarni yig\u2018ish"},{"location":"django/django-project-structure/#6-buyruqlar-royxatini-korish","text":"\ud83d\udccc Django\u2019da mavjud barcha buyruqlarni ko\u2018rish: python manage.py help","title":"\u2733\ufe0f 6. Buyruqlar ro\u2018yxatini ko\u2018rish"},{"location":"django/django-project-structure/#7-migrationlarni-tekshirish","text":"\ud83d\udccc Bazaga migration qo\u2018llanadimi yoki yo\u2018qmi, tekshiradi: python manage.py showmigrations","title":"\u2733\ufe0f 7. Migrationlarni tekshirish"},{"location":"django/django-project-structure/#8-parolni-ozgartirish-foydalanuvchi-uchun","text":"python manage.py changepassword username","title":"\u2733\ufe0f 8. Parolni o\u2018zgartirish (foydalanuvchi uchun)"},{"location":"django/django-project-structure/#9-serverni-boshqa-port-yoki-ip-da-ishga-tushirish","text":"\ud83d\udccc Masalan, 8001-portda: python manage.py runserver 8001 \ud83d\udccc yoki lokal tarmoqdagi boshqa qurilmalardan ham kirish uchun: python manage.py runserver 0.0.0.0:8000","title":"\u2733\ufe0f 9. Serverni boshqa port yoki IP da ishga tushirish"},{"location":"django/django-project-structure/#10-oz-buyruqlaringizni-yaratish","text":"\ud83d\udccc management/commands/ papkasi ichida yangi buyruq yozish mumkin. Masalan: python manage.py mycommand","title":"\u2733\ufe0f 10. O\u2018z buyruqlaringizni yaratish"},{"location":"django/django-project-structure/#11-migrate-bu-fayldagi-ozgarishlarni-real-malumotlar-bazasiga-qollaydi","text":"python manage.py migrate","title":"\u2733\ufe0f 11. migrate bu fayldagi o\u2018zgarishlarni real ma\u2019lumotlar bazasiga qo\u2018llaydi."},{"location":"django/django-project-structure/#loyiha-papkasi-myproject","text":"\ud83d\udccc Bu papka loyihaning asosiy konfiguratsiyalarini o'z ichiga oladi.","title":"\u2747\ufe0f Loyiha papkasi (myproject/)"},{"location":"django/django-project-structure/#__init__py","text":"\ud83d\udccc Bu fayl papkani Python paketi sifatida belgilaydi.","title":"\u2733\ufe0f __init__.py"},{"location":"django/django-project-structure/#settingspy","text":"\ud83d\udccc Loyiha konfiguratsiyalari shu yerda. - Muhim bo\u2018limlar: - DATABASES \u2013 ma\u2019lumotlar bazasi sozlamalari - INSTALLED_APPS \u2013 ulanishi kerak bo\u2018lgan app\u2019lar ro\u2018yxati - MIDDLEWARE \u2013 request/response jarayonlarini boshqaruvchi qavatlar - STATIC_URL , MEDIA_URL \u2013 statik va media fayllar yo\u2018llari","title":"\u2733\ufe0f settings.py"},{"location":"django/django-project-structure/#urlspy","text":"\ud83d\udccc Loyiha darajasida URL'larni boshqarish uchun ishlatiladi. from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('myapp/', include('myapp.urls')), # myapp URL'larini ulash ]","title":"\u2733\ufe0f urls.py"},{"location":"django/django-project-structure/#asgipy-va-wsgipy","text":"wsgi.py \u2013 WSGI server uchun loyiha konfiguratsiyasi (Apache, Gunicorn uchun kerak). asgi.py \u2013 ASGI server uchun loyiha konfiguratsiyasi (async, WebSocket'lar uchun).","title":"\u2733\ufe0f asgi.py va wsgi.py"},{"location":"django/django-project-structure/#django-application-tuzilmasi-myapp","text":"\ud83d\udccc Har bir app odatda quyidagi fayllardan iborat bo\u2018ladi:","title":"\u2747\ufe0f Django application tuzilmasi (myapp/)"},{"location":"django/django-project-structure/#modelspy","text":"\ud83d\udccc Ma\u2019lumotlar bazasi jadvallari shu yerda yoziladi. from django.db import models class UserProfile(models.Model): name = models.CharField(max_length=100) email = models.EmailField(unique=True) created_at = models.DateTimeField(auto_now_add=True)","title":"\u2733\ufe0f models.py"},{"location":"django/django-project-structure/#viewspy","text":"\ud83d\udccc Brauzerdan kelgan so'rovlarni qayta ishlaydi. from django.http import HttpResponse def home(request): return HttpResponse(\"Hello, World!\")","title":"\u2733\ufe0f views.py"},{"location":"django/django-project-structure/#urlspy_1","text":"\ud83d\udccc Ilova darajasidagi URL'larni boshqaradi. from django.urls import path from .views import home urlpatterns = [ path('', home, name='home'), ]","title":"\u2733\ufe0f urls.py"},{"location":"django/django-project-structure/#adminpy","text":"\ud83d\udccc Django admin paneliga modellarning ro'yxatga olinishi uchun ishlatiladi. from django.contrib import admin from .models import UserProfile admin.site.register(UserProfile)","title":"\u2733\ufe0f admin.py"},{"location":"django/django-project-structure/#migrations","text":"\ud83d\udccc Ma'lumotlar bazasi o'zgarishlarini saqlovchi fayllar joylashgan. python manage.py makemigrations \ud83d\udccc Migratsiyalarni bajarish uchun: python manage.py migrate","title":"\u2733\ufe0f migrations/"},{"location":"django/django-project-structure/#appspy","text":"\ud83d\udccc Django applarni konfiguratsiyalarini saqlaydi.","title":"\u2733\ufe0f apps.py"},{"location":"django/django-project-structure/#testspy","text":"\ud83d\udccc Djangoda test yozish uchun ishlatiladi. from django.test import TestCase class SimpleTest(TestCase): def test_basic(self): self.assertEqual(1 + 1, 2)","title":"\u2733\ufe0f tests.py"},{"location":"django/django-project-structure/#templates","text":"\ud83d\udccc HTML shablonlar joylashadigan papka.","title":"\u2733\ufe0f templates/"},{"location":"django/django-project-structure/#static","text":"\ud83d\udccc CSS, JavaScript va media fayllar saqlanadigan joy.","title":"\u2733\ufe0f static/"},{"location":"django/django-project-structure/#django-loyihasi-qanday-ishlaydi","text":"Brauzer foydalanuvchi so\u2018rov yuboradi.\u2b07\ufe0f Django urls.py orqali mos keluvchi view ni topadi.\u2b07\ufe0f views.py da mos keluvchi funksiya ishlaydi. \u2b07\ufe0f Agar ma'lumotlar kerak bo'lsa, models.py orqali ma'lumotlar bazasidan olinadi.\u2b07\ufe0f Natija foydalanuvchiga HttpResponse yoki render orqali qaytariladi.","title":"Django loyihasi qanday ishlaydi?"},{"location":"django/file-upload-and-media-files/","text":"","title":"File Upload and Media Files"},{"location":"django/introduction-to-django/","text":"\ud83c\udf10 DJANGO WEB FRAMEWORK ASOSLARI \ud83e\udde9 INTRODUCTION TO DJANGO \ud83d\udd30 DJANGO NIMA? \ud83d\udccc Django \u2014 bu Python dasturlash tilida yozilgan veb-framework bo\u2018lib, veb-ilovalarni tez va xavfsiz tarzda ishlab chiqishga yordam beradi. Django shiori: \"The web framework for perfectionists with deadlines.\" (Muddati bor mukammallikni yoqtiradiganlar uchun veb-framework.) \u2705 DJANGONING AFZALLIKLARI Afzallik Tavsif Fast Development Django sizga kamroq kod yozib, ko\u2018proq ish qilish imkonini beradi. Security Djangoda xavfsizlikka alohida e'tibor qaratilgan. Misol: SQL injection, XSS, CSRFdan himoya. Admin Panel Avtomatik yaratiladigan admin panel orqali ma\u2019lumotlarni boshqarish juda oson. Extensible Kengaytirilgan plaginlar, kutubxonalar va jamoa mavjud. ORM Ob'ektga yo'naltirilgan ma'lumotlar bazasi bilan ishlash imkonini beradi. \u2705 DJANGO FRAMEWORKINING ASOSIY XUSUSIYATLARI \u2747\ufe0f Django nima uchun mashhur? \ud83d\udccc Django Python tilida yozilgan ochiq kodli (open-source) veb-framework bo\u2018lib, veb-ilovalarni ishlab chiqishni soddalashtirishga qaratilgan. U \u201cDRY\u201d (Don't Repeat Yourself) va \u201cConvention over Configuration\u201d tamoyillariga asoslanadi, bu esa dasturchilarga tez, samarali va tushunarli kod yozish imkonini beradi. \u2747\ufe0f Django kimlar uchun? Startaplar va katta loyihalar: Django Instagram, Pinterest, Disqus kabi yirik loyihalarda ishlatilgan. Yangidan boshlovchilar: Oddiy va tushunarli tuzilmasi tufayli o\u2018rganish oson. Tajribali dasturchilar: Kengaytiriladigan arxitekturasi va moslashuvchanligi tufayli murakkab loyihalarda qulay. \u2747\ufe0f Django qayerda ishlatiladi? Kontent boshqaruv tizimlari (CMS) Ijtimoiy tarmoqlar E-commerce platformalari API backend-lari Ilmiy va ma'lumotlarni tahlil qilish loyihalari \u2705 DJANGONI O'RNATISH pip install django \ud83d\udccc O'rnatilganligini tekshirish: django-admin --version \u2705 DJANGO LOYIHA(PROJECT) YARATISH \ud83d\udccc Django loyihani yaratishning sababi \u2014 bu butun veb-ilovangiz uchun asosiy \u201cyadro\u201d (framework struktura) tayyorlab berishidir. django-admin startproject project_name . \ud83d\udccc Struktura: manage.py project_name/ # Django loyihasining asosiy papkasi (sozlamalar joylashgan) \u251c\u2500\u2500 __init__.py # Papkani Python paketi sifatida belgilaydi \u251c\u2500\u2500 settings.py # Django sozlamalari (DB, app, static va boshqalar) \u251c\u2500\u2500 urls.py # URL marshrutlari (routing) \u251c\u2500\u2500 asgi.py # ASGI server kirish nuqtasi (async ishlash uchun) \u2514\u2500\u2500 wsgi.py # WSGI server kirish nuqtasi (classic ishlash uchun) \u2705 DJANGO SERVERINI ISHGA TUSHURISH python manage.py runserver \ud83d\udccc Browserda ochish : http://127.0.0.1:8000/ \u2705 DJANGO ILOVA(APP) YARATISH python manage.py startapp app_name \ud83d\udccc Ilova strukturasi: app_name/ \u251c\u2500\u2500 __init__.py # Papkani Python paketi sifatida belgilaydi \u251c\u2500\u2500 admin.py # Admin panelga modelni ro\u2018yxatdan o\u2018tkazish \u251c\u2500\u2500 apps.py # App konfiguratsiyasi \u251c\u2500\u2500 migrations/ # Ma'lumotlar bazasi o\u2018zgarishlari (migratsiyalar) saqlanadigan papka \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 models.py # Ma'lumotlar bazasi modellari \u251c\u2500\u2500 tests.py # Test kodlari \u251c\u2500\u2500 views.py # So\u2018rovlar (request) va javoblar (response) ishlovchilari \u2514\u2500\u2500 urls.py # (Biz qo\u2018lda yaratamiz) \u2014 appning URL marshrutlari","title":"Introduction to Django"},{"location":"django/introduction-to-django/#django-web-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO WEB FRAMEWORK ASOSLARI"},{"location":"django/introduction-to-django/#introduction-to-django","text":"","title":"\ud83e\udde9 INTRODUCTION TO DJANGO"},{"location":"django/introduction-to-django/#django-nima","text":"\ud83d\udccc Django \u2014 bu Python dasturlash tilida yozilgan veb-framework bo\u2018lib, veb-ilovalarni tez va xavfsiz tarzda ishlab chiqishga yordam beradi. Django shiori: \"The web framework for perfectionists with deadlines.\" (Muddati bor mukammallikni yoqtiradiganlar uchun veb-framework.)","title":"\ud83d\udd30 DJANGO NIMA?"},{"location":"django/introduction-to-django/#djangoning-afzalliklari","text":"Afzallik Tavsif Fast Development Django sizga kamroq kod yozib, ko\u2018proq ish qilish imkonini beradi. Security Djangoda xavfsizlikka alohida e'tibor qaratilgan. Misol: SQL injection, XSS, CSRFdan himoya. Admin Panel Avtomatik yaratiladigan admin panel orqali ma\u2019lumotlarni boshqarish juda oson. Extensible Kengaytirilgan plaginlar, kutubxonalar va jamoa mavjud. ORM Ob'ektga yo'naltirilgan ma'lumotlar bazasi bilan ishlash imkonini beradi.","title":"\u2705 DJANGONING AFZALLIKLARI"},{"location":"django/introduction-to-django/#django-frameworkining-asosiy-xususiyatlari","text":"","title":"\u2705 DJANGO FRAMEWORKINING ASOSIY XUSUSIYATLARI"},{"location":"django/introduction-to-django/#django-nima-uchun-mashhur","text":"\ud83d\udccc Django Python tilida yozilgan ochiq kodli (open-source) veb-framework bo\u2018lib, veb-ilovalarni ishlab chiqishni soddalashtirishga qaratilgan. U \u201cDRY\u201d (Don't Repeat Yourself) va \u201cConvention over Configuration\u201d tamoyillariga asoslanadi, bu esa dasturchilarga tez, samarali va tushunarli kod yozish imkonini beradi.","title":"\u2747\ufe0f Django nima uchun mashhur?"},{"location":"django/introduction-to-django/#django-kimlar-uchun","text":"Startaplar va katta loyihalar: Django Instagram, Pinterest, Disqus kabi yirik loyihalarda ishlatilgan. Yangidan boshlovchilar: Oddiy va tushunarli tuzilmasi tufayli o\u2018rganish oson. Tajribali dasturchilar: Kengaytiriladigan arxitekturasi va moslashuvchanligi tufayli murakkab loyihalarda qulay.","title":"\u2747\ufe0f Django kimlar uchun?"},{"location":"django/introduction-to-django/#django-qayerda-ishlatiladi","text":"Kontent boshqaruv tizimlari (CMS) Ijtimoiy tarmoqlar E-commerce platformalari API backend-lari Ilmiy va ma'lumotlarni tahlil qilish loyihalari","title":"\u2747\ufe0f Django qayerda ishlatiladi?"},{"location":"django/introduction-to-django/#djangoni-ornatish","text":"pip install django \ud83d\udccc O'rnatilganligini tekshirish: django-admin --version","title":"\u2705 DJANGONI O'RNATISH"},{"location":"django/introduction-to-django/#django-loyihaproject-yaratish","text":"\ud83d\udccc Django loyihani yaratishning sababi \u2014 bu butun veb-ilovangiz uchun asosiy \u201cyadro\u201d (framework struktura) tayyorlab berishidir. django-admin startproject project_name . \ud83d\udccc Struktura: manage.py project_name/ # Django loyihasining asosiy papkasi (sozlamalar joylashgan) \u251c\u2500\u2500 __init__.py # Papkani Python paketi sifatida belgilaydi \u251c\u2500\u2500 settings.py # Django sozlamalari (DB, app, static va boshqalar) \u251c\u2500\u2500 urls.py # URL marshrutlari (routing) \u251c\u2500\u2500 asgi.py # ASGI server kirish nuqtasi (async ishlash uchun) \u2514\u2500\u2500 wsgi.py # WSGI server kirish nuqtasi (classic ishlash uchun)","title":"\u2705 DJANGO LOYIHA(PROJECT) YARATISH"},{"location":"django/introduction-to-django/#django-serverini-ishga-tushurish","text":"python manage.py runserver \ud83d\udccc Browserda ochish : http://127.0.0.1:8000/","title":"\u2705 DJANGO SERVERINI ISHGA TUSHURISH"},{"location":"django/introduction-to-django/#django-ilovaapp-yaratish","text":"python manage.py startapp app_name \ud83d\udccc Ilova strukturasi: app_name/ \u251c\u2500\u2500 __init__.py # Papkani Python paketi sifatida belgilaydi \u251c\u2500\u2500 admin.py # Admin panelga modelni ro\u2018yxatdan o\u2018tkazish \u251c\u2500\u2500 apps.py # App konfiguratsiyasi \u251c\u2500\u2500 migrations/ # Ma'lumotlar bazasi o\u2018zgarishlari (migratsiyalar) saqlanadigan papka \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 models.py # Ma'lumotlar bazasi modellari \u251c\u2500\u2500 tests.py # Test kodlari \u251c\u2500\u2500 views.py # So\u2018rovlar (request) va javoblar (response) ishlovchilari \u2514\u2500\u2500 urls.py # (Biz qo\u2018lda yaratamiz) \u2014 appning URL marshrutlari","title":"\u2705 DJANGO ILOVA(APP) YARATISH"},{"location":"django/middleware-and-sessions/","text":"","title":"Middleware and Sessions"},{"location":"django/project-planning/","text":"","title":"Project Planning"},{"location":"django/queryset-and-filtering/","text":"","title":"QuerySet and Filtering"},{"location":"django/static-files-and-bootstrap/","text":"","title":"Static Files and Bootstrap"},{"location":"django/templates/","text":"","title":"Templates (Working with HTML)"},{"location":"django/url-dispatcher-and-views/","text":"\ud83c\udf10 Django Web Framework Asoslari URL Dispatcher and Views \ud83d\udccc Django-da URL routing va views yaratish juda muhim qism hisoblanadi. Bu orqali foydalanuvchilar brauzer orqali so'rov yuboradi va Django ularni qanday qaytarishni hal qiladi URL Dispatcher [!NOTE] Django-da URL Dispatcher foydalanuvchi so'rovlarini tegishli view funksiyalariga yo'naltiradi. Bu urls.py faylida amalga oshiriladi. urls.py from django.urls import path from . import views urlpatterns = [ path('', views.home, name='home'), path('about/', views.about, name='about'), path('contact/', views.contact, name='contact'), path('', views.home, name='home') - Asosiy sahifaga ( / ) so'rov kelganda views.home funksiyasi chaqiriladi. path('about/', views.about, name='about') - /about/ yo'lida views.about funksiyasi chaqiriladi. path('contact/', views.contact, name='contact') - /contact/ yo'lida views.contact funksiyasi chaqiriladi. Views [!NOTE] Views - bu foydalanuvchi so'rovlariga javob beradigan funksiyalar yoki classlar. Ular views.py faylida joylashgan. views.py from django.http import HttpResponse def home(request): return HttpResponse(\"Welcome to the Home Page!\") def about(request): return HttpResponse(\"This is the About Page.\") def contact(request): return HttpResponse(\"Contact us at contact@example.com.\") home funksiyasi asosiy sahifaga kirganda \"Welcome to the Home Page!\" xabarini qaytaradi. about funksiyasi /about/ yo'lida \"This is the About Page.\" xabarini qaytaradi. contact funksiyasi /contact/ yo'lida \"Contact us at contact@example.com.\" xabarini qaytaradi. Turli sahifalar uchun url va view yaratish Keling, bir nechta sahifalar uchun yo'llar va ko'rinishlar yaratamiz. urls.py from django.urls import path from . import views urlpatterns = [ path('', views.home, name='home'), path('about/', views.about, name='about'), path('contact/', views.contact, name='contact'), path('services/', views.services, name='services'), path('portfolio/', views.portfolio, name='portfolio'), ] views.py from django.http import HttpResponse def home(request): return HttpResponse(\"Welcome to the Home Page!\") def about(request): return HttpResponse(\"This is the About Page.\") def contact(request): return HttpResponse(\"Contact us at contact@example.com.\") def services(request): return HttpResponse(\"Our Services: Web Development, SEO, Consulting.\") def portfolio(request): return HttpResponse(\"Check out our portfolio to see our work.\") HTML Template bilan ishlash Ko'pincha, oddiy HttpResponse o'rniga HTML shablonlardan foydalaniladi. Buning uchun render funksiyasidan foydalanamiz. views.py from django.shortcuts import render def home(request): return render(request, 'home.html') def about(request): return render(request, 'about.html') def contact(request): return render(request, 'contact.html') templates/home.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Home</title> </head> <body> <h1>Welcome to the Home Page!</h1> </body> </html> templates/about.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>About</title> </head> <body> <h1>This is the About Page.</h1> </body> </html> templates/contact.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Contact</title> </head> <body> <h1>Contact us at contact@example.com.</h1> </body> </html> Dinamik URL-lar Ba'zida URL-larda dinamik qiymatlar bo'lishi mumkin. Masalan, foydalanuvchi ID-si yoki post slugi. urls.py from django.urls import path from . import views urlpatterns = [ path('', views.home, name='home'), path('about/', views.about, name='about'), path('contact/', views.contact, name='contact'), path('user/<int:user_id>/', views.user_profile, name='user_profile'), ] views.py from django.http import HttpResponse def user_profile(request, user_id): return HttpResponse(f\"User Profile Page for User ID: {user_id}\")","title":"Url Dispatcher and Views"},{"location":"django/url-dispatcher-and-views/#django-web-framework-asoslari","text":"","title":"\ud83c\udf10 Django Web Framework Asoslari"},{"location":"django/url-dispatcher-and-views/#url-dispatcher-and-views","text":"\ud83d\udccc Django-da URL routing va views yaratish juda muhim qism hisoblanadi. Bu orqali foydalanuvchilar brauzer orqali so'rov yuboradi va Django ularni qanday qaytarishni hal qiladi","title":"URL Dispatcher and Views"},{"location":"django/url-dispatcher-and-views/#url-dispatcher","text":"[!NOTE] Django-da URL Dispatcher foydalanuvchi so'rovlarini tegishli view funksiyalariga yo'naltiradi. Bu urls.py faylida amalga oshiriladi. urls.py from django.urls import path from . import views urlpatterns = [ path('', views.home, name='home'), path('about/', views.about, name='about'), path('contact/', views.contact, name='contact'), path('', views.home, name='home') - Asosiy sahifaga ( / ) so'rov kelganda views.home funksiyasi chaqiriladi. path('about/', views.about, name='about') - /about/ yo'lida views.about funksiyasi chaqiriladi. path('contact/', views.contact, name='contact') - /contact/ yo'lida views.contact funksiyasi chaqiriladi.","title":"URL Dispatcher"},{"location":"django/url-dispatcher-and-views/#views","text":"[!NOTE] Views - bu foydalanuvchi so'rovlariga javob beradigan funksiyalar yoki classlar. Ular views.py faylida joylashgan. views.py from django.http import HttpResponse def home(request): return HttpResponse(\"Welcome to the Home Page!\") def about(request): return HttpResponse(\"This is the About Page.\") def contact(request): return HttpResponse(\"Contact us at contact@example.com.\") home funksiyasi asosiy sahifaga kirganda \"Welcome to the Home Page!\" xabarini qaytaradi. about funksiyasi /about/ yo'lida \"This is the About Page.\" xabarini qaytaradi. contact funksiyasi /contact/ yo'lida \"Contact us at contact@example.com.\" xabarini qaytaradi.","title":"Views"},{"location":"django/url-dispatcher-and-views/#turli-sahifalar-uchun-url-va-view-yaratish","text":"Keling, bir nechta sahifalar uchun yo'llar va ko'rinishlar yaratamiz. urls.py from django.urls import path from . import views urlpatterns = [ path('', views.home, name='home'), path('about/', views.about, name='about'), path('contact/', views.contact, name='contact'), path('services/', views.services, name='services'), path('portfolio/', views.portfolio, name='portfolio'), ] views.py from django.http import HttpResponse def home(request): return HttpResponse(\"Welcome to the Home Page!\") def about(request): return HttpResponse(\"This is the About Page.\") def contact(request): return HttpResponse(\"Contact us at contact@example.com.\") def services(request): return HttpResponse(\"Our Services: Web Development, SEO, Consulting.\") def portfolio(request): return HttpResponse(\"Check out our portfolio to see our work.\")","title":"Turli sahifalar uchun url va view yaratish"},{"location":"django/url-dispatcher-and-views/#html-template-bilan-ishlash","text":"Ko'pincha, oddiy HttpResponse o'rniga HTML shablonlardan foydalaniladi. Buning uchun render funksiyasidan foydalanamiz. views.py from django.shortcuts import render def home(request): return render(request, 'home.html') def about(request): return render(request, 'about.html') def contact(request): return render(request, 'contact.html') templates/home.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Home</title> </head> <body> <h1>Welcome to the Home Page!</h1> </body> </html> templates/about.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>About</title> </head> <body> <h1>This is the About Page.</h1> </body> </html> templates/contact.html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Contact</title> </head> <body> <h1>Contact us at contact@example.com.</h1> </body> </html>","title":"HTML Template bilan ishlash"},{"location":"django/url-dispatcher-and-views/#dinamik-url-lar","text":"Ba'zida URL-larda dinamik qiymatlar bo'lishi mumkin. Masalan, foydalanuvchi ID-si yoki post slugi. urls.py from django.urls import path from . import views urlpatterns = [ path('', views.home, name='home'), path('about/', views.about, name='about'), path('contact/', views.contact, name='contact'), path('user/<int:user_id>/', views.user_profile, name='user_profile'), ] views.py from django.http import HttpResponse def user_profile(request, user_id): return HttpResponse(f\"User Profile Page for User ID: {user_id}\")","title":"Dinamik URL-lar"},{"location":"drf/advanced-concepts-and-best-practices/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 19-DARS: ILG'OR TUSHUNCHALAR VA ENG YAXSHI AMALIYOTLAR Bu darsda Django REST Framework (DRF) da ilg'or tushunchalar va eng yaxshi amaliyotlarni bosqichma-bosqich o'rganamiz. Biz API versioning, DRF-spectacular bilan avtomatik API hujjatlari, maxsus xatolik boshqaruvi va loyiha sifatini oshirish uchun eng yaxshi amaliyotlarni ko'rib chiqamiz. Har bir qadam tushunarli va faqat ilg'or tushunchalar va amaliyotlarga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash, Celery, keshlash, WebSocket va Docker asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash, keshlash va WebSocket bilan). - Signallar, Celery, WebSocket va testlar myapp/signals.py , myapp/tasks.py , myapp/consumers.py va myapp/tests.py fayllarida sozlangan. - Docker sozlamalari Dockerfile va docker-compose.yml fayllarida mavjud. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. ILG'OR TUSHUNCHALAR VA ENG YAXSHI AMALIYOTLAR NI TUSHUNISH \ud83d\udccc Ilg'or tushunchalar : - API versioning : API ning turli versiyalarini qo'llab-quvvatlash. - DRF-spectacular : Avtomatik API hujjatlari (OpenAPI/Swagger) yaratish. - Maxsus xatolik boshqaruvi : API xatolarini markazlashgan tarzda boshqarish. \ud83d\udccc Eng yaxshi amaliyotlar : - Kod tashkiloti: Loyiha tuzilmasini soddalashtirish va qayta ishlatish. - Xavfsizlik: API va ma'lumotlarni himoya qilish. - Logging: Tahlil va xatolarni kuzatish uchun yaxshilangan logging. - Test qamrovi: To'liq funksionallikni sinash. \ud83d\udccc Ushbu darsda ushbu tushunchalarni loyihamizga qo'llaymiz. \u2705 3. PAKETLARNI O'RNATISH \ud83d\udccc API versioning va DRF-spectacular uchun qo'shimcha paketlarni o'rnatamiz: pip install drf-spectacular \ud83d\udccc requirements.txt faylini yangilang: django==4.2 djangorestframework==3.14 django-filter==23.2 djangorestframework-simplejwt==5.2 channels==4.0 channels-redis==4.0 django-redis==5.2 celery==5.2 redis==4.5 psycopg2-binary==2.9 daphne==4.0 drf-spectacular==0.26 \u2705 4. LOYIHA SOZLAMALARINI YANGILASH \ud83d\udccc myproject/settings.py faylida API versioning va DRF-spectacular sozlamalarini qo'shamiz: INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'channels', 'drf_spectacular', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.URLPathVersioning', # API versioning 'DEFAULT_VERSION': 'v1', # Standart versiya 'ALLOWED_VERSIONS': ['v1', 'v2'], # Ruxsat etilgan versiyalar 'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema', # DRF-spectacular } # PostgreSQL sozlamalari DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql', 'NAME': 'mydb', 'USER': 'myuser', 'PASSWORD': 'mypassword', 'HOST': 'db', 'PORT': '5432', } } # Celery sozlamalari CELERY_BROKER_URL = 'redis://redis:6379/0' CELERY_RESULT_BACKEND = 'redis://redis:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = False # Keshlash sozlamalari CACHES = { 'default': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://redis:6379/1', 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', } } } # Channels sozlamalari ASGI_APPLICATION = 'myproject.asgi.application' CHANNEL_LAYERS = { 'default': { 'BACKEND': 'channels_redis.core.RedisChannelLayer', 'CONFIG': { 'hosts': [('redis', 6379)], }, }, } # Logging sozlamalari LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'verbose': { 'format': '{levelname} {asctime} {module} {message}', 'style': '{', }, }, 'handlers': { 'file': { 'level': 'INFO', 'class': 'logging.FileHandler', 'filename': 'debug.log', 'formatter': 'verbose', }, 'console': { 'level': 'INFO', 'class': 'logging.StreamHandler', 'formatter': 'verbose', }, }, 'loggers': { 'myapp': { 'handlers': ['file', 'console'], 'level': 'INFO', 'propagate': True, }, 'django': { 'handlers': ['file', 'console'], 'level': 'INFO', 'propagate': True, }, }, } \ud83d\udccc Tushuntirish : - DEFAULT_VERSIONING_CLASS : URL da versiyalashni yoqadi (masalan, /v1/tasks/ ). - DEFAULT_SCHEMA_CLASS : DRF-spectacular ni API hujjatlari uchun sozlaydi. - LOGGING : Formatlangan loglar uchun verbose formater qo'shildi. \u2705 5. API VERSIONING NI SOZLASH \ud83d\udccc myproject/urls.py faylini yangilaymiz va versiyalashni qo'llab-quvvatlaymiz: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include('myapp.urls')), # WebSocket sahifasi uchun path('v1/', include(router.urls)), # v1 versiyasi path('v2/', include(router.urls)), # v2 versiyasi (keyinchalik farqlarni qo'shish mumkin) path('v1/api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('v1/api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), path('v1/schema/', SpectacularAPIView.as_view(), name='schema'), # API sxemasi path('v1/docs/', SpectacularSwaggerView.as_view(url_name='schema'), name='swagger-ui'), # Swagger UI ] \ud83d\udccc Tushuntirish : - v1/ va v2/ : API versiyalari uchun prefikslar. - SpectacularAPIView : OpenAPI sxemasini yaratadi. - SpectacularSwaggerView : Swagger UI ni ta'minlaydi. \u2705 6. MAXSUS XATOLIK BOSHQARUVI \ud83d\udccc myapp/exceptions.py faylini yarating va maxsus xatolik sinfini qo'shing: from rest_framework.views import exception_handler from rest_framework.response import Response from rest_framework import status def custom_exception_handler(exc, context): response = exception_handler(exc, context) if response is not None: custom_response = { 'error': { 'status_code': response.status_code, 'message': str(exc), 'detail': response.data } } response.data = custom_response return response \ud83d\udccc myproject/settings.py faylida xatolik boshqaruvchisini sozlang: REST_FRAMEWORK = { ... 'EXCEPTION_HANDLER': 'myapp.exceptions.custom_exception_handler', } \ud83d\udccc Tushuntirish : - custom_exception_handler : API xatolarini moslashtirilgan formatda qaytaradi (masalan, {'error': {...}} ). \u2705 7. KOD TASHKILOTI VA ENG YAXSHI AMALIYOTLAR \ud83d\udccc Quyidagi amaliyotlarni qo'llaymiz: - Modulli tuzilma : Kodni models , serializers , views , permissions , pagination , signals , tasks , consumers va exceptions kabi alohida fayllarga ajratdik. - Xavfsizlik : - JWT autentifikatsiyasi va IsOwnerOrReadOnly ruxsatlarini qo'lladik. - ALLOWED_HOSTS ni sozlash: python ALLOWED_HOSTS = ['localhost', '127.0.0.1', 'your-domain.com'] - HTTPS ni Nginx orqali sozlash (ishlab chiqarishda). - Logging : Formatlangan loglar qo'shildi ( verbose formater). - Test qamrovi : Oldingi darsda yozilgan testlar loyiha funksionalligini qamrab oladi. - Ma'lumotlar bazasi optimallashtirish : select_related qo'llanildi. \u2705 8. DRF-SPECTACULAR BILAN API HUJJATLARI \ud83d\udccc myapp/views.py faylida TaskViewSet ni DRF-spectacular uchun hujjatlaymiz: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from django.views.decorators.cache import cache_page from django.utils.decorators import method_decorator from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated from drf_spectacular.utils import extend_schema, OpenApiParameter class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all().select_related('owner') serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user) @method_decorator(cache_page(60 * 5)) @extend_schema( description='Barcha vazifalarni ro\\'yxatini qaytaradi, sahifalash va filtrlash qo\\'llaniladi.', parameters=[ OpenApiParameter(name='completed', description='Vazifa holati (true/false)', required=False, type=bool), OpenApiParameter(name='search', description='Sarlavha yoki tavsif bo\\'yicha qidirish', required=False, type=str), ] ) def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) \ud83d\udccc Tushuntirish : - @extend_schema : API endpointi uchun hujjatlashtirish qo'shadi. - OpenApiParameter : Filtr va qidiruv parametrlari uchun hujjatlashtirish. \u2705 9. TESTLARNI YANGILASH \ud83d\udccc myapp/tests.py fayliga API versioning va xatolik boshqaruvini sinash uchun testlar qo'shamiz: from django.test import TestCase from rest_framework.test import APITestCase from rest_framework import status from django.urls import reverse from django.contrib.auth.models import User from rest_framework_simplejwt.tokens import RefreshToken from .models import Task from .serializers import TaskSerializer from django.core.cache import cache from channels.testing import WebsocketCommunicator from myapp.consumers import TaskConsumer import json import logging logger = logging.getLogger(__name__) # Oldingi testlar (TaskModelTest, TaskSerializerTest, TaskSignalTest, TaskAPITest, TaskWebSocketTest) shu yerda qoladi class TaskAdvancedTest(APITestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.token = RefreshToken.for_user(self.user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.token}') cache.clear() def test_api_versioning(self): url_v1 = reverse('task-list', kwargs={'version': 'v1'}) response_v1 = self.client.get(url_v1) self.assertEqual(response_v1.status_code, status.HTTP_200_OK) url_v2 = reverse('task-list', kwargs={'version': 'v2'}) response_v2 = self.client.get(url_v2) self.assertEqual(response_v2.status_code, status.HTTP_200_OK) def test_custom_exception_handler(self): url = reverse('task-detail', kwargs={'version': 'v1', 'pk': 999}) # Mavjud bo'lmagan ID response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND) self.assertIn('error', response.data) self.assertEqual(response.data['error']['status_code'], 404) self.assertIn('detail', response.data['error']) def test_api_documentation(self): url = reverse('schema', kwargs={'version': 'v1'}) response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) \ud83d\udccc Tushuntirish : - test_api_versioning : v1 va v2 versiyalarini sinaydi. - test_custom_exception_handler : Maxsus xatolik formatini tekshiradi. - test_api_documentation : API sxemasining mavjudligini sinaydi. \u2705 10. DOCKER SOZLAMALARINI TEKSHIRISH \ud83d\udccc docker-compose.yml faylida o'zgarishlar talab qilinmaydi, lekin requirements.txt yangilanganligi uchun konteynerni qayta quring: docker-compose up --build \u2705 11. SINOV UCHUN MASALALAR \ud83d\udccc Ilg'or tushunchalar va amaliyotlarni sinash uchun quyidagi amallarni bajarib ko'ring: 1. http://localhost/v1/docs/ manzilida Swagger UI ni oching va API hujjatlarini ko'ring. 2. http://localhost/v1/tasks/ va http://localhost/v2/tasks/ manzillarini sinab, versiyalashni tekshiring. 3. Mavjud bo'lmagan vazifani so'rang ( /v1/tasks/999/ ) va maxsus xatolik formatini ko'ring. 4. python manage.py test bilan yangi testlarni sinab ko'ring. 5. Loglarni debug.log faylida tekshiring va formatlangan xabarlarni ko'ring.","title":"Advanced Concepts and Best Practices"},{"location":"drf/advanced-concepts-and-best-practices/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/advanced-concepts-and-best-practices/#19-dars-ilgor-tushunchalar-va-eng-yaxshi-amaliyotlar","text":"Bu darsda Django REST Framework (DRF) da ilg'or tushunchalar va eng yaxshi amaliyotlarni bosqichma-bosqich o'rganamiz. Biz API versioning, DRF-spectacular bilan avtomatik API hujjatlari, maxsus xatolik boshqaruvi va loyiha sifatini oshirish uchun eng yaxshi amaliyotlarni ko'rib chiqamiz. Har bir qadam tushunarli va faqat ilg'or tushunchalar va amaliyotlarga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash, Celery, keshlash, WebSocket va Docker asosida davom etamiz.","title":"\ud83e\udde9 19-DARS: ILG'OR TUSHUNCHALAR VA ENG YAXSHI AMALIYOTLAR"},{"location":"drf/advanced-concepts-and-best-practices/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash, keshlash va WebSocket bilan). - Signallar, Celery, WebSocket va testlar myapp/signals.py , myapp/tasks.py , myapp/consumers.py va myapp/tests.py fayllarida sozlangan. - Docker sozlamalari Dockerfile va docker-compose.yml fayllarida mavjud. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/advanced-concepts-and-best-practices/#2-ilgor-tushunchalar-va-eng-yaxshi-amaliyotlar-ni-tushunish","text":"\ud83d\udccc Ilg'or tushunchalar : - API versioning : API ning turli versiyalarini qo'llab-quvvatlash. - DRF-spectacular : Avtomatik API hujjatlari (OpenAPI/Swagger) yaratish. - Maxsus xatolik boshqaruvi : API xatolarini markazlashgan tarzda boshqarish. \ud83d\udccc Eng yaxshi amaliyotlar : - Kod tashkiloti: Loyiha tuzilmasini soddalashtirish va qayta ishlatish. - Xavfsizlik: API va ma'lumotlarni himoya qilish. - Logging: Tahlil va xatolarni kuzatish uchun yaxshilangan logging. - Test qamrovi: To'liq funksionallikni sinash. \ud83d\udccc Ushbu darsda ushbu tushunchalarni loyihamizga qo'llaymiz.","title":"\u2705 2. ILG'OR TUSHUNCHALAR VA ENG YAXSHI AMALIYOTLAR NI TUSHUNISH"},{"location":"drf/advanced-concepts-and-best-practices/#3-paketlarni-ornatish","text":"\ud83d\udccc API versioning va DRF-spectacular uchun qo'shimcha paketlarni o'rnatamiz: pip install drf-spectacular \ud83d\udccc requirements.txt faylini yangilang: django==4.2 djangorestframework==3.14 django-filter==23.2 djangorestframework-simplejwt==5.2 channels==4.0 channels-redis==4.0 django-redis==5.2 celery==5.2 redis==4.5 psycopg2-binary==2.9 daphne==4.0 drf-spectacular==0.26","title":"\u2705 3. PAKETLARNI O'RNATISH"},{"location":"drf/advanced-concepts-and-best-practices/#4-loyiha-sozlamalarini-yangilash","text":"\ud83d\udccc myproject/settings.py faylida API versioning va DRF-spectacular sozlamalarini qo'shamiz: INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'channels', 'drf_spectacular', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.URLPathVersioning', # API versioning 'DEFAULT_VERSION': 'v1', # Standart versiya 'ALLOWED_VERSIONS': ['v1', 'v2'], # Ruxsat etilgan versiyalar 'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema', # DRF-spectacular } # PostgreSQL sozlamalari DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql', 'NAME': 'mydb', 'USER': 'myuser', 'PASSWORD': 'mypassword', 'HOST': 'db', 'PORT': '5432', } } # Celery sozlamalari CELERY_BROKER_URL = 'redis://redis:6379/0' CELERY_RESULT_BACKEND = 'redis://redis:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = False # Keshlash sozlamalari CACHES = { 'default': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://redis:6379/1', 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', } } } # Channels sozlamalari ASGI_APPLICATION = 'myproject.asgi.application' CHANNEL_LAYERS = { 'default': { 'BACKEND': 'channels_redis.core.RedisChannelLayer', 'CONFIG': { 'hosts': [('redis', 6379)], }, }, } # Logging sozlamalari LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'verbose': { 'format': '{levelname} {asctime} {module} {message}', 'style': '{', }, }, 'handlers': { 'file': { 'level': 'INFO', 'class': 'logging.FileHandler', 'filename': 'debug.log', 'formatter': 'verbose', }, 'console': { 'level': 'INFO', 'class': 'logging.StreamHandler', 'formatter': 'verbose', }, }, 'loggers': { 'myapp': { 'handlers': ['file', 'console'], 'level': 'INFO', 'propagate': True, }, 'django': { 'handlers': ['file', 'console'], 'level': 'INFO', 'propagate': True, }, }, } \ud83d\udccc Tushuntirish : - DEFAULT_VERSIONING_CLASS : URL da versiyalashni yoqadi (masalan, /v1/tasks/ ). - DEFAULT_SCHEMA_CLASS : DRF-spectacular ni API hujjatlari uchun sozlaydi. - LOGGING : Formatlangan loglar uchun verbose formater qo'shildi.","title":"\u2705 4. LOYIHA SOZLAMALARINI YANGILASH"},{"location":"drf/advanced-concepts-and-best-practices/#5-api-versioning-ni-sozlash","text":"\ud83d\udccc myproject/urls.py faylini yangilaymiz va versiyalashni qo'llab-quvvatlaymiz: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include('myapp.urls')), # WebSocket sahifasi uchun path('v1/', include(router.urls)), # v1 versiyasi path('v2/', include(router.urls)), # v2 versiyasi (keyinchalik farqlarni qo'shish mumkin) path('v1/api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('v1/api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), path('v1/schema/', SpectacularAPIView.as_view(), name='schema'), # API sxemasi path('v1/docs/', SpectacularSwaggerView.as_view(url_name='schema'), name='swagger-ui'), # Swagger UI ] \ud83d\udccc Tushuntirish : - v1/ va v2/ : API versiyalari uchun prefikslar. - SpectacularAPIView : OpenAPI sxemasini yaratadi. - SpectacularSwaggerView : Swagger UI ni ta'minlaydi.","title":"\u2705 5. API VERSIONING NI SOZLASH"},{"location":"drf/advanced-concepts-and-best-practices/#6-maxsus-xatolik-boshqaruvi","text":"\ud83d\udccc myapp/exceptions.py faylini yarating va maxsus xatolik sinfini qo'shing: from rest_framework.views import exception_handler from rest_framework.response import Response from rest_framework import status def custom_exception_handler(exc, context): response = exception_handler(exc, context) if response is not None: custom_response = { 'error': { 'status_code': response.status_code, 'message': str(exc), 'detail': response.data } } response.data = custom_response return response \ud83d\udccc myproject/settings.py faylida xatolik boshqaruvchisini sozlang: REST_FRAMEWORK = { ... 'EXCEPTION_HANDLER': 'myapp.exceptions.custom_exception_handler', } \ud83d\udccc Tushuntirish : - custom_exception_handler : API xatolarini moslashtirilgan formatda qaytaradi (masalan, {'error': {...}} ).","title":"\u2705 6. MAXSUS XATOLIK BOSHQARUVI"},{"location":"drf/advanced-concepts-and-best-practices/#7-kod-tashkiloti-va-eng-yaxshi-amaliyotlar","text":"\ud83d\udccc Quyidagi amaliyotlarni qo'llaymiz: - Modulli tuzilma : Kodni models , serializers , views , permissions , pagination , signals , tasks , consumers va exceptions kabi alohida fayllarga ajratdik. - Xavfsizlik : - JWT autentifikatsiyasi va IsOwnerOrReadOnly ruxsatlarini qo'lladik. - ALLOWED_HOSTS ni sozlash: python ALLOWED_HOSTS = ['localhost', '127.0.0.1', 'your-domain.com'] - HTTPS ni Nginx orqali sozlash (ishlab chiqarishda). - Logging : Formatlangan loglar qo'shildi ( verbose formater). - Test qamrovi : Oldingi darsda yozilgan testlar loyiha funksionalligini qamrab oladi. - Ma'lumotlar bazasi optimallashtirish : select_related qo'llanildi.","title":"\u2705 7. KOD TASHKILOTI VA ENG YAXSHI AMALIYOTLAR"},{"location":"drf/advanced-concepts-and-best-practices/#8-drf-spectacular-bilan-api-hujjatlari","text":"\ud83d\udccc myapp/views.py faylida TaskViewSet ni DRF-spectacular uchun hujjatlaymiz: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from django.views.decorators.cache import cache_page from django.utils.decorators import method_decorator from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated from drf_spectacular.utils import extend_schema, OpenApiParameter class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all().select_related('owner') serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user) @method_decorator(cache_page(60 * 5)) @extend_schema( description='Barcha vazifalarni ro\\'yxatini qaytaradi, sahifalash va filtrlash qo\\'llaniladi.', parameters=[ OpenApiParameter(name='completed', description='Vazifa holati (true/false)', required=False, type=bool), OpenApiParameter(name='search', description='Sarlavha yoki tavsif bo\\'yicha qidirish', required=False, type=str), ] ) def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) \ud83d\udccc Tushuntirish : - @extend_schema : API endpointi uchun hujjatlashtirish qo'shadi. - OpenApiParameter : Filtr va qidiruv parametrlari uchun hujjatlashtirish.","title":"\u2705 8. DRF-SPECTACULAR BILAN API HUJJATLARI"},{"location":"drf/advanced-concepts-and-best-practices/#9-testlarni-yangilash","text":"\ud83d\udccc myapp/tests.py fayliga API versioning va xatolik boshqaruvini sinash uchun testlar qo'shamiz: from django.test import TestCase from rest_framework.test import APITestCase from rest_framework import status from django.urls import reverse from django.contrib.auth.models import User from rest_framework_simplejwt.tokens import RefreshToken from .models import Task from .serializers import TaskSerializer from django.core.cache import cache from channels.testing import WebsocketCommunicator from myapp.consumers import TaskConsumer import json import logging logger = logging.getLogger(__name__) # Oldingi testlar (TaskModelTest, TaskSerializerTest, TaskSignalTest, TaskAPITest, TaskWebSocketTest) shu yerda qoladi class TaskAdvancedTest(APITestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.token = RefreshToken.for_user(self.user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.token}') cache.clear() def test_api_versioning(self): url_v1 = reverse('task-list', kwargs={'version': 'v1'}) response_v1 = self.client.get(url_v1) self.assertEqual(response_v1.status_code, status.HTTP_200_OK) url_v2 = reverse('task-list', kwargs={'version': 'v2'}) response_v2 = self.client.get(url_v2) self.assertEqual(response_v2.status_code, status.HTTP_200_OK) def test_custom_exception_handler(self): url = reverse('task-detail', kwargs={'version': 'v1', 'pk': 999}) # Mavjud bo'lmagan ID response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND) self.assertIn('error', response.data) self.assertEqual(response.data['error']['status_code'], 404) self.assertIn('detail', response.data['error']) def test_api_documentation(self): url = reverse('schema', kwargs={'version': 'v1'}) response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) \ud83d\udccc Tushuntirish : - test_api_versioning : v1 va v2 versiyalarini sinaydi. - test_custom_exception_handler : Maxsus xatolik formatini tekshiradi. - test_api_documentation : API sxemasining mavjudligini sinaydi.","title":"\u2705 9. TESTLARNI YANGILASH"},{"location":"drf/advanced-concepts-and-best-practices/#10-docker-sozlamalarini-tekshirish","text":"\ud83d\udccc docker-compose.yml faylida o'zgarishlar talab qilinmaydi, lekin requirements.txt yangilanganligi uchun konteynerni qayta quring: docker-compose up --build","title":"\u2705 10. DOCKER SOZLAMALARINI TEKSHIRISH"},{"location":"drf/advanced-concepts-and-best-practices/#11-sinov-uchun-masalalar","text":"\ud83d\udccc Ilg'or tushunchalar va amaliyotlarni sinash uchun quyidagi amallarni bajarib ko'ring: 1. http://localhost/v1/docs/ manzilida Swagger UI ni oching va API hujjatlarini ko'ring. 2. http://localhost/v1/tasks/ va http://localhost/v2/tasks/ manzillarini sinab, versiyalashni tekshiring. 3. Mavjud bo'lmagan vazifani so'rang ( /v1/tasks/999/ ) va maxsus xatolik formatini ko'ring. 4. python manage.py test bilan yangi testlarni sinab ko'ring. 5. Loglarni debug.log faylida tekshiring va formatlangan xabarlarni ko'ring.","title":"\u2705 11. SINOV UCHUN MASALALAR"},{"location":"drf/api-testing-and-unit-testing/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 15-DARS: API TESTLARI VA UNIT TESTLARI BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida API testlari va unit testlarini yozishni bosqichma-bosqich o'rganamiz. Testlar loyihaning to'g'ri ishlashini ta'minlaydi va kod sifatini oshiradi. Har bir qadam tushunarli va faqat API va unit testlariga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash va Celery asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash va Celery bilan). - Signallar va Celery myapp/signals.py va myapp/tasks.py fayllarida sozlangan. - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. API VA UNIT TESTLARINI TUSHUNISH \ud83d\udccc Unit testlar : Kodning alohida qismlarini (masalan, model yoki serializer metodlari) sinash uchun ishlatiladi. \ud83d\udccc API testlari : API endpointlarining to'g'ri ishlashini, HTTP javoblarini va ma'lumotlar formatini sinash uchun ishlatiladi. \ud83d\udccc Django TestCase va DRFning APITestCase sinflaridan foydalanamiz: - TestCase : Model va umumiy logikani sinash uchun. - APITestCase : API so'rovlarini (GET, POST, PATCH, DELETE) sinash uchun. \ud83d\udccc Testlar loyihaning funksionalligini (masalan, JWT autentifikatsiyasi, ruxsatlar, sahifalash) va Celery signal integratsiyasini tekshiradi. \u2705 3. TESTLAR UCHUN SOZLAMALAR \ud83d\udccc Testlar yozish uchun qo'shimcha paketlar o'rnatish shart emas, chunki Django va DRF o'z ichida test vositalarini ta'minlaydi. \ud83d\udccc Redis va Celery test paytida ishlayotgan bo'lishi kerak. Testlarda Celery vazifalarini sinxron tarzda bajarish uchun CELERY_TASK_ALWAYS_EAGER sozlamasini qo'shamiz. \ud83d\udccc myproject/settings.py faylida test sozlamasini qo'shing: # ... Boshqa sozlamalar ... CELERY_TASK_ALWAYS_EAGER = True # Testlarda Celery vazifalari sinxron bajariladi \u2705 4. TEST FAYLINI YARATISH \ud83d\udccc myapp/tests.py faylini yarating va quyidagi testlarni qo'shing. Testlar model, serializer, API endpointlari va Celery signal integratsiyasini sinaydi: from django.test import TestCase from rest_framework.test import APITestCase from rest_framework import status from django.urls import reverse from django.contrib.auth.models import User from rest_framework_simplejwt.tokens import RefreshToken from .models import Task from .serializers import TaskSerializer import logging # Logger sozlash logger = logging.getLogger(__name__) class TaskModelTest(TestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.task = Task.objects.create( title='Test vazifa', description='Test tavsifi', completed=False, owner=self.user ) def test_task_creation(self): self.assertEqual(self.task.title, 'Test vazifa') self.assertEqual(self.task.owner.username, 'testuser') self.assertFalse(self.task.completed) self.assertEqual(str(self.task), 'Test vazifa') class TaskSerializerTest(TestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.task = Task.objects.create( title='Test vazifa', description='Test tavsifi', owner=self.user ) self.serializer = TaskSerializer(instance=self.task) def test_serializer_contains_expected_fields(self): data = self.serializer.data self.assertEqual(set(data.keys()), {'id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'}) self.assertEqual(data['title'], 'Test vazifa') self.assertEqual(data['status'], 'Bajarilmagan') self.assertEqual(data['owner'], 'testuser') def test_serializer_title_validation(self): invalid_data = {'title': 'ab', 'description': 'Test'} # Title 3 belgidan kam serializer = TaskSerializer(data=invalid_data) self.assertFalse(serializer.is_valid()) self.assertIn('title', serializer.errors) class TaskAPITest(APITestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.other_user = User.objects.create_user(username='otheruser', password='otherpass123') self.task = Task.objects.create( title='Test vazifa', description='Test tavsifi', owner=self.user ) self.token = RefreshToken.for_user(self.user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.token}') def test_get_tasks_list(self): url = reverse('task-list') response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 1) self.assertEqual(response.data['results'][0]['title'], 'Test vazifa') def test_create_task(self): url = reverse('task-list') data = {'title': 'Yangi vazifa', 'description': 'Yangi tavsif'} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_201_CREATED) self.assertEqual(Task.objects.count(), 2) self.assertEqual(Task.objects.latest('id').title, 'Yangi vazifa') def test_update_task_owner_only(self): url = reverse('task-detail', kwargs={'pk': self.task.id}) data = {'completed': True} response = self.client.patch(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK) self.task.refresh_from_db() self.assertTrue(self.task.completed) # Boshqa foydalanuvchi bilan sinash other_token = RefreshToken.for_user(self.other_user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {other_token}') response = self.client.patch(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN) def test_delete_task_owner_only(self): url = reverse('task-detail', kwargs={'pk': self.task.id}) response = self.client.delete(url) self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT) self.assertEqual(Task.objects.count(), 0) # Boshqa foydalanuvchi bilan sinash self.task = Task.objects.create(title='Yana vazifa', owner=self.user) other_token = RefreshToken.for_user(self.other_user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {other_token}') response = self.client.delete(url) self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN) def test_pagination(self): for i in range(5): Task.objects.create(title=f'Vazifa {i}', owner=self.user) url = reverse('task-list') response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 3) # CustomTaskPagination: 3 ta vazifa/sahifa self.assertIn('next', response.data) self.assertIsNone(response.data['previous']) def test_filtering(self): Task.objects.create(title='Bajarilgan vazifa', completed=True, owner=self.user) url = reverse('task-list') + '?completed=true' response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 1) self.assertEqual(response.data['results'][0]['title'], 'Bajarilgan vazifa') class TaskSignalTest(TestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') # Loggingni sinash uchun logger.handlers = [] # Mavjud handlerlarni tozalash self.log_output = logging.StreamHandler() logger.addHandler(self.log_output) logger.setLevel(logging.INFO) def test_task_creation_signal(self): with self.assertLogs('myapp', level='INFO') as cm: Task.objects.create(title='Test vazifa', owner=self.user) self.assertIn('Yangi vazifa yaratildi', cm.output[0]) def test_task_deletion_signal(self): task = Task.objects.create(title='Test vazifa', owner=self.user) with self.assertLogs('myapp', level='INFO') as cm: task.delete() self.assertIn('Vazifa o\\'chirildi', cm.output[0]) \ud83d\udccc Tushuntirish : - TaskModelTest : Modelning to'g'ri yaratilishi va __str__ metodini sinaydi. - TaskSerializerTest : Serializer maydonlari va validatsiyasini sinaydi. - TaskAPITest : API endpointlarini (GET, POST, PATCH, DELETE), JWT autentifikatsiyasini, ruxsatlarni va sahifalashni sinaydi. - TaskSignalTest : Signallar va Celery vazifalarining log yozishini sinaydi. - setUp : Har bir test sinfi uchun boshlang'ich ma'lumotlarni sozlaydi. - assertLogs : Signallarning loglarini tekshiradi. \u2705 5. TESTLARNI ISHGA TUSHIRISH \ud83d\udccc Testlarni ishga tushirish uchun quyidagi buyruqni loyiha papkasida bajaring: python manage.py test \ud83d\udccc Eslatma : Redis serveri va Celery worker ishlayotgan bo'lishi shart emas, chunki CELERY_TASK_ALWAYS_EAGER = True sozlamasi Celery vazifalarini sinxron bajaradi. \u2705 6. LOYIHA SOZLAMALARINI TEKSHIRISH \ud83d\udccc myproject/settings.py faylida quyidagi sozlamalar mavjudligiga ishonch hosil qiling: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } CELERY_BROKER_URL = 'redis://localhost:6379/0' CELERY_RESULT_BACKEND = 'redis://localhost:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = True # Testlarda sinxron bajarish \u2705 7. URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), ] \u2705 8. TESTLARNI SINAB KO'RISH \ud83d\udccc Testlarni ishga tushirish uchun: python manage.py test \ud83d\udccc Natija: Barcha testlar muvaffaqiyatli o'tsa, \"OK\" xabarini ko'rasiz. Agar xato bo'lsa, qaysi test muvaffaqiyatsiz bo'lganini ko'rsatadi. \u2747\ufe0f Test sinovlari : Model testi : Task modelining to'g'ri yaratilishi va __str__ metodini sinaydi. Serializer testi : TaskSerializer maydonlari va title validatsiyasini tekshiradi. API testi : /tasks/ va /tasks/<pk>/ endpointlarining to'g'ri ishlashi, JWT autentifikatsiyasi, IsOwnerOrReadOnly ruxsati va sahifalashni sinaydi. Signal testi : Vazifa yaratilishi va o'chirilishi signallari log yozayotganini tekshiradi. \u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang. \u2705 10. SINOV UCHUN MASALALAR \ud83d\udccc Testlarni sinash uchun quyidagi amallarni bajarib ko'ring: 1. python manage.py test ni ishga tushirib, barcha testlar muvaffaqiyatli o'tganini tekshiring. 2. TaskSerializerTest dagi test_serializer_title_validation testini sinab ko'rish uchun title ga 2 belgi kiriting va xato oling. 3. TaskAPITest dagi test_update_task_owner_only testini sinab ko'ring va boshqa foydalanuvchi 403 Forbidden xatosini olishini tasdiqlang. 4. TaskSignalTest dagi loglarni tekshiring va Celery vazifasi sinxron tarzda ishlayotganini ko'ring.","title":"API Testing and Unit Testing"},{"location":"drf/api-testing-and-unit-testing/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/api-testing-and-unit-testing/#15-dars-api-testlari-va-unit-testlari-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida API testlari va unit testlarini yozishni bosqichma-bosqich o'rganamiz. Testlar loyihaning to'g'ri ishlashini ta'minlaydi va kod sifatini oshiradi. Har bir qadam tushunarli va faqat API va unit testlariga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash va Celery asosida davom etamiz.","title":"\ud83e\udde9 15-DARS: API TESTLARI VA UNIT TESTLARI BILAN ISHLASH"},{"location":"drf/api-testing-and-unit-testing/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash va Celery bilan). - Signallar va Celery myapp/signals.py va myapp/tasks.py fayllarida sozlangan. - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/api-testing-and-unit-testing/#2-api-va-unit-testlarini-tushunish","text":"\ud83d\udccc Unit testlar : Kodning alohida qismlarini (masalan, model yoki serializer metodlari) sinash uchun ishlatiladi. \ud83d\udccc API testlari : API endpointlarining to'g'ri ishlashini, HTTP javoblarini va ma'lumotlar formatini sinash uchun ishlatiladi. \ud83d\udccc Django TestCase va DRFning APITestCase sinflaridan foydalanamiz: - TestCase : Model va umumiy logikani sinash uchun. - APITestCase : API so'rovlarini (GET, POST, PATCH, DELETE) sinash uchun. \ud83d\udccc Testlar loyihaning funksionalligini (masalan, JWT autentifikatsiyasi, ruxsatlar, sahifalash) va Celery signal integratsiyasini tekshiradi.","title":"\u2705 2. API VA UNIT TESTLARINI TUSHUNISH"},{"location":"drf/api-testing-and-unit-testing/#3-testlar-uchun-sozlamalar","text":"\ud83d\udccc Testlar yozish uchun qo'shimcha paketlar o'rnatish shart emas, chunki Django va DRF o'z ichida test vositalarini ta'minlaydi. \ud83d\udccc Redis va Celery test paytida ishlayotgan bo'lishi kerak. Testlarda Celery vazifalarini sinxron tarzda bajarish uchun CELERY_TASK_ALWAYS_EAGER sozlamasini qo'shamiz. \ud83d\udccc myproject/settings.py faylida test sozlamasini qo'shing: # ... Boshqa sozlamalar ... CELERY_TASK_ALWAYS_EAGER = True # Testlarda Celery vazifalari sinxron bajariladi","title":"\u2705 3. TESTLAR UCHUN SOZLAMALAR"},{"location":"drf/api-testing-and-unit-testing/#4-test-faylini-yaratish","text":"\ud83d\udccc myapp/tests.py faylini yarating va quyidagi testlarni qo'shing. Testlar model, serializer, API endpointlari va Celery signal integratsiyasini sinaydi: from django.test import TestCase from rest_framework.test import APITestCase from rest_framework import status from django.urls import reverse from django.contrib.auth.models import User from rest_framework_simplejwt.tokens import RefreshToken from .models import Task from .serializers import TaskSerializer import logging # Logger sozlash logger = logging.getLogger(__name__) class TaskModelTest(TestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.task = Task.objects.create( title='Test vazifa', description='Test tavsifi', completed=False, owner=self.user ) def test_task_creation(self): self.assertEqual(self.task.title, 'Test vazifa') self.assertEqual(self.task.owner.username, 'testuser') self.assertFalse(self.task.completed) self.assertEqual(str(self.task), 'Test vazifa') class TaskSerializerTest(TestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.task = Task.objects.create( title='Test vazifa', description='Test tavsifi', owner=self.user ) self.serializer = TaskSerializer(instance=self.task) def test_serializer_contains_expected_fields(self): data = self.serializer.data self.assertEqual(set(data.keys()), {'id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'}) self.assertEqual(data['title'], 'Test vazifa') self.assertEqual(data['status'], 'Bajarilmagan') self.assertEqual(data['owner'], 'testuser') def test_serializer_title_validation(self): invalid_data = {'title': 'ab', 'description': 'Test'} # Title 3 belgidan kam serializer = TaskSerializer(data=invalid_data) self.assertFalse(serializer.is_valid()) self.assertIn('title', serializer.errors) class TaskAPITest(APITestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.other_user = User.objects.create_user(username='otheruser', password='otherpass123') self.task = Task.objects.create( title='Test vazifa', description='Test tavsifi', owner=self.user ) self.token = RefreshToken.for_user(self.user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.token}') def test_get_tasks_list(self): url = reverse('task-list') response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 1) self.assertEqual(response.data['results'][0]['title'], 'Test vazifa') def test_create_task(self): url = reverse('task-list') data = {'title': 'Yangi vazifa', 'description': 'Yangi tavsif'} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_201_CREATED) self.assertEqual(Task.objects.count(), 2) self.assertEqual(Task.objects.latest('id').title, 'Yangi vazifa') def test_update_task_owner_only(self): url = reverse('task-detail', kwargs={'pk': self.task.id}) data = {'completed': True} response = self.client.patch(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK) self.task.refresh_from_db() self.assertTrue(self.task.completed) # Boshqa foydalanuvchi bilan sinash other_token = RefreshToken.for_user(self.other_user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {other_token}') response = self.client.patch(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN) def test_delete_task_owner_only(self): url = reverse('task-detail', kwargs={'pk': self.task.id}) response = self.client.delete(url) self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT) self.assertEqual(Task.objects.count(), 0) # Boshqa foydalanuvchi bilan sinash self.task = Task.objects.create(title='Yana vazifa', owner=self.user) other_token = RefreshToken.for_user(self.other_user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {other_token}') response = self.client.delete(url) self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN) def test_pagination(self): for i in range(5): Task.objects.create(title=f'Vazifa {i}', owner=self.user) url = reverse('task-list') response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 3) # CustomTaskPagination: 3 ta vazifa/sahifa self.assertIn('next', response.data) self.assertIsNone(response.data['previous']) def test_filtering(self): Task.objects.create(title='Bajarilgan vazifa', completed=True, owner=self.user) url = reverse('task-list') + '?completed=true' response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 1) self.assertEqual(response.data['results'][0]['title'], 'Bajarilgan vazifa') class TaskSignalTest(TestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') # Loggingni sinash uchun logger.handlers = [] # Mavjud handlerlarni tozalash self.log_output = logging.StreamHandler() logger.addHandler(self.log_output) logger.setLevel(logging.INFO) def test_task_creation_signal(self): with self.assertLogs('myapp', level='INFO') as cm: Task.objects.create(title='Test vazifa', owner=self.user) self.assertIn('Yangi vazifa yaratildi', cm.output[0]) def test_task_deletion_signal(self): task = Task.objects.create(title='Test vazifa', owner=self.user) with self.assertLogs('myapp', level='INFO') as cm: task.delete() self.assertIn('Vazifa o\\'chirildi', cm.output[0]) \ud83d\udccc Tushuntirish : - TaskModelTest : Modelning to'g'ri yaratilishi va __str__ metodini sinaydi. - TaskSerializerTest : Serializer maydonlari va validatsiyasini sinaydi. - TaskAPITest : API endpointlarini (GET, POST, PATCH, DELETE), JWT autentifikatsiyasini, ruxsatlarni va sahifalashni sinaydi. - TaskSignalTest : Signallar va Celery vazifalarining log yozishini sinaydi. - setUp : Har bir test sinfi uchun boshlang'ich ma'lumotlarni sozlaydi. - assertLogs : Signallarning loglarini tekshiradi.","title":"\u2705 4. TEST FAYLINI YARATISH"},{"location":"drf/api-testing-and-unit-testing/#5-testlarni-ishga-tushirish","text":"\ud83d\udccc Testlarni ishga tushirish uchun quyidagi buyruqni loyiha papkasida bajaring: python manage.py test \ud83d\udccc Eslatma : Redis serveri va Celery worker ishlayotgan bo'lishi shart emas, chunki CELERY_TASK_ALWAYS_EAGER = True sozlamasi Celery vazifalarini sinxron bajaradi.","title":"\u2705 5. TESTLARNI ISHGA TUSHIRISH"},{"location":"drf/api-testing-and-unit-testing/#6-loyiha-sozlamalarini-tekshirish","text":"\ud83d\udccc myproject/settings.py faylida quyidagi sozlamalar mavjudligiga ishonch hosil qiling: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } CELERY_BROKER_URL = 'redis://localhost:6379/0' CELERY_RESULT_BACKEND = 'redis://localhost:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = True # Testlarda sinxron bajarish","title":"\u2705 6. LOYIHA SOZLAMALARINI TEKSHIRISH"},{"location":"drf/api-testing-and-unit-testing/#7-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), ]","title":"\u2705 7. URL SOZLASH"},{"location":"drf/api-testing-and-unit-testing/#8-testlarni-sinab-korish","text":"\ud83d\udccc Testlarni ishga tushirish uchun: python manage.py test \ud83d\udccc Natija: Barcha testlar muvaffaqiyatli o'tsa, \"OK\" xabarini ko'rasiz. Agar xato bo'lsa, qaysi test muvaffaqiyatsiz bo'lganini ko'rsatadi.","title":"\u2705 8. TESTLARNI SINAB KO'RISH"},{"location":"drf/api-testing-and-unit-testing/#test-sinovlari","text":"Model testi : Task modelining to'g'ri yaratilishi va __str__ metodini sinaydi. Serializer testi : TaskSerializer maydonlari va title validatsiyasini tekshiradi. API testi : /tasks/ va /tasks/<pk>/ endpointlarining to'g'ri ishlashi, JWT autentifikatsiyasi, IsOwnerOrReadOnly ruxsati va sahifalashni sinaydi. Signal testi : Vazifa yaratilishi va o'chirilishi signallari log yozayotganini tekshiradi.","title":"\u2747\ufe0f Test sinovlari:"},{"location":"drf/api-testing-and-unit-testing/#9-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/api-testing-and-unit-testing/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/api-testing-and-unit-testing/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/api-testing-and-unit-testing/#10-sinov-uchun-masalalar","text":"\ud83d\udccc Testlarni sinash uchun quyidagi amallarni bajarib ko'ring: 1. python manage.py test ni ishga tushirib, barcha testlar muvaffaqiyatli o'tganini tekshiring. 2. TaskSerializerTest dagi test_serializer_title_validation testini sinab ko'rish uchun title ga 2 belgi kiriting va xato oling. 3. TaskAPITest dagi test_update_task_owner_only testini sinab ko'ring va boshqa foydalanuvchi 403 Forbidden xatosini olishini tasdiqlang. 4. TaskSignalTest dagi loglarni tekshiring va Celery vazifasi sinxron tarzda ishlayotganini ko'ring.","title":"\u2705 10. SINOV UCHUN MASALALAR"},{"location":"drf/authentication-token-based/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 7-DARS: AUTENTIFIKATSIYA (TOKEN-GA ASOSLANGAN AUTENTIFIKATSIYA) Bu darsda Django REST Framework (DRF) yordamida token-ga asoslangan autentifikatsiyani sozlashni bosqichma-bosqich o'rganamiz. Token autentifikatsiyasi API ga xavfsiz kirishni ta'minlaydi. Har bir qadam tushunarli va faqat token autentifikatsiyasiga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan. - DefaultRouter bilan /tasks/ endpointi myproject/urls.py faylida ro'yxatdan o'tkazilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. TOKEN AUTENTIFIKATSIYASINI TUSHUNISH \ud83d\udccc DRFning token-ga asoslangan autentifikatsiyasi har bir foydalanuvchiga noyob token beradi. Ushbu token API so'rovlarida foydalanuvchi identifikatsiyasi uchun ishlatiladi. Tokenlar HTTP sarlavhalarida (Authorization) yuboriladi. \ud83d\udccc Afzalliklari: - Oddiy va xavfsiz. - Har bir foydalanuvchi uchun alohida token. - Tokenni osongina o'chirish yoki yangilash mumkin. \u2705 3. TOKEN AUTENTIFIKATSIYASINI SOZLASH \ud83d\udccc DRFning o'rnatilgan TokenAuthentication sinfidan foydalanamiz. \u2747\ufe0f DRF autentifikatsiya paketini o'rnatish : \ud83d\udccc Token autentifikatsiyasi uchun qo'shimcha paket o'rnatish shart emas, chunki u DRF bilan birga keladi. Ammo loyihada rest_framework o'rnatilganligini tekshiring: pip install djangorestframework \u2747\ufe0f Token autentifikatsiyasini loyihaga qo'shish : \ud83d\udccc myproject/settings.py faylini yangilang va REST_FRAMEWORK sozlamalarini qo'shing: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', # Token autentifikatsiyasi uchun 'myapp', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', # Faqat autentifikatsiya qilingan foydalanuvchilar uchun ], } \u2747\ufe0f Migratsiyalarni qo'llash : \ud83d\udccc Token autentifikatsiyasi uchun ma'lumotlar bazasida authtoken_token jadvali yaratilishi kerak: python manage.py migrate \u2705 4. VIEWSET NI AUTENTIFIKATSIYA BILAN YANGILASH \ud83d\udccc myapp/views.py faylida TaskViewSet ni autentifikatsiya va ruxsatlar bilan yangilaymiz: from rest_framework import viewsets from rest_framework.permissions import IsAuthenticated from .models import Task from .serializers import TaskSerializer class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated] # Faqat autentifikatsiya qilingan foydalanuvchilar \ud83d\udccc Tushuntirish : - permission_classes = [IsAuthenticated] : Faqat token bilan autentifikatsiya qilingan foydalanuvchilar API ga kira oladi. - TaskViewSet oldingi darsda sozlangan bo'lib, CRUD operatsiyalarini qo'llab-quvvatlaydi. \u2705 5. ROUTER BILAN URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi, lekin token olish uchun qo'shimcha endpoint qo'shamiz: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), # Token olish uchun ] \ud83d\udccc Tushuntirish : - obtain_auth_token : Foydalanuvchi login va parol yordamida token olishi uchun endpoint. - /tasks/ va /tasks/<pk>/ endpointlari TaskViewSet uchun ishlaydi. \u2705 6. FOYDALANUVCHI VA TOKEN YARATISH \ud83d\udccc Token autentifikatsiyasi uchun foydalanuvchi va token yaratamiz. \u2747\ufe0f Foydalanuvchi yaratish : \ud83d\udccc Admin paneli orqali yoki buyruq satri yordamida foydalanuvchi yarating: python manage.py createsuperuser \ud83d\udccc Masalan: username: testuser , password: testpass123 . \u2747\ufe0f Token yaratish : \ud83d\udccc Token olish uchun /api-token-auth/ endpointiga POST so'rov yuboring: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=testuser&password=testpass123\" \ud83d\udccc Javob sifatida token qaytadi, masalan: {\"token\": \"9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\"} \ud83d\udccc Ushbu tokenni saqlang, chunki u API so'rovlarida ishlatiladi. \u2705 7. AUTENTIFIKATSIYA BILAN API NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> . \u2747\ufe0f Create (Yangi vazifa qo'shish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (Postman orqali): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Bu test vazifa\", \"completed\": false}' \ud83d\udccc Token bo'lmasa, 401 Unauthorized xatosi qaytadi. \u2747\ufe0f Read (Ma'lumotlarni o'qish) : Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\" Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\" \u2747\ufe0f Update (Ma'lumotlarni yangilash) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH \ud83d\udccc Masalan : curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' \u2747\ufe0f Delete (Ma'lumotlarni o'chirish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\" \u2705 8. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : \ud83d\udccc Agar hali yaratilmagan bo'lsa: python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida quyidagi kod bo'lishi kerak: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalarni qo'shing, tahrirlang yoki o'chiring. \u2705 9. SINOV UCHUN MASALALAR \ud83d\udccc Token autentifikatsiyasini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /api-token-auth/ manzilidan token oling. 2. Token bilan /tasks/ manzilida yangi vazifa qo'shing. 3. Tokensiz so'rov yuboring va 401 Unauthorized xatosini oling. 4. /tasks/1/ manzilida vazifani yangilang yoki o'chiring.","title":"Authentication (Token-Based Authentication)"},{"location":"drf/authentication-token-based/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/authentication-token-based/#7-dars-autentifikatsiya-token-ga-asoslangan-autentifikatsiya","text":"Bu darsda Django REST Framework (DRF) yordamida token-ga asoslangan autentifikatsiyani sozlashni bosqichma-bosqich o'rganamiz. Token autentifikatsiyasi API ga xavfsiz kirishni ta'minlaydi. Har bir qadam tushunarli va faqat token autentifikatsiyasiga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz.","title":"\ud83e\udde9 7-DARS: AUTENTIFIKATSIYA (TOKEN-GA ASOSLANGAN AUTENTIFIKATSIYA)"},{"location":"drf/authentication-token-based/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan. - DefaultRouter bilan /tasks/ endpointi myproject/urls.py faylida ro'yxatdan o'tkazilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/authentication-token-based/#2-token-autentifikatsiyasini-tushunish","text":"\ud83d\udccc DRFning token-ga asoslangan autentifikatsiyasi har bir foydalanuvchiga noyob token beradi. Ushbu token API so'rovlarida foydalanuvchi identifikatsiyasi uchun ishlatiladi. Tokenlar HTTP sarlavhalarida (Authorization) yuboriladi. \ud83d\udccc Afzalliklari: - Oddiy va xavfsiz. - Har bir foydalanuvchi uchun alohida token. - Tokenni osongina o'chirish yoki yangilash mumkin.","title":"\u2705 2. TOKEN AUTENTIFIKATSIYASINI TUSHUNISH"},{"location":"drf/authentication-token-based/#3-token-autentifikatsiyasini-sozlash","text":"\ud83d\udccc DRFning o'rnatilgan TokenAuthentication sinfidan foydalanamiz.","title":"\u2705 3. TOKEN AUTENTIFIKATSIYASINI SOZLASH"},{"location":"drf/authentication-token-based/#drf-autentifikatsiya-paketini-ornatish","text":"\ud83d\udccc Token autentifikatsiyasi uchun qo'shimcha paket o'rnatish shart emas, chunki u DRF bilan birga keladi. Ammo loyihada rest_framework o'rnatilganligini tekshiring: pip install djangorestframework","title":"\u2747\ufe0f DRF autentifikatsiya paketini o'rnatish:"},{"location":"drf/authentication-token-based/#token-autentifikatsiyasini-loyihaga-qoshish","text":"\ud83d\udccc myproject/settings.py faylini yangilang va REST_FRAMEWORK sozlamalarini qo'shing: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', # Token autentifikatsiyasi uchun 'myapp', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', # Faqat autentifikatsiya qilingan foydalanuvchilar uchun ], }","title":"\u2747\ufe0f Token autentifikatsiyasini loyihaga qo'shish:"},{"location":"drf/authentication-token-based/#migratsiyalarni-qollash","text":"\ud83d\udccc Token autentifikatsiyasi uchun ma'lumotlar bazasida authtoken_token jadvali yaratilishi kerak: python manage.py migrate","title":"\u2747\ufe0f Migratsiyalarni qo'llash:"},{"location":"drf/authentication-token-based/#4-viewset-ni-autentifikatsiya-bilan-yangilash","text":"\ud83d\udccc myapp/views.py faylida TaskViewSet ni autentifikatsiya va ruxsatlar bilan yangilaymiz: from rest_framework import viewsets from rest_framework.permissions import IsAuthenticated from .models import Task from .serializers import TaskSerializer class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated] # Faqat autentifikatsiya qilingan foydalanuvchilar \ud83d\udccc Tushuntirish : - permission_classes = [IsAuthenticated] : Faqat token bilan autentifikatsiya qilingan foydalanuvchilar API ga kira oladi. - TaskViewSet oldingi darsda sozlangan bo'lib, CRUD operatsiyalarini qo'llab-quvvatlaydi.","title":"\u2705 4. VIEWSET NI AUTENTIFIKATSIYA BILAN YANGILASH"},{"location":"drf/authentication-token-based/#5-router-bilan-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi, lekin token olish uchun qo'shimcha endpoint qo'shamiz: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), # Token olish uchun ] \ud83d\udccc Tushuntirish : - obtain_auth_token : Foydalanuvchi login va parol yordamida token olishi uchun endpoint. - /tasks/ va /tasks/<pk>/ endpointlari TaskViewSet uchun ishlaydi.","title":"\u2705 5. ROUTER BILAN URL SOZLASH"},{"location":"drf/authentication-token-based/#6-foydalanuvchi-va-token-yaratish","text":"\ud83d\udccc Token autentifikatsiyasi uchun foydalanuvchi va token yaratamiz.","title":"\u2705 6. FOYDALANUVCHI VA TOKEN YARATISH"},{"location":"drf/authentication-token-based/#foydalanuvchi-yaratish","text":"\ud83d\udccc Admin paneli orqali yoki buyruq satri yordamida foydalanuvchi yarating: python manage.py createsuperuser \ud83d\udccc Masalan: username: testuser , password: testpass123 .","title":"\u2747\ufe0f Foydalanuvchi yaratish:"},{"location":"drf/authentication-token-based/#token-yaratish","text":"\ud83d\udccc Token olish uchun /api-token-auth/ endpointiga POST so'rov yuboring: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=testuser&password=testpass123\" \ud83d\udccc Javob sifatida token qaytadi, masalan: {\"token\": \"9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\"} \ud83d\udccc Ushbu tokenni saqlang, chunki u API so'rovlarida ishlatiladi.","title":"\u2747\ufe0f Token yaratish:"},{"location":"drf/authentication-token-based/#7-autentifikatsiya-bilan-api-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> .","title":"\u2705 7. AUTENTIFIKATSIYA BILAN API NI SINAB KO'RISH"},{"location":"drf/authentication-token-based/#create-yangi-vazifa-qoshish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (Postman orqali): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Bu test vazifa\", \"completed\": false}' \ud83d\udccc Token bo'lmasa, 401 Unauthorized xatosi qaytadi.","title":"\u2747\ufe0f Create (Yangi vazifa qo'shish):"},{"location":"drf/authentication-token-based/#read-malumotlarni-oqish","text":"Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\" Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\"","title":"\u2747\ufe0f Read (Ma'lumotlarni o'qish):"},{"location":"drf/authentication-token-based/#update-malumotlarni-yangilash","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH \ud83d\udccc Masalan : curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\" -H \"Content-Type: application/json\" -d '{\"completed\": true}'","title":"\u2747\ufe0f Update (Ma'lumotlarni yangilash):"},{"location":"drf/authentication-token-based/#delete-malumotlarni-ochirish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbafc6ee0b\"","title":"\u2747\ufe0f Delete (Ma'lumotlarni o'chirish):"},{"location":"drf/authentication-token-based/#8-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 8. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/authentication-token-based/#admin-foydalanuvchisini-tekshirish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa: python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/authentication-token-based/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida quyidagi kod bo'lishi kerak: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalarni qo'shing, tahrirlang yoki o'chiring.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/authentication-token-based/#9-sinov-uchun-masalalar","text":"\ud83d\udccc Token autentifikatsiyasini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /api-token-auth/ manzilidan token oling. 2. Token bilan /tasks/ manzilida yangi vazifa qo'shing. 3. Tokensiz so'rov yuboring va 401 Unauthorized xatosini oling. 4. /tasks/1/ manzilida vazifani yangilang yoki o'chiring.","title":"\u2705 9. SINOV UCHUN MASALALAR"},{"location":"drf/background-tasks-and-celery/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 14-DARS: FON VAZIFALARI VA CELERY BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida fon vazifalarini (background tasks) va Celery bilan ishlashni bosqichma-bosqich o'rganamiz. Celery uzoq davom etadigan yoki resurs talab qiladigan vazifalarni asinxron tarzda bajarish uchun ishlatiladi. Har bir qadam tushunarli va faqat fon vazifalari va Celery ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar va signallar asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash va sahifalash bilan). - Signallar myapp/signals.py faylida sozlangan. - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. CELERY VA FON VAZIFALARINI TUSHUNISH \ud83d\udccc Celery \u2014 Python loyihalarida asinxron vazifalarni boshqarish uchun kuchli vosita. U uzoq vaqt talab qiladigan vazifalarni (masalan, log yozish, email yuborish) asosiy ilova jarayonidan ajratib, fon rejimida bajaradi. \ud83d\udccc Fon vazifalari : - API so'rovlarining tezligini oshiradi. - Serverni ortiqcha yukdan himoya qiladi. - Vazifalarni parallel ravishda bajarish imkonini beradi. \ud83d\udccc Celery ishlatish uchun Redis yoki RabbitMQ kabi xabar brokeri talab qilinadi. Ushbu darsda Redis dan foydalanamiz. \u2705 3. CELERY VA REDIS NI O'RNATISH \ud83d\udccc Quyidagi paketlarni o'rnatamiz: pip install celery redis \ud83d\udccc Redis ni o'rnatish (masalan, Ubuntu uchun): sudo apt-get install redis-server \ud83d\udccc Redis serverini ishga tushiring va uning ishlayotganligini tekshiring: redis-server redis-cli ping # Javob: PONG \u2705 4. CELERY SOZLAMALARINI QO'SHISH \ud83d\udccc myproject papkasida celery.py faylini yarating va quyidagi kodni qo'shing: import os from celery import Celery os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings') app = Celery('myproject') app.config_from_object('django.conf:settings', namespace='CELERY') app.autodiscover_tasks() \ud83d\udccc Tushuntirish : - Celery('myproject') : Celery ilovasini yaratadi. - config_from_object : Django sozlamalaridan Celery konfiguratsiyasini oladi. - autodiscover_tasks : Ilovadagi vazifalarni avtomatik topadi. \ud83d\udccc myproject/__init__.py faylini yangilang: from .celery import app as celery_app __all__ = ('celery_app',) \u2705 5. LOYIHA SOZLAMALARINI YANGILASH \ud83d\udccc myproject/settings.py faylida Celery va Redis sozlamalarini qo'shamiz: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } # Celery sozlamalari CELERY_BROKER_URL = 'redis://localhost:6379/0' # Redis broker manzili CELERY_RESULT_BACKEND = 'redis://localhost:6379/0' # Natijalarni saqlash uchun CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' # O'zbekiston vaqt zonasi \ud83d\udccc Tushuntirish : - CELERY_BROKER_URL : Redis server manzili (standart port 6379). - CELERY_TIMEZONE : Vaqt zonasi sifatida Asia/Tashkent ishlatiladi. \u2705 6. FON VAZIFASINI YARATISH \ud83d\udccc myapp/tasks.py faylini yarating va vazifa yaratilganda log yozish uchun fon vazifasini qo'shing: from celery import shared_task import logging logger = logging.getLogger(__name__) @shared_task def log_task_creation(task_id, task_title, owner_username): logger.info(f\"[Celery] Yangi vazifa yaratildi: {task_title} (ID: {task_id}, Owner: {owner_username})\") \ud83d\udccc Tushuntirish : - @shared_task : Celery vazifasini belgilaydi. - log_task_creation : Vazifa yaratilganda log yozadi. \u2705 7. SIGNALLARNI CELERY BILAN INTEGRATSIYA QILISH \ud83d\udccc myapp/signals.py faylini yangilaymiz va vazifa yaratilganda Celery vazifasini chaqiramiz: from django.db.models.signals import post_save, post_delete from django.dispatch import receiver from .models import Task from .tasks import log_task_creation import logging logger = logging.getLogger(__name__) @receiver(post_save, sender=Task) def handle_task_creation(sender, instance, created, **kwargs): if created: # Celery vazifasini fon rejimida ishga tushirish log_task_creation.delay(instance.id, instance.title, instance.owner.username) else: logger.info(f\"Vazifa yangilandi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") @receiver(post_delete, sender=Task) def log_task_deletion(sender, instance, **kwargs): logger.info(f\"Vazifa o'chirildi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") \ud83d\udccc Tushuntirish : - log_task_creation.delay : Celery vazifasini asinxron tarzda ishga tushiradi. - post_delete signali o'zgarmagan holda qoldi. \u2705 8. CELERY ISHGA TUSHIRISH \ud83d\udccc Celery worker ni ishga tushirish uchun yangi terminal oching va loyiha papkasida quyidagi buyruqni bajaring: celery -A myproject worker --loglevel=info \ud83d\udccc Eslatma : Redis serveri ishlayotgan bo'lishi kerak. \u2705 9. VIEWSET NI TEKSHIRISH \ud83d\udccc myapp/views.py faylida TaskViewSet oldingi darsdagidek qoladi: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user) \u2705 10. URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), ] \u2705 11. CELERY VAZIFALARINI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Celery worker ni alohida terminalda ishga tushiring: celery -A myproject worker --loglevel=info \u2747\ufe0f Foydalanuvchi va token yaratish : \ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc JWT token oling: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"user1\", \"password\": \"pass123\"}' \u2747\ufe0f Vazifa yaratish va Celery sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test vazifa\"}' \ud83d\udccc Celery worker terminalida yoki debug.log faylida quyidagi logni ko'rasiz: [Celery] Yangi vazifa yaratildi: Yangi vazifa (ID: 1, Owner: user1) \u2747\ufe0f Vazifa yangilash va signal sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' \ud83d\udccc Log (Celery emas, signal orqali): Vazifa yangilandi: Yangi vazifa (ID: 1, Owner: user1) \u2747\ufe0f Vazifa o'chirish va signal sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" \ud83d\udccc Log: Vazifa o'chirildi: Yangi vazifa (ID: 1, Owner: user1) \u2705 12. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang va loglarni tekshiring. \u2705 13. SINOV UCHUN MASALALAR \ud83d\udccc Celery vazifalarini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va debug.log yoki Celery terminalida logni tekshiring. 2. Admin panelida vazifa qo'shing va Celery logini ko'ring. 3. Celery workerni o'chirib, vazifa qo'shing va logning kechiktirilganligini tekshiring. 4. /tasks/1/ manzilida vazifani yangilang va signal logini tekshiring.","title":"Background Tasks and Celery"},{"location":"drf/background-tasks-and-celery/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/background-tasks-and-celery/#14-dars-fon-vazifalari-va-celery-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida fon vazifalarini (background tasks) va Celery bilan ishlashni bosqichma-bosqich o'rganamiz. Celery uzoq davom etadigan yoki resurs talab qiladigan vazifalarni asinxron tarzda bajarish uchun ishlatiladi. Har bir qadam tushunarli va faqat fon vazifalari va Celery ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar va signallar asosida davom etamiz.","title":"\ud83e\udde9 14-DARS: FON VAZIFALARI VA CELERY BILAN ISHLASH"},{"location":"drf/background-tasks-and-celery/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash va sahifalash bilan). - Signallar myapp/signals.py faylida sozlangan. - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/background-tasks-and-celery/#2-celery-va-fon-vazifalarini-tushunish","text":"\ud83d\udccc Celery \u2014 Python loyihalarida asinxron vazifalarni boshqarish uchun kuchli vosita. U uzoq vaqt talab qiladigan vazifalarni (masalan, log yozish, email yuborish) asosiy ilova jarayonidan ajratib, fon rejimida bajaradi. \ud83d\udccc Fon vazifalari : - API so'rovlarining tezligini oshiradi. - Serverni ortiqcha yukdan himoya qiladi. - Vazifalarni parallel ravishda bajarish imkonini beradi. \ud83d\udccc Celery ishlatish uchun Redis yoki RabbitMQ kabi xabar brokeri talab qilinadi. Ushbu darsda Redis dan foydalanamiz.","title":"\u2705 2. CELERY VA FON VAZIFALARINI TUSHUNISH"},{"location":"drf/background-tasks-and-celery/#3-celery-va-redis-ni-ornatish","text":"\ud83d\udccc Quyidagi paketlarni o'rnatamiz: pip install celery redis \ud83d\udccc Redis ni o'rnatish (masalan, Ubuntu uchun): sudo apt-get install redis-server \ud83d\udccc Redis serverini ishga tushiring va uning ishlayotganligini tekshiring: redis-server redis-cli ping # Javob: PONG","title":"\u2705 3. CELERY VA REDIS NI O'RNATISH"},{"location":"drf/background-tasks-and-celery/#4-celery-sozlamalarini-qoshish","text":"\ud83d\udccc myproject papkasida celery.py faylini yarating va quyidagi kodni qo'shing: import os from celery import Celery os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings') app = Celery('myproject') app.config_from_object('django.conf:settings', namespace='CELERY') app.autodiscover_tasks() \ud83d\udccc Tushuntirish : - Celery('myproject') : Celery ilovasini yaratadi. - config_from_object : Django sozlamalaridan Celery konfiguratsiyasini oladi. - autodiscover_tasks : Ilovadagi vazifalarni avtomatik topadi. \ud83d\udccc myproject/__init__.py faylini yangilang: from .celery import app as celery_app __all__ = ('celery_app',)","title":"\u2705 4. CELERY SOZLAMALARINI QO'SHISH"},{"location":"drf/background-tasks-and-celery/#5-loyiha-sozlamalarini-yangilash","text":"\ud83d\udccc myproject/settings.py faylida Celery va Redis sozlamalarini qo'shamiz: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } # Celery sozlamalari CELERY_BROKER_URL = 'redis://localhost:6379/0' # Redis broker manzili CELERY_RESULT_BACKEND = 'redis://localhost:6379/0' # Natijalarni saqlash uchun CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' # O'zbekiston vaqt zonasi \ud83d\udccc Tushuntirish : - CELERY_BROKER_URL : Redis server manzili (standart port 6379). - CELERY_TIMEZONE : Vaqt zonasi sifatida Asia/Tashkent ishlatiladi.","title":"\u2705 5. LOYIHA SOZLAMALARINI YANGILASH"},{"location":"drf/background-tasks-and-celery/#6-fon-vazifasini-yaratish","text":"\ud83d\udccc myapp/tasks.py faylini yarating va vazifa yaratilganda log yozish uchun fon vazifasini qo'shing: from celery import shared_task import logging logger = logging.getLogger(__name__) @shared_task def log_task_creation(task_id, task_title, owner_username): logger.info(f\"[Celery] Yangi vazifa yaratildi: {task_title} (ID: {task_id}, Owner: {owner_username})\") \ud83d\udccc Tushuntirish : - @shared_task : Celery vazifasini belgilaydi. - log_task_creation : Vazifa yaratilganda log yozadi.","title":"\u2705 6. FON VAZIFASINI YARATISH"},{"location":"drf/background-tasks-and-celery/#7-signallarni-celery-bilan-integratsiya-qilish","text":"\ud83d\udccc myapp/signals.py faylini yangilaymiz va vazifa yaratilganda Celery vazifasini chaqiramiz: from django.db.models.signals import post_save, post_delete from django.dispatch import receiver from .models import Task from .tasks import log_task_creation import logging logger = logging.getLogger(__name__) @receiver(post_save, sender=Task) def handle_task_creation(sender, instance, created, **kwargs): if created: # Celery vazifasini fon rejimida ishga tushirish log_task_creation.delay(instance.id, instance.title, instance.owner.username) else: logger.info(f\"Vazifa yangilandi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") @receiver(post_delete, sender=Task) def log_task_deletion(sender, instance, **kwargs): logger.info(f\"Vazifa o'chirildi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") \ud83d\udccc Tushuntirish : - log_task_creation.delay : Celery vazifasini asinxron tarzda ishga tushiradi. - post_delete signali o'zgarmagan holda qoldi.","title":"\u2705 7. SIGNALLARNI CELERY BILAN INTEGRATSIYA QILISH"},{"location":"drf/background-tasks-and-celery/#8-celery-ishga-tushirish","text":"\ud83d\udccc Celery worker ni ishga tushirish uchun yangi terminal oching va loyiha papkasida quyidagi buyruqni bajaring: celery -A myproject worker --loglevel=info \ud83d\udccc Eslatma : Redis serveri ishlayotgan bo'lishi kerak.","title":"\u2705 8. CELERY ISHGA TUSHIRISH"},{"location":"drf/background-tasks-and-celery/#9-viewset-ni-tekshirish","text":"\ud83d\udccc myapp/views.py faylida TaskViewSet oldingi darsdagidek qoladi: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user)","title":"\u2705 9. VIEWSET NI TEKSHIRISH"},{"location":"drf/background-tasks-and-celery/#10-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), ]","title":"\u2705 10. URL SOZLASH"},{"location":"drf/background-tasks-and-celery/#11-celery-vazifalarini-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Celery worker ni alohida terminalda ishga tushiring: celery -A myproject worker --loglevel=info","title":"\u2705 11. CELERY VAZIFALARINI SINAB KO'RISH"},{"location":"drf/background-tasks-and-celery/#foydalanuvchi-va-token-yaratish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc JWT token oling: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"user1\", \"password\": \"pass123\"}'","title":"\u2747\ufe0f Foydalanuvchi va token yaratish:"},{"location":"drf/background-tasks-and-celery/#vazifa-yaratish-va-celery-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test vazifa\"}' \ud83d\udccc Celery worker terminalida yoki debug.log faylida quyidagi logni ko'rasiz: [Celery] Yangi vazifa yaratildi: Yangi vazifa (ID: 1, Owner: user1)","title":"\u2747\ufe0f Vazifa yaratish va Celery sinovi:"},{"location":"drf/background-tasks-and-celery/#vazifa-yangilash-va-signal-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' \ud83d\udccc Log (Celery emas, signal orqali): Vazifa yangilandi: Yangi vazifa (ID: 1, Owner: user1)","title":"\u2747\ufe0f Vazifa yangilash va signal sinovi:"},{"location":"drf/background-tasks-and-celery/#vazifa-ochirish-va-signal-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" \ud83d\udccc Log: Vazifa o'chirildi: Yangi vazifa (ID: 1, Owner: user1)","title":"\u2747\ufe0f Vazifa o'chirish va signal sinovi:"},{"location":"drf/background-tasks-and-celery/#12-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 12. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/background-tasks-and-celery/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/background-tasks-and-celery/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang va loglarni tekshiring.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/background-tasks-and-celery/#13-sinov-uchun-masalalar","text":"\ud83d\udccc Celery vazifalarini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va debug.log yoki Celery terminalida logni tekshiring. 2. Admin panelida vazifa qo'shing va Celery logini ko'ring. 3. Celery workerni o'chirib, vazifa qo'shing va logning kechiktirilganligini tekshiring. 4. /tasks/1/ manzilida vazifani yangilang va signal logini tekshiring.","title":"\u2705 13. SINOV UCHUN MASALALAR"},{"location":"drf/caching-and-performance-optimization/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 16-DARS: KESHLASH VA ISHLASHNI OPTIMALASHTIRISH Bu darsda Django REST Framework (DRF) yordamida keshlash (caching) va ishlashni optimallashtirish usullarini bosqichma-bosqich o'rganamiz. Keshlash API javoblarini tezkorlashtiradi va server yukini kamaytiradi. Har bir qadam tushunarli va faqat keshlash va ishlash optimallashtirishga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash, signallar va Celery asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash va Celery bilan). - Signallar va Celery myapp/signals.py va myapp/tasks.py fayllarida sozlangan. - Testlar myapp/tests.py faylida yozilgan. - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. KESHLASH VA ISHLASH OPTIMALASHTIRISH NI TUSHUNISH \ud83d\udccc Keshlash : Tez-tez so'raladigan ma'lumotlarni vaqtincha saqlab, ma'lumotlar bazasiga murojaatlarni kamaytiradi, bu esa javob vaqtini qisqartiradi. \ud83d\udccc Ishlash optimallashtirish : API so'rovlarini tezkorlashtirish uchun turli usullar (masalan, keshlash, ma'lumotlar bazasi so'rovlarini optimallashtirish) qo'llaniladi. \ud83d\udccc DRF keshlash turlari: - Per-view keshlash : Muayyan view uchun keshlash. - Per-site keshlash : Butun sayt uchun global keshlash. - Backend keshlash : Redis yoki Memcached kabi tizimlar bilan. \ud83d\udccc Ushbu darsda Redis bilan keshlash va ma'lumotlar bazasi so'rovlarini optimallashtirishga e'tibor qaratamiz. \u2705 3. REDIS KESHLASH UCHUN SOZLASH \ud83d\udccc Oldingi darsda Redis allaqachon Celery uchun o'rnatilgan. Agar hali o'rnatilmagan bo'lsa: pip install redis sudo apt-get install redis-server # Ubuntu uchun \ud83d\udccc Redis serverini ishga tushiring: redis-server redis-cli ping # Javob: PONG \u2705 4. LOYIHA SOZLAMALARINI YANGILASH \ud83d\udccc myproject/settings.py faylida keshlash sozlamalarini qo'shamiz: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } # Celery sozlamalari CELERY_BROKER_URL = 'redis://localhost:6379/0' CELERY_RESULT_BACKEND = 'redis://localhost:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = True # Keshlash sozlamalari CACHES = { 'default': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://127.0.0.1:6379/1', # Celery dan farqli database (1) 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', } } } \ud83d\udccc Tushuntirish : - CACHES : Redis ni kesh backend sifatida sozlaydi. Celery dan farqli database (1) ishlatiladi. - LOCATION : Redis server manzili, database 1 uchun. \u2705 5. KESHLASHNI VIEWSET GA QO'SHISH \ud83d\udccc TaskViewSet da /tasks/ endpointi uchun keshlashni qo'shamiz. myapp/views.py faylini yangilaymiz: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from rest_framework.decorators import action from django.views.decorators.cache import cache_page from django.utils.decorators import method_decorator from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user) @method_decorator(cache_page(60 * 5)) # 5 daqiqa keshlash def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) \ud83d\udccc Tushuntirish : - cache_page(60 * 5) : /tasks/ endpointi uchun javobni 5 daqiqa keshlaydi. - @method_decorator : DRF viewset metodlarida keshlashni qo'llash uchun ishlatiladi. - Faqat list (GET /tasks/) metodi keshlanadi, chunki u eng ko'p so'raladigan operatsiya. \u2705 6. MA'LUMOTLAR BAZASI SO'ROVLARINI OPTIMALASHTIRISH \ud83d\udccc Ma'lumotlar bazasi so'rovlarini kamaytirish uchun Task modelidagi owner maydoniga select_related qo'shamiz: class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all().select_related('owner') # owner maydonini oldindan yuklash serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user) @method_decorator(cache_page(60 * 5)) def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) \ud83d\udccc Tushuntirish : - select_related('owner') : owner maydonini oldindan yuklaydi, bu esa qo'shimcha ma'lumotlar bazasi so'rovlarini kamaytiradi. \u2705 7. TESTLARNI YANGILASH \ud83d\udccc Keshlashni sinash uchun myapp/tests.py fayliga yangi test qo'shamiz: from django.test import TestCase from rest_framework.test import APITestCase from rest_framework import status from django.urls import reverse from django.contrib.auth.models import User from rest_framework_simplejwt.tokens import RefreshToken from .models import Task from .serializers import TaskSerializer from django.core.cache import cache import logging logger = logging.getLogger(__name__) # Oldingi testlar (TaskModelTest, TaskSerializerTest, TaskSignalTest) shu yerda qoladi class TaskAPITest(APITestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.other_user = User.objects.create_user(username='otheruser', password='otherpass123') self.task = Task.objects.create( title='Test vazifa', description='Test tavsifi', owner=self.user ) self.token = RefreshToken.for_user(self.user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.token}') cache.clear() # Testdan oldin keshni tozalash def test_get_tasks_list(self): url = reverse('task-list') response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 1) self.assertEqual(response.data['results'][0]['title'], 'Test vazifa') def test_create_task(self): url = reverse('task-list') data = {'title': 'Yangi vazifa', 'description': 'Yangi tavsif'} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_201_CREATED) self.assertEqual(Task.objects.count(), 2) self.assertEqual(Task.objects.latest('id').title, 'Yangi vazifa') def test_update_task_owner_only(self): url = reverse('task-detail', kwargs={'pk': self.task.id}) data = {'completed': True} response = self.client.patch(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK) self.task.refresh_from_db() self.assertTrue(self.task.completed) other_token = RefreshToken.for_user(self.other_user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {other_token}') response = self.client.patch(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN) def test_delete_task_owner_only(self): url = reverse('task-detail', kwargs={'pk': self.task.id}) response = self.client.delete(url) self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT) self.assertEqual(Task.objects.count(), 0) self.task = Task.objects.create(title='Yana vazifa', owner=self.user) other_token = RefreshToken.for_user(self.other_user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {other_token}') response = self.client.delete(url) self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN) def test_pagination(self): for i in range(5): Task.objects.create(title=f'Vazifa {i}', owner=self.user) url = reverse('task-list') response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 3) self.assertIn('next', response.data) self.assertIsNone(response.data['previous']) def test_filtering(self): Task.objects.create(title='Bajarilgan vazifa', completed=True, owner=self.user) url = reverse('task-list') + '?completed=true' response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 1) self.assertEqual(response.data['results'][0]['title'], 'Bajarilgan vazifa') def test_caching(self): url = reverse('task-list') # Birinchi so'rov response1 = self.client.get(url) self.assertEqual(response1.status_code, status.HTTP_200_OK) # Keshdan ikkinchi so'rov response2 = self.client.get(url) self.assertEqual(response2.status_code, status.HTTP_200_OK) self.assertEqual(response1.data, response2.data) # Keshlangan javob bir xil # Yangi vazifa qo'shish keshni yangilamaydi Task.objects.create(title='Kesh sinovi', owner=self.user) response3 = self.client.get(url) self.assertEqual(len(response3.data['results']), len(response1.data['results'])) # Keshlangan natija \ud83d\udccc Tushuntirish : - test_caching : /tasks/ endpointining keshlanganligini sinaydi. - cache.clear() : Testdan oldin keshni tozalaydi. - Keshlangan javob bir xil bo'lishi va yangi vazifa qo'shilganda keshning yangilanmasligi tekshiriladi. \u2705 8. URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), ] \u2705 9. KESHLASH VA ISHLASHNI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Redis serverini ishga tushiring: redis-server \ud83d\udccc Celery worker ni ishga tushiring (ixtiyoriy, testlar uchun shart emas): celery -A myproject worker --loglevel=info \u2747\ufe0f Foydalanuvchi va token yaratish : \ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: testuser, password: testpass123 \ud83d\udccc JWT token oling: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"testuser\", \"password\": \"testpass123\"}' \u2747\ufe0f Keshlash sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" \ud83d\udccc Birinchi so'rov ma'lumotlar bazasidan olinadi, keyingi so'rovlar 5 daqiqa davomida keshdan qaytariladi. Yangi vazifa qo'shing: curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test\"}' \ud83d\udccc /tasks/ ni qayta so'rang \u2014 kesh tufayli yangi vazifa ko'rinmaydi. \u2747\ufe0f Testlarni ishga tushirish : python manage.py test \ud83d\udccc test_caching testi keshning to'g'ri ishlashini tasdiqlaydi. \u2705 10. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang. \u2705 11. SINOV UCHUN MASALALAR \ud83d\udccc Keshlash va ishlashni sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manziliga bir necha marta GET so'rov yuboring va javob vaqtini solishtiring. 2. Yangi vazifa qo'shing va /tasks/ manzilida kesh tufayli yangi vazifa ko'rinmasligini tekshiring. 3. python manage.py test bilan test_caching testini sinab ko'ring. 4. select_related effekti uchun ma'lumotlar bazasi so'rovlarini (Django Debug Toolbar bilan) tekshiring.","title":"Caching and Performance Optimization"},{"location":"drf/caching-and-performance-optimization/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/caching-and-performance-optimization/#16-dars-keshlash-va-ishlashni-optimalashtirish","text":"Bu darsda Django REST Framework (DRF) yordamida keshlash (caching) va ishlashni optimallashtirish usullarini bosqichma-bosqich o'rganamiz. Keshlash API javoblarini tezkorlashtiradi va server yukini kamaytiradi. Har bir qadam tushunarli va faqat keshlash va ishlash optimallashtirishga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash, signallar va Celery asosida davom etamiz.","title":"\ud83e\udde9 16-DARS: KESHLASH VA ISHLASHNI OPTIMALASHTIRISH"},{"location":"drf/caching-and-performance-optimization/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash va Celery bilan). - Signallar va Celery myapp/signals.py va myapp/tasks.py fayllarida sozlangan. - Testlar myapp/tests.py faylida yozilgan. - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/caching-and-performance-optimization/#2-keshlash-va-ishlash-optimalashtirish-ni-tushunish","text":"\ud83d\udccc Keshlash : Tez-tez so'raladigan ma'lumotlarni vaqtincha saqlab, ma'lumotlar bazasiga murojaatlarni kamaytiradi, bu esa javob vaqtini qisqartiradi. \ud83d\udccc Ishlash optimallashtirish : API so'rovlarini tezkorlashtirish uchun turli usullar (masalan, keshlash, ma'lumotlar bazasi so'rovlarini optimallashtirish) qo'llaniladi. \ud83d\udccc DRF keshlash turlari: - Per-view keshlash : Muayyan view uchun keshlash. - Per-site keshlash : Butun sayt uchun global keshlash. - Backend keshlash : Redis yoki Memcached kabi tizimlar bilan. \ud83d\udccc Ushbu darsda Redis bilan keshlash va ma'lumotlar bazasi so'rovlarini optimallashtirishga e'tibor qaratamiz.","title":"\u2705 2. KESHLASH VA ISHLASH OPTIMALASHTIRISH NI TUSHUNISH"},{"location":"drf/caching-and-performance-optimization/#3-redis-keshlash-uchun-sozlash","text":"\ud83d\udccc Oldingi darsda Redis allaqachon Celery uchun o'rnatilgan. Agar hali o'rnatilmagan bo'lsa: pip install redis sudo apt-get install redis-server # Ubuntu uchun \ud83d\udccc Redis serverini ishga tushiring: redis-server redis-cli ping # Javob: PONG","title":"\u2705 3. REDIS KESHLASH UCHUN SOZLASH"},{"location":"drf/caching-and-performance-optimization/#4-loyiha-sozlamalarini-yangilash","text":"\ud83d\udccc myproject/settings.py faylida keshlash sozlamalarini qo'shamiz: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } # Celery sozlamalari CELERY_BROKER_URL = 'redis://localhost:6379/0' CELERY_RESULT_BACKEND = 'redis://localhost:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = True # Keshlash sozlamalari CACHES = { 'default': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://127.0.0.1:6379/1', # Celery dan farqli database (1) 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', } } } \ud83d\udccc Tushuntirish : - CACHES : Redis ni kesh backend sifatida sozlaydi. Celery dan farqli database (1) ishlatiladi. - LOCATION : Redis server manzili, database 1 uchun.","title":"\u2705 4. LOYIHA SOZLAMALARINI YANGILASH"},{"location":"drf/caching-and-performance-optimization/#5-keshlashni-viewset-ga-qoshish","text":"\ud83d\udccc TaskViewSet da /tasks/ endpointi uchun keshlashni qo'shamiz. myapp/views.py faylini yangilaymiz: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from rest_framework.decorators import action from django.views.decorators.cache import cache_page from django.utils.decorators import method_decorator from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user) @method_decorator(cache_page(60 * 5)) # 5 daqiqa keshlash def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) \ud83d\udccc Tushuntirish : - cache_page(60 * 5) : /tasks/ endpointi uchun javobni 5 daqiqa keshlaydi. - @method_decorator : DRF viewset metodlarida keshlashni qo'llash uchun ishlatiladi. - Faqat list (GET /tasks/) metodi keshlanadi, chunki u eng ko'p so'raladigan operatsiya.","title":"\u2705 5. KESHLASHNI VIEWSET GA QO'SHISH"},{"location":"drf/caching-and-performance-optimization/#6-malumotlar-bazasi-sorovlarini-optimalashtirish","text":"\ud83d\udccc Ma'lumotlar bazasi so'rovlarini kamaytirish uchun Task modelidagi owner maydoniga select_related qo'shamiz: class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all().select_related('owner') # owner maydonini oldindan yuklash serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user) @method_decorator(cache_page(60 * 5)) def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) \ud83d\udccc Tushuntirish : - select_related('owner') : owner maydonini oldindan yuklaydi, bu esa qo'shimcha ma'lumotlar bazasi so'rovlarini kamaytiradi.","title":"\u2705 6. MA'LUMOTLAR BAZASI SO'ROVLARINI OPTIMALASHTIRISH"},{"location":"drf/caching-and-performance-optimization/#7-testlarni-yangilash","text":"\ud83d\udccc Keshlashni sinash uchun myapp/tests.py fayliga yangi test qo'shamiz: from django.test import TestCase from rest_framework.test import APITestCase from rest_framework import status from django.urls import reverse from django.contrib.auth.models import User from rest_framework_simplejwt.tokens import RefreshToken from .models import Task from .serializers import TaskSerializer from django.core.cache import cache import logging logger = logging.getLogger(__name__) # Oldingi testlar (TaskModelTest, TaskSerializerTest, TaskSignalTest) shu yerda qoladi class TaskAPITest(APITestCase): def setUp(self): self.user = User.objects.create_user(username='testuser', password='testpass123') self.other_user = User.objects.create_user(username='otheruser', password='otherpass123') self.task = Task.objects.create( title='Test vazifa', description='Test tavsifi', owner=self.user ) self.token = RefreshToken.for_user(self.user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {self.token}') cache.clear() # Testdan oldin keshni tozalash def test_get_tasks_list(self): url = reverse('task-list') response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 1) self.assertEqual(response.data['results'][0]['title'], 'Test vazifa') def test_create_task(self): url = reverse('task-list') data = {'title': 'Yangi vazifa', 'description': 'Yangi tavsif'} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_201_CREATED) self.assertEqual(Task.objects.count(), 2) self.assertEqual(Task.objects.latest('id').title, 'Yangi vazifa') def test_update_task_owner_only(self): url = reverse('task-detail', kwargs={'pk': self.task.id}) data = {'completed': True} response = self.client.patch(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK) self.task.refresh_from_db() self.assertTrue(self.task.completed) other_token = RefreshToken.for_user(self.other_user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {other_token}') response = self.client.patch(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN) def test_delete_task_owner_only(self): url = reverse('task-detail', kwargs={'pk': self.task.id}) response = self.client.delete(url) self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT) self.assertEqual(Task.objects.count(), 0) self.task = Task.objects.create(title='Yana vazifa', owner=self.user) other_token = RefreshToken.for_user(self.other_user).access_token self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {other_token}') response = self.client.delete(url) self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN) def test_pagination(self): for i in range(5): Task.objects.create(title=f'Vazifa {i}', owner=self.user) url = reverse('task-list') response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 3) self.assertIn('next', response.data) self.assertIsNone(response.data['previous']) def test_filtering(self): Task.objects.create(title='Bajarilgan vazifa', completed=True, owner=self.user) url = reverse('task-list') + '?completed=true' response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(len(response.data['results']), 1) self.assertEqual(response.data['results'][0]['title'], 'Bajarilgan vazifa') def test_caching(self): url = reverse('task-list') # Birinchi so'rov response1 = self.client.get(url) self.assertEqual(response1.status_code, status.HTTP_200_OK) # Keshdan ikkinchi so'rov response2 = self.client.get(url) self.assertEqual(response2.status_code, status.HTTP_200_OK) self.assertEqual(response1.data, response2.data) # Keshlangan javob bir xil # Yangi vazifa qo'shish keshni yangilamaydi Task.objects.create(title='Kesh sinovi', owner=self.user) response3 = self.client.get(url) self.assertEqual(len(response3.data['results']), len(response1.data['results'])) # Keshlangan natija \ud83d\udccc Tushuntirish : - test_caching : /tasks/ endpointining keshlanganligini sinaydi. - cache.clear() : Testdan oldin keshni tozalaydi. - Keshlangan javob bir xil bo'lishi va yangi vazifa qo'shilganda keshning yangilanmasligi tekshiriladi.","title":"\u2705 7. TESTLARNI YANGILASH"},{"location":"drf/caching-and-performance-optimization/#8-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), ]","title":"\u2705 8. URL SOZLASH"},{"location":"drf/caching-and-performance-optimization/#9-keshlash-va-ishlashni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Redis serverini ishga tushiring: redis-server \ud83d\udccc Celery worker ni ishga tushiring (ixtiyoriy, testlar uchun shart emas): celery -A myproject worker --loglevel=info","title":"\u2705 9. KESHLASH VA ISHLASHNI SINAB KO'RISH"},{"location":"drf/caching-and-performance-optimization/#foydalanuvchi-va-token-yaratish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: testuser, password: testpass123 \ud83d\udccc JWT token oling: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"testuser\", \"password\": \"testpass123\"}'","title":"\u2747\ufe0f Foydalanuvchi va token yaratish:"},{"location":"drf/caching-and-performance-optimization/#keshlash-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" \ud83d\udccc Birinchi so'rov ma'lumotlar bazasidan olinadi, keyingi so'rovlar 5 daqiqa davomida keshdan qaytariladi. Yangi vazifa qo'shing: curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test\"}' \ud83d\udccc /tasks/ ni qayta so'rang \u2014 kesh tufayli yangi vazifa ko'rinmaydi.","title":"\u2747\ufe0f Keshlash sinovi:"},{"location":"drf/caching-and-performance-optimization/#testlarni-ishga-tushirish","text":"python manage.py test \ud83d\udccc test_caching testi keshning to'g'ri ishlashini tasdiqlaydi.","title":"\u2747\ufe0f Testlarni ishga tushirish:"},{"location":"drf/caching-and-performance-optimization/#10-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 10. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/caching-and-performance-optimization/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/caching-and-performance-optimization/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/caching-and-performance-optimization/#11-sinov-uchun-masalalar","text":"\ud83d\udccc Keshlash va ishlashni sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manziliga bir necha marta GET so'rov yuboring va javob vaqtini solishtiring. 2. Yangi vazifa qo'shing va /tasks/ manzilida kesh tufayli yangi vazifa ko'rinmasligini tekshiring. 3. python manage.py test bilan test_caching testini sinab ko'ring. 4. select_related effekti uchun ma'lumotlar bazasi so'rovlarini (Django Debug Toolbar bilan) tekshiring.","title":"\u2705 11. SINOV UCHUN MASALALAR"},{"location":"drf/creating-the-first-api/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 2-DARS: BIRINCHI API NI YARATISH Bu darsda Django REST Framework (DRF) yordamida birinchi API ni bosqichma-bosqich yaratamiz. Har bir qadam tushunarli va faqat API yaratishga qaratilgan bo'ladi. Oldingi darsda sozlangan myproject loyihasi va myapp ilovasi asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject va myapp ). Agar hali sozlamagan bo'lsangiz, avvalgi darsga qayting. Quyidagi sozlamalar mavjud bo'lishi kerak: - myapp ilovasi INSTALLED_APPS ro'yxatida. - rest_framework ham INSTALLED_APPS ga qo'shilgan. - Virtual muhit faol va Django bilan DRF o'rnatilgan. \u2705 2. MODELNI YARATISH \ud83d\udccc API ma'lumotlar bilan ishlashi uchun avval model yaratamiz. myapp/models.py faylida quyidagi oddiy modelni qo'shamiz: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title \ud83d\udccc Bu model vazifalar ro'yxatini saqlash uchun ishlatiladi (masalan, todo-list). \u2747\ufe0f Migratsiyalarni amalga oshirish : \ud83d\udccc Modelni ma'lumotlar bazasiga qo'shish uchun migratsiyalarni yarating va qo'llang: python manage.py makemigrations python manage.py migrate \u2705 3. SERIALIZER YARATISH \ud83d\udccc Serializer ma'lumotlarni JSON formatiga aylantiradi va API orqali ishlatish uchun tayyorlaydi. myapp/serializers.py faylini yarating va quyidagi kodni qo'shing: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): class Meta: model = Task fields = ['id', 'title', 'completed', 'created_at'] \ud83d\udccc fields ro'yxatida API orqali ko'rsatiladigan maydonlarni belgilaymiz. \u2705 4. VIEW YARATISH \ud83d\udccc API funksiyalarini boshqarish uchun view yaratamiz. myapp/views.py faylida quyidagi kodni qo'shing: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer \ud83d\udccc ModelViewSet DRFning tayyor sinfi bo'lib, CRUD (Create, Read, Update, Delete) amallarini avtomatik boshqaradi. \u2705 5. URL SOZLASH \ud83d\udccc API uchun URL marshrutlarini sozlaymiz. myproject/urls.py faylini yangilang: from django.urls import path, include from rest_framework.routers import DefaultRouter from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), ] \ud83d\udccc router.register orqali tasks endpointi yaratiladi. Bu /tasks/ manzilida API ishlaydi. \u2705 6. API NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda http://127.0.0.1:8000/tasks/ manziliga o'ting. DRFning interfeysi orqali quyidagi amallarni sinab ko'rishingiz mumkin: - GET : Barcha vazifalarni ko'rish. - POST : Yangi vazifa qo'shish. - PUT/PATCH : Mavjud vazifani tahrirlash. - DELETE : Vazifani o'chirish. \u2705 7. MA'LUMOT QO'SHISH (IXTIYORIY) \ud83d\udccc Django admin paneli orqali sinov ma'lumotlari qo'shish uchun: \u2747\ufe0f Admin foydalanuvchisini yaratish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida quyidagi kodni qo'shing: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalar qo'shing. \u2705 8. API NI TEST QILISH UCHUN MASALALAR \ud83d\udccc API funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. Brauzer orqali /tasks/ manzilida vazifalar ro'yxatini ko'ring. 2. DRF interfeysi yordamida yangi vazifa qo'shing (masalan, title: \"Birinchi vazifa\", completed: False ). 3. curl yoki Postman yordamida quyidagi so'rovni yuboring: bash curl -X POST http://127.0.0.1:8000/tasks/ -d \"title=Test vazifa&completed=true\"","title":"Creating the First API"},{"location":"drf/creating-the-first-api/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/creating-the-first-api/#2-dars-birinchi-api-ni-yaratish","text":"Bu darsda Django REST Framework (DRF) yordamida birinchi API ni bosqichma-bosqich yaratamiz. Har bir qadam tushunarli va faqat API yaratishga qaratilgan bo'ladi. Oldingi darsda sozlangan myproject loyihasi va myapp ilovasi asosida davom etamiz.","title":"\ud83e\udde9 2-DARS: BIRINCHI API NI YARATISH"},{"location":"drf/creating-the-first-api/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject va myapp ). Agar hali sozlamagan bo'lsangiz, avvalgi darsga qayting. Quyidagi sozlamalar mavjud bo'lishi kerak: - myapp ilovasi INSTALLED_APPS ro'yxatida. - rest_framework ham INSTALLED_APPS ga qo'shilgan. - Virtual muhit faol va Django bilan DRF o'rnatilgan.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/creating-the-first-api/#2-modelni-yaratish","text":"\ud83d\udccc API ma'lumotlar bilan ishlashi uchun avval model yaratamiz. myapp/models.py faylida quyidagi oddiy modelni qo'shamiz: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title \ud83d\udccc Bu model vazifalar ro'yxatini saqlash uchun ishlatiladi (masalan, todo-list).","title":"\u2705 2. MODELNI YARATISH"},{"location":"drf/creating-the-first-api/#migratsiyalarni-amalga-oshirish","text":"\ud83d\udccc Modelni ma'lumotlar bazasiga qo'shish uchun migratsiyalarni yarating va qo'llang: python manage.py makemigrations python manage.py migrate","title":"\u2747\ufe0f Migratsiyalarni amalga oshirish:"},{"location":"drf/creating-the-first-api/#3-serializer-yaratish","text":"\ud83d\udccc Serializer ma'lumotlarni JSON formatiga aylantiradi va API orqali ishlatish uchun tayyorlaydi. myapp/serializers.py faylini yarating va quyidagi kodni qo'shing: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): class Meta: model = Task fields = ['id', 'title', 'completed', 'created_at'] \ud83d\udccc fields ro'yxatida API orqali ko'rsatiladigan maydonlarni belgilaymiz.","title":"\u2705 3. SERIALIZER YARATISH"},{"location":"drf/creating-the-first-api/#4-view-yaratish","text":"\ud83d\udccc API funksiyalarini boshqarish uchun view yaratamiz. myapp/views.py faylida quyidagi kodni qo'shing: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer \ud83d\udccc ModelViewSet DRFning tayyor sinfi bo'lib, CRUD (Create, Read, Update, Delete) amallarini avtomatik boshqaradi.","title":"\u2705 4. VIEW YARATISH"},{"location":"drf/creating-the-first-api/#5-url-sozlash","text":"\ud83d\udccc API uchun URL marshrutlarini sozlaymiz. myproject/urls.py faylini yangilang: from django.urls import path, include from rest_framework.routers import DefaultRouter from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), ] \ud83d\udccc router.register orqali tasks endpointi yaratiladi. Bu /tasks/ manzilida API ishlaydi.","title":"\u2705 5. URL SOZLASH"},{"location":"drf/creating-the-first-api/#6-api-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda http://127.0.0.1:8000/tasks/ manziliga o'ting. DRFning interfeysi orqali quyidagi amallarni sinab ko'rishingiz mumkin: - GET : Barcha vazifalarni ko'rish. - POST : Yangi vazifa qo'shish. - PUT/PATCH : Mavjud vazifani tahrirlash. - DELETE : Vazifani o'chirish.","title":"\u2705 6. API NI SINAB KO'RISH"},{"location":"drf/creating-the-first-api/#7-malumot-qoshish-ixtiyoriy","text":"\ud83d\udccc Django admin paneli orqali sinov ma'lumotlari qo'shish uchun:","title":"\u2705 7. MA'LUMOT QO'SHISH (IXTIYORIY)"},{"location":"drf/creating-the-first-api/#admin-foydalanuvchisini-yaratish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini yaratish:"},{"location":"drf/creating-the-first-api/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida quyidagi kodni qo'shing: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalar qo'shing.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/creating-the-first-api/#8-api-ni-test-qilish-uchun-masalalar","text":"\ud83d\udccc API funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. Brauzer orqali /tasks/ manzilida vazifalar ro'yxatini ko'ring. 2. DRF interfeysi yordamida yangi vazifa qo'shing (masalan, title: \"Birinchi vazifa\", completed: False ). 3. curl yoki Postman yordamida quyidagi so'rovni yuboring: bash curl -X POST http://127.0.0.1:8000/tasks/ -d \"title=Test vazifa&completed=true\"","title":"\u2705 8. API NI TEST QILISH UCHUN MASALALAR"},{"location":"drf/deployment-and-docker/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 18-DARS: JOYLASHTIRISH VA DOCKER BILAN ISHLASH Bu darsda Django REST Framework (DRF) loyihasini Docker yordamida joylashtirishni bosqichma-bosqich o'rganamiz. Docker loyihani izolyatsiya qilingan konteynerlarda ishlatish imkonini beradi, bu esa uni turli muhitlarda barqaror ishlashini ta'minlaydi. Har bir qadam tushunarli va faqat joylashtirish va Docker ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash, Celery, keshlash va WebSocket (Django Channels) asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash, keshlash va WebSocket bilan). - Signallar, Celery va WebSocket myapp/signals.py , myapp/tasks.py va myapp/consumers.py fayllarida sozlangan. - /tasks/ va /ws/tasks/ endpointlari myproject/urls.py va myapp/routing.py fayllarida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. DOCKER VA JOYLASHTIRISH NI TUSHUNISH \ud83d\udccc Docker : Ilovalarni konteynerlarga joylashtirib, ularni mustaqil va moslashuvchan muhitda ishlatish imkonini beradi. \ud83d\udccc Joylashtirish : Loyihani ishlab chiqarish (production) muhitida foydalanuvchilarga ochiq qilish jarayoni. \ud83d\udccc Biz quyidagi komponentlarni Docker konteynerlarida joylashtiramiz: - Django (Daphne bilan WebSocket uchun). - Redis (Celery, keshlash va Channels uchun). - PostgreSQL (ma'lumotlar bazasi sifatida). - Celery worker. \ud83d\udccc Nginx ni reverse proxy sifatida ishlatamiz. \u2705 3. DOCKER VA DOCKER COMPOSE NI O'RNATISH \ud83d\udccc Docker va Docker Compose ni o'rnatish: - Docker : Rasmiy saytdan o'rnatiladi. - Docker Compose : Docker bilan birga keladi yoki alohida o'rnatiladi: bash sudo apt-get install docker-compose # Ubuntu uchun \ud83d\udccc Docker ishlayotganligini tekshiring: docker --version docker-compose --version \u2705 4. POSTGRESQL UCHUN SOZLAMALAR \ud83d\udccc Loyiha SQLite dan PostgreSQL ga o'tkaziladi. myproject/settings.py faylini yangilaymiz: INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'channels', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } # PostgreSQL sozlamalari DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql', 'NAME': 'mydb', 'USER': 'myuser', 'PASSWORD': 'mypassword', 'HOST': 'db', 'PORT': '5432', } } # Celery sozlamalari CELERY_BROKER_URL = 'redis://redis:6379/0' CELERY_RESULT_BACKEND = 'redis://redis:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = False # Ishlab chiqarishda sinxron emas # Keshlash sozlamalari CACHES = { 'default': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://redis:6379/1', 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', } } } # Channels sozlamalari ASGI_APPLICATION = 'myproject.asgi.application' CHANNEL_LAYERS = { 'default': { 'BACKEND': 'channels_redis.core.RedisChannelLayer', 'CONFIG': { 'hosts': [('redis', 6379)], }, }, } \ud83d\udccc Tushuntirish : - DATABASES : PostgreSQL sozlamalari qo'shildi. db \u2014 Docker Compose dagi PostgreSQL xizmati nomi. - CELERY_BROKER_URL va CACHES : redis xizmati nomiga o'zgartirildi. - CELERY_TASK_ALWAYS_EAGER = False : Ishlab chiqarishda Celery asinxron ishlaydi. \u2705 5. DOCKERFILE YARATISH \ud83d\udccc Loyiha ildizida Dockerfile yarating: FROM python:3.9-slim WORKDIR /app COPY requirements.txt . RUN pip install --no-cache-dir -r requirements.txt COPY . . ENV PYTHONUNBUFFERED=1 CMD [\"daphne\", \"-b\", \"0.0.0.0\", \"-p\", \"8000\", \"myproject.asgi:application\"] \ud83d\udccc Tushuntirish : - python:3.9-slim : Yengil Python tasviri. - requirements.txt : Loyiha bog'liqliklarini o'rnatadi. - daphne : WebSocket uchun ASGI serveri sifatida ishlaydi. \u2705 6. REQUIREMENTS.TXT YARATISH \ud83d\udccc Loyiha ildizida requirements.txt faylini yarating: django==4.2 djangorestframework==3.14 django-filter==23.2 djangorestframework-simplejwt==5.2 channels==4.0 channels-redis==4.0 django-redis==5.2 celery==5.2 redis==4.5 psycopg2-binary==2.9 daphne==4.0 \ud83d\udccc Eslatma : Versiyalar sizning loyihangizga mos kelishi kerak. \u2705 7. DOCKER COMPOSE SOZLASH \ud83d\udccc Loyiha ildizida docker-compose.yml faylini yarating: version: '3.8' services: db: image: postgres:13 environment: POSTGRES_DB: mydb POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword volumes: - postgres_data:/var/lib/postgresql/data redis: image: redis:6 volumes: - redis_data:/data web: build: . volumes: - .:/app ports: - \"8000:8000\" depends_on: - db - redis environment: - PYTHONUNBUFFERED=1 command: > sh -c \"python manage.py migrate && daphne -b 0.0.0.0 -p 8000 myproject.asgi:application\" celery: build: . volumes: - .:/app depends_on: - redis - db command: celery -A myproject worker --loglevel=info nginx: image: nginx:latest ports: - \"80:80\" volumes: - ./nginx.conf:/etc/nginx/nginx.conf depends_on: - web volumes: postgres_data: redis_data: \ud83d\udccc Tushuntirish : - db : PostgreSQL xizmati. - redis : Redis xizmati. - web : Django va Daphne xizmati. - celery : Celery worker xizmati. - nginx : Reverse proxy sifatida ishlaydi. \u2705 8. NGINX SOZLASH \ud83d\udccc Loyiha ildizida nginx.conf faylini yarating: events {} http { server { listen 80; location / { proxy_pass http://web:8000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location /ws/ { proxy_pass http://web:8000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; } } } \ud83d\udccc Tushuntirish : - / : HTTP so'rovlarini web xizmatiga yo'naltiradi. - /ws/ : WebSocket so'rovlarini qo'llab-quvvatlaydi. \u2705 9. LOYIHANI JOYLASHTIRISH \ud83d\udccc Docker Compose bilan loyihani ishga tushirish: docker-compose up --build \ud83d\udccc Migratsiyalarni amalga oshirish (birinchi marta): docker-compose exec web python manage.py migrate \ud83d\udccc Superuser yaratish: docker-compose exec web python manage.py createsuperuser \u2705 10. JOYLASHTIRISHNI SINAB KO'RISH \ud83d\udccc Brauzerda http://localhost yoki http://localhost/ws/ manzilini oching. \ud83d\udccc API ni sinash: curl -X POST http://localhost/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"testuser\", \"password\": \"testpass123\"}' curl -X POST http://localhost/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test\"}' \ud83d\udccc WebSocket sinovi: - http://localhost/ws/ manzilida WebSocket sahifasini oching. - Yangi vazifa qo'shing va bildirishnoma oling. \u2705 11. TESTLARNI DOCKERDA ISHGA TUSHIRISH \ud83d\udccc Testlarni Docker ichida ishga tushirish: docker-compose exec web python manage.py test \u2705 12. SINOV UCHUN MASALALAR \ud83d\udccc Joylashtirishni sinash uchun quyidagi amallarni bajarib ko'ring: 1. docker-compose up --build bilan loyihani ishga tushiring va http://localhost/tasks/ manzilini sinang. 2. WebSocket ni http://localhost/ws/ manzilida sinab, vazifa qo'shishda bildirishnoma oling. 3. Testlarni docker-compose exec web python manage.py test bilan ishga tushiring. 4. PostgreSQL ga ulanishni docker-compose exec db psql -U myuser -d mydb bilan tekshiring.","title":"Deployment and Docker"},{"location":"drf/deployment-and-docker/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/deployment-and-docker/#18-dars-joylashtirish-va-docker-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) loyihasini Docker yordamida joylashtirishni bosqichma-bosqich o'rganamiz. Docker loyihani izolyatsiya qilingan konteynerlarda ishlatish imkonini beradi, bu esa uni turli muhitlarda barqaror ishlashini ta'minlaydi. Har bir qadam tushunarli va faqat joylashtirish va Docker ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash, Celery, keshlash va WebSocket (Django Channels) asosida davom etamiz.","title":"\ud83e\udde9 18-DARS: JOYLASHTIRISH VA DOCKER BILAN ISHLASH"},{"location":"drf/deployment-and-docker/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash, keshlash va WebSocket bilan). - Signallar, Celery va WebSocket myapp/signals.py , myapp/tasks.py va myapp/consumers.py fayllarida sozlangan. - /tasks/ va /ws/tasks/ endpointlari myproject/urls.py va myapp/routing.py fayllarida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/deployment-and-docker/#2-docker-va-joylashtirish-ni-tushunish","text":"\ud83d\udccc Docker : Ilovalarni konteynerlarga joylashtirib, ularni mustaqil va moslashuvchan muhitda ishlatish imkonini beradi. \ud83d\udccc Joylashtirish : Loyihani ishlab chiqarish (production) muhitida foydalanuvchilarga ochiq qilish jarayoni. \ud83d\udccc Biz quyidagi komponentlarni Docker konteynerlarida joylashtiramiz: - Django (Daphne bilan WebSocket uchun). - Redis (Celery, keshlash va Channels uchun). - PostgreSQL (ma'lumotlar bazasi sifatida). - Celery worker. \ud83d\udccc Nginx ni reverse proxy sifatida ishlatamiz.","title":"\u2705 2. DOCKER VA JOYLASHTIRISH NI TUSHUNISH"},{"location":"drf/deployment-and-docker/#3-docker-va-docker-compose-ni-ornatish","text":"\ud83d\udccc Docker va Docker Compose ni o'rnatish: - Docker : Rasmiy saytdan o'rnatiladi. - Docker Compose : Docker bilan birga keladi yoki alohida o'rnatiladi: bash sudo apt-get install docker-compose # Ubuntu uchun \ud83d\udccc Docker ishlayotganligini tekshiring: docker --version docker-compose --version","title":"\u2705 3. DOCKER VA DOCKER COMPOSE NI O'RNATISH"},{"location":"drf/deployment-and-docker/#4-postgresql-uchun-sozlamalar","text":"\ud83d\udccc Loyiha SQLite dan PostgreSQL ga o'tkaziladi. myproject/settings.py faylini yangilaymiz: INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'channels', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } # PostgreSQL sozlamalari DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql', 'NAME': 'mydb', 'USER': 'myuser', 'PASSWORD': 'mypassword', 'HOST': 'db', 'PORT': '5432', } } # Celery sozlamalari CELERY_BROKER_URL = 'redis://redis:6379/0' CELERY_RESULT_BACKEND = 'redis://redis:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = False # Ishlab chiqarishda sinxron emas # Keshlash sozlamalari CACHES = { 'default': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://redis:6379/1', 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', } } } # Channels sozlamalari ASGI_APPLICATION = 'myproject.asgi.application' CHANNEL_LAYERS = { 'default': { 'BACKEND': 'channels_redis.core.RedisChannelLayer', 'CONFIG': { 'hosts': [('redis', 6379)], }, }, } \ud83d\udccc Tushuntirish : - DATABASES : PostgreSQL sozlamalari qo'shildi. db \u2014 Docker Compose dagi PostgreSQL xizmati nomi. - CELERY_BROKER_URL va CACHES : redis xizmati nomiga o'zgartirildi. - CELERY_TASK_ALWAYS_EAGER = False : Ishlab chiqarishda Celery asinxron ishlaydi.","title":"\u2705 4. POSTGRESQL UCHUN SOZLAMALAR"},{"location":"drf/deployment-and-docker/#5-dockerfile-yaratish","text":"\ud83d\udccc Loyiha ildizida Dockerfile yarating: FROM python:3.9-slim WORKDIR /app COPY requirements.txt . RUN pip install --no-cache-dir -r requirements.txt COPY . . ENV PYTHONUNBUFFERED=1 CMD [\"daphne\", \"-b\", \"0.0.0.0\", \"-p\", \"8000\", \"myproject.asgi:application\"] \ud83d\udccc Tushuntirish : - python:3.9-slim : Yengil Python tasviri. - requirements.txt : Loyiha bog'liqliklarini o'rnatadi. - daphne : WebSocket uchun ASGI serveri sifatida ishlaydi.","title":"\u2705 5. DOCKERFILE YARATISH"},{"location":"drf/deployment-and-docker/#6-requirementstxt-yaratish","text":"\ud83d\udccc Loyiha ildizida requirements.txt faylini yarating: django==4.2 djangorestframework==3.14 django-filter==23.2 djangorestframework-simplejwt==5.2 channels==4.0 channels-redis==4.0 django-redis==5.2 celery==5.2 redis==4.5 psycopg2-binary==2.9 daphne==4.0 \ud83d\udccc Eslatma : Versiyalar sizning loyihangizga mos kelishi kerak.","title":"\u2705 6. REQUIREMENTS.TXT YARATISH"},{"location":"drf/deployment-and-docker/#7-docker-compose-sozlash","text":"\ud83d\udccc Loyiha ildizida docker-compose.yml faylini yarating: version: '3.8' services: db: image: postgres:13 environment: POSTGRES_DB: mydb POSTGRES_USER: myuser POSTGRES_PASSWORD: mypassword volumes: - postgres_data:/var/lib/postgresql/data redis: image: redis:6 volumes: - redis_data:/data web: build: . volumes: - .:/app ports: - \"8000:8000\" depends_on: - db - redis environment: - PYTHONUNBUFFERED=1 command: > sh -c \"python manage.py migrate && daphne -b 0.0.0.0 -p 8000 myproject.asgi:application\" celery: build: . volumes: - .:/app depends_on: - redis - db command: celery -A myproject worker --loglevel=info nginx: image: nginx:latest ports: - \"80:80\" volumes: - ./nginx.conf:/etc/nginx/nginx.conf depends_on: - web volumes: postgres_data: redis_data: \ud83d\udccc Tushuntirish : - db : PostgreSQL xizmati. - redis : Redis xizmati. - web : Django va Daphne xizmati. - celery : Celery worker xizmati. - nginx : Reverse proxy sifatida ishlaydi.","title":"\u2705 7. DOCKER COMPOSE SOZLASH"},{"location":"drf/deployment-and-docker/#8-nginx-sozlash","text":"\ud83d\udccc Loyiha ildizida nginx.conf faylini yarating: events {} http { server { listen 80; location / { proxy_pass http://web:8000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location /ws/ { proxy_pass http://web:8000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; } } } \ud83d\udccc Tushuntirish : - / : HTTP so'rovlarini web xizmatiga yo'naltiradi. - /ws/ : WebSocket so'rovlarini qo'llab-quvvatlaydi.","title":"\u2705 8. NGINX SOZLASH"},{"location":"drf/deployment-and-docker/#9-loyihani-joylashtirish","text":"\ud83d\udccc Docker Compose bilan loyihani ishga tushirish: docker-compose up --build \ud83d\udccc Migratsiyalarni amalga oshirish (birinchi marta): docker-compose exec web python manage.py migrate \ud83d\udccc Superuser yaratish: docker-compose exec web python manage.py createsuperuser","title":"\u2705 9. LOYIHANI JOYLASHTIRISH"},{"location":"drf/deployment-and-docker/#10-joylashtirishni-sinab-korish","text":"\ud83d\udccc Brauzerda http://localhost yoki http://localhost/ws/ manzilini oching. \ud83d\udccc API ni sinash: curl -X POST http://localhost/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"testuser\", \"password\": \"testpass123\"}' curl -X POST http://localhost/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test\"}' \ud83d\udccc WebSocket sinovi: - http://localhost/ws/ manzilida WebSocket sahifasini oching. - Yangi vazifa qo'shing va bildirishnoma oling.","title":"\u2705 10. JOYLASHTIRISHNI SINAB KO'RISH"},{"location":"drf/deployment-and-docker/#11-testlarni-dockerda-ishga-tushirish","text":"\ud83d\udccc Testlarni Docker ichida ishga tushirish: docker-compose exec web python manage.py test","title":"\u2705 11. TESTLARNI DOCKERDA ISHGA TUSHIRISH"},{"location":"drf/deployment-and-docker/#12-sinov-uchun-masalalar","text":"\ud83d\udccc Joylashtirishni sinash uchun quyidagi amallarni bajarib ko'ring: 1. docker-compose up --build bilan loyihani ishga tushiring va http://localhost/tasks/ manzilini sinang. 2. WebSocket ni http://localhost/ws/ manzilida sinab, vazifa qo'shishda bildirishnoma oling. 3. Testlarni docker-compose exec web python manage.py test bilan ishga tushiring. 4. PostgreSQL ga ulanishni docker-compose exec db psql -U myuser -d mydb bilan tekshiring.","title":"\u2705 12. SINOV UCHUN MASALALAR"},{"location":"drf/filtering-searching-and-ordering/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 10-DARS: FILTRLASH, QIDIRISH VA TARTIBLASH Bu darsda Django REST Framework (DRF) yordamida ma'lumotlarni filtrlash, qidirish va tartiblash funksiyalarini sozlashni bosqichma-bosqich o'rganamiz. Bu funksiyalar API dan olingan ma'lumotlarni foydalanuvchi ehtiyojlariga moslashtirishga yordam beradi. Har bir qadam tushunarli va faqat filtrlash, qidirish va tartiblashga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, token autentifikatsiyasi va ruxsatlar asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (autentifikatsiya va ruxsatlar bilan). - Token autentifikatsiyasi va /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. FILTRLASH, QIDIRISH VA TARTIBLASH NI TUSHUNISH \ud83d\udccc Filtrlash : Ma'lumotlarni muayyan shartlar asosida cheklash (masalan, faqat bajarilgan vazifalarni ko'rsatish). \ud83d\udccc Qidirish : Ma'lumotlarni kalit so'z bo'yicha izlash (masalan, sarlavhada muayyan so'zni qidirish). \ud83d\udccc Tartiblash : Ma'lumotlarni muayyan maydon bo'yicha tartiblash (masalan, yaratilgan sana bo'yicha). \ud83d\udccc DRF bu funksiyalarni django-filter , SearchFilter va OrderingFilter kabi vositalar orqali qo'llab-quvvatlaydi. \u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz: \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title \u2747\ufe0f Serializer tekshirish : \ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \u2705 4. FILTRLASH UCHUN DJANGO-FILTER O'RNATISH \ud83d\udccc Filtrlash uchun django-filter paketini o'rnatamiz: pip install django-filter \ud83d\udccc myproject/settings.py faylida django-filter ni qo'shing: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp', ] \u2705 5. VIEWSET NI FILTRLASH, QIDIRISH VA TARTIBLASH BILAN YANGILASH \ud83d\udccc myapp/views.py faylida TaskViewSet ni yangilaymiz va filtrlash, qidirish va tartiblash funksiyalarini qo'shamiz: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] # Filtrlash uchun maydonlar search_fields = ['title', 'description'] # Qidirish uchun maydonlar ordering_fields = ['created_at', 'completed'] # Tartiblash uchun maydonlar ordering = ['created_at'] # Standart tartiblash def perform_create(self, serializer): serializer.save(owner=self.request.user) \ud83d\udccc Tushuntirish : - filter_backends : DjangoFilterBackend , SearchFilter va OrderingFilter ni qo'shadi. - filterset_fields : completed va owner bo'yicha filtrlash imkonini beradi. - search_fields : title va description maydonlarida qidirish imkonini beradi. - ordering_fields : created_at va completed bo'yicha tartiblash imkonini beradi. - ordering : Standart tartiblash created_at bo'yicha. \u2705 6. LOYIHA SOZLAMALARINI YANGILASH \ud83d\udccc myproject/settings.py faylida REST_FRAMEWORK sozlamalarini yangilang: REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], } \u2705 7. URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), ] \u2705 8. FILTRLASH, QIDIRISH VA TARTIBLASH NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> . \u2747\ufe0f Foydalanuvchi va token yaratish : \ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc Token oling: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user1&password=pass123\" \u2747\ufe0f Filtrlash sinovi : Faqat bajarilgan vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?completed=true \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/?completed=true -H \"Authorization: Token <user1_token>\" Muayyan foydalanuvchi vazifalarini ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?owner=1 (1 \u2014 foydalanuvchi ID si) \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/?owner=1 -H \"Authorization: Token <user1_token>\" \u2747\ufe0f Qidirish sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?search=test \ud83d\udccc Usul : GET \ud83d\udccc title yoki description da \"test\" so'zini qidiradi: curl http://127.0.0.1:8000/tasks/?search=test -H \"Authorization: Token <user1_token>\" \u2747\ufe0f Tartiblash sinovi : Yaratilgan sana bo'yicha teskari tartiblash : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?ordering=-created_at \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/?ordering=-created_at -H \"Authorization: Token <user1_token>\" Bajarilgan holati bo'yicha tartiblash : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?ordering=completed \ud83d\udccc Usul : GET bash curl http://127.0.0.1:8000/tasks/?ordering=completed -H \"Authorization: Token <user1_token>\" \u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang. \u2705 10. SINOV UCHUN MASALALAR \ud83d\udccc Filtrlash, qidirish va tartiblashni sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/?completed=true manzilidan faqat bajarilgan vazifalarni oling. 2. /tasks/?search=vazifa manzilidan \"vazifa\" so'zini o'z ichiga olgan vazifalarni qidiring. 3. /tasks/?ordering=-created_at manzilidan eng so'nggi vazifalarni birinchi ko'ring. 4. Admin panelida bir nechta vazifa qo'shing va filtrlash/qidirishni sinab ko'ring.","title":"Filtering, Searching, and Ordering"},{"location":"drf/filtering-searching-and-ordering/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/filtering-searching-and-ordering/#10-dars-filtrlash-qidirish-va-tartiblash","text":"Bu darsda Django REST Framework (DRF) yordamida ma'lumotlarni filtrlash, qidirish va tartiblash funksiyalarini sozlashni bosqichma-bosqich o'rganamiz. Bu funksiyalar API dan olingan ma'lumotlarni foydalanuvchi ehtiyojlariga moslashtirishga yordam beradi. Har bir qadam tushunarli va faqat filtrlash, qidirish va tartiblashga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, token autentifikatsiyasi va ruxsatlar asosida davom etamiz.","title":"\ud83e\udde9 10-DARS: FILTRLASH, QIDIRISH VA TARTIBLASH"},{"location":"drf/filtering-searching-and-ordering/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (autentifikatsiya va ruxsatlar bilan). - Token autentifikatsiyasi va /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/filtering-searching-and-ordering/#2-filtrlash-qidirish-va-tartiblash-ni-tushunish","text":"\ud83d\udccc Filtrlash : Ma'lumotlarni muayyan shartlar asosida cheklash (masalan, faqat bajarilgan vazifalarni ko'rsatish). \ud83d\udccc Qidirish : Ma'lumotlarni kalit so'z bo'yicha izlash (masalan, sarlavhada muayyan so'zni qidirish). \ud83d\udccc Tartiblash : Ma'lumotlarni muayyan maydon bo'yicha tartiblash (masalan, yaratilgan sana bo'yicha). \ud83d\udccc DRF bu funksiyalarni django-filter , SearchFilter va OrderingFilter kabi vositalar orqali qo'llab-quvvatlaydi.","title":"\u2705 2. FILTRLASH, QIDIRISH VA TARTIBLASH NI TUSHUNISH"},{"location":"drf/filtering-searching-and-ordering/#3-model-va-serializerni-tekshirish","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz:","title":"\u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH"},{"location":"drf/filtering-searching-and-ordering/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/filtering-searching-and-ordering/#serializer-tekshirish","text":"\ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value","title":"\u2747\ufe0f Serializer tekshirish:"},{"location":"drf/filtering-searching-and-ordering/#4-filtrlash-uchun-django-filter-ornatish","text":"\ud83d\udccc Filtrlash uchun django-filter paketini o'rnatamiz: pip install django-filter \ud83d\udccc myproject/settings.py faylida django-filter ni qo'shing: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp', ]","title":"\u2705 4. FILTRLASH UCHUN DJANGO-FILTER O'RNATISH"},{"location":"drf/filtering-searching-and-ordering/#5-viewset-ni-filtrlash-qidirish-va-tartiblash-bilan-yangilash","text":"\ud83d\udccc myapp/views.py faylida TaskViewSet ni yangilaymiz va filtrlash, qidirish va tartiblash funksiyalarini qo'shamiz: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] # Filtrlash uchun maydonlar search_fields = ['title', 'description'] # Qidirish uchun maydonlar ordering_fields = ['created_at', 'completed'] # Tartiblash uchun maydonlar ordering = ['created_at'] # Standart tartiblash def perform_create(self, serializer): serializer.save(owner=self.request.user) \ud83d\udccc Tushuntirish : - filter_backends : DjangoFilterBackend , SearchFilter va OrderingFilter ni qo'shadi. - filterset_fields : completed va owner bo'yicha filtrlash imkonini beradi. - search_fields : title va description maydonlarida qidirish imkonini beradi. - ordering_fields : created_at va completed bo'yicha tartiblash imkonini beradi. - ordering : Standart tartiblash created_at bo'yicha.","title":"\u2705 5. VIEWSET NI FILTRLASH, QIDIRISH VA TARTIBLASH BILAN YANGILASH"},{"location":"drf/filtering-searching-and-ordering/#6-loyiha-sozlamalarini-yangilash","text":"\ud83d\udccc myproject/settings.py faylida REST_FRAMEWORK sozlamalarini yangilang: REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], }","title":"\u2705 6. LOYIHA SOZLAMALARINI YANGILASH"},{"location":"drf/filtering-searching-and-ordering/#7-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), ]","title":"\u2705 7. URL SOZLASH"},{"location":"drf/filtering-searching-and-ordering/#8-filtrlash-qidirish-va-tartiblash-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> .","title":"\u2705 8. FILTRLASH, QIDIRISH VA TARTIBLASH NI SINAB KO'RISH"},{"location":"drf/filtering-searching-and-ordering/#foydalanuvchi-va-token-yaratish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc Token oling: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user1&password=pass123\"","title":"\u2747\ufe0f Foydalanuvchi va token yaratish:"},{"location":"drf/filtering-searching-and-ordering/#filtrlash-sinovi","text":"Faqat bajarilgan vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?completed=true \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/?completed=true -H \"Authorization: Token <user1_token>\" Muayyan foydalanuvchi vazifalarini ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?owner=1 (1 \u2014 foydalanuvchi ID si) \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/?owner=1 -H \"Authorization: Token <user1_token>\"","title":"\u2747\ufe0f Filtrlash sinovi:"},{"location":"drf/filtering-searching-and-ordering/#qidirish-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?search=test \ud83d\udccc Usul : GET \ud83d\udccc title yoki description da \"test\" so'zini qidiradi: curl http://127.0.0.1:8000/tasks/?search=test -H \"Authorization: Token <user1_token>\"","title":"\u2747\ufe0f Qidirish sinovi:"},{"location":"drf/filtering-searching-and-ordering/#tartiblash-sinovi","text":"Yaratilgan sana bo'yicha teskari tartiblash : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?ordering=-created_at \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/?ordering=-created_at -H \"Authorization: Token <user1_token>\" Bajarilgan holati bo'yicha tartiblash : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?ordering=completed \ud83d\udccc Usul : GET bash curl http://127.0.0.1:8000/tasks/?ordering=completed -H \"Authorization: Token <user1_token>\"","title":"\u2747\ufe0f Tartiblash sinovi:"},{"location":"drf/filtering-searching-and-ordering/#9-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/filtering-searching-and-ordering/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/filtering-searching-and-ordering/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/filtering-searching-and-ordering/#10-sinov-uchun-masalalar","text":"\ud83d\udccc Filtrlash, qidirish va tartiblashni sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/?completed=true manzilidan faqat bajarilgan vazifalarni oling. 2. /tasks/?search=vazifa manzilidan \"vazifa\" so'zini o'z ichiga olgan vazifalarni qidiring. 3. /tasks/?ordering=-created_at manzilidan eng so'nggi vazifalarni birinchi ko'ring. 4. Admin panelida bir nechta vazifa qo'shing va filtrlash/qidirishni sinab ko'ring.","title":"\u2705 10. SINOV UCHUN MASALALAR"},{"location":"drf/implementing-crud-operations/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 3-DARS: CRUD OPERATSIYALARINI FUNCTION-BASED VIEWS BILAN AMALGA OSHIRISH Bu darsda Django REST Framework (DRF) yordamida CRUD (Create, Read, Update, Delete) operatsiyalarini function-based views (FBV) yordamida bosqichma-bosqich amalga oshiramiz. Har bir qadam tushunarli va faqat CRUD operatsiyalariga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - Ma'lumotlar bazasi migratsiyalari qo'llanilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. CRUD OPERATSIYALARINI TUSHUNISH \ud83d\udccc CRUD operatsiyalari quyidagilarni o'z ichiga oladi: - Create : Yangi ma'lumot qo'shish. - Read : Mavjud ma'lumotlarni o'qish (ro'yxat yoki bitta ob'ekt). - Update : Mavjud ma'lumotlarni yangilash. - Delete : Ma'lumotlarni o'chirish. \ud83d\udccc Function-based views yordamida har bir operatsiyani alohida funksiya sifatida yozamiz. \u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz: \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title \u2747\ufe0f Serializer tekshirish : \ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): class Meta: model = Task fields = ['id', 'title', 'completed', 'created_at'] \u2705 4. FUNCTION-BASED VIEWS YARATISH \ud83d\udccc myapp/views.py faylini yangilaymiz va CRUD operatsiyalari uchun function-based views yozamiz: from rest_framework.decorators import api_view from rest_framework.response import Response from rest_framework import status from .models import Task from .serializers import TaskSerializer @api_view(['GET', 'POST']) def task_list(request): if request.method == 'GET': tasks = Task.objects.all() serializer = TaskSerializer(tasks, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = TaskSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) @api_view(['GET', 'PUT', 'DELETE']) def task_detail(request, pk): try: task = Task.objects.get(pk=pk) except Task.DoesNotExist: return Response(status=status.HTTP_404_NOT_FOUND) if request.method == 'GET': serializer = TaskSerializer(task) return Response(serializer.data) elif request.method == 'PUT': serializer = TaskSerializer(task, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == 'DELETE': task.delete() return Response(status=status.HTTP_204_NO_CONTENT) \ud83d\udccc Tushuntirish : - task_list : GET (barcha vazifalarni o'qish) va POST (yangi vazifa qo'shish) so'rovlarini boshqaradi. - task_detail : GET (bitta vazifani o'qish), PUT (vazifani yangilash) va DELETE (vazifani o'chirish) so'rovlarini boshqaradi. - @api_view dekoratori DRFning API funksiyalarini yoqadi. \u2705 5. URL SOZLASH \ud83d\udccc myproject/urls.py faylini yangilaymiz va function-based views uchun URL marshrutlarini qo'shamiz: from django.urls import path from myapp.views import task_list, task_detail urlpatterns = [ path('tasks/', task_list, name='task-list'), path('tasks/<int:pk>/', task_detail, name='task-detail'), ] \ud83d\udccc Tushuntirish : - /tasks/ manzili vazifalar ro'yxatini ko'rish va yangi vazifa qo'shish uchun. - /tasks/<pk>/ manzili bitta vazifani ko'rish, yangilash yoki o'chirish uchun. \u2705 6. CRUD OPERATSIYALARINI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda yoki Postman kabi vositalar yordamida quyidagi manzillarni sinab ko'ring: \u2747\ufe0f Create (Yangi vazifa qo'shish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (Postman orqali): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"completed\": false}' \ud83d\udccc DRF interfeysi orqali ham yangi vazifa qo'shishingiz mumkin. \u2747\ufe0f Read (Ma'lumotlarni o'qish) : Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc Brauzerda bu manzilga o'tsangiz, barcha vazifalar JSON formatida chiqadi. Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ (1 - vazifa ID si) \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/1/ \u2747\ufe0f Update (Ma'lumotlarni yangilash) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PUT \ud83d\udccc Masalan (vazifani yangilash uchun): curl -X PUT http://127.0.0.1:8000/tasks/1/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangilangan vazifa\", \"completed\": true}' \u2747\ufe0f Delete (Ma'lumotlarni o'chirish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Bu 1-ID li vazifani o'chiradi. \u2705 7. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : \ud83d\udccc Agar hali yaratilmagan bo'lsa: python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida quyidagi kod bo'lishi kerak: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalarni qo'shing, tahrirlang yoki o'chiring. \u2705 8. CRUD SINOVI UCHUN MASALALAR \ud83d\udccc API funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. Brauzer orqali /tasks/ manzilida vazifalar ro'yxatini ko'ring. 2. Postman yoki DRF interfeysi yordamida yangi vazifa qo'shing (masalan, title: \"Test vazifa\", completed: False ). 3. /tasks/1/ manzilida bitta vazifani yangilang (masalan, completed ni true ga o'zgartiring). 4. /tasks/1/ manzilidan foydalanib, 1-ID li vazifani o'chiring.","title":"Implementing CRUD Operations"},{"location":"drf/implementing-crud-operations/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/implementing-crud-operations/#3-dars-crud-operatsiyalarini-function-based-views-bilan-amalga-oshirish","text":"Bu darsda Django REST Framework (DRF) yordamida CRUD (Create, Read, Update, Delete) operatsiyalarini function-based views (FBV) yordamida bosqichma-bosqich amalga oshiramiz. Har bir qadam tushunarli va faqat CRUD operatsiyalariga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz.","title":"\ud83e\udde9 3-DARS: CRUD OPERATSIYALARINI FUNCTION-BASED VIEWS BILAN AMALGA OSHIRISH"},{"location":"drf/implementing-crud-operations/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - Ma'lumotlar bazasi migratsiyalari qo'llanilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/implementing-crud-operations/#2-crud-operatsiyalarini-tushunish","text":"\ud83d\udccc CRUD operatsiyalari quyidagilarni o'z ichiga oladi: - Create : Yangi ma'lumot qo'shish. - Read : Mavjud ma'lumotlarni o'qish (ro'yxat yoki bitta ob'ekt). - Update : Mavjud ma'lumotlarni yangilash. - Delete : Ma'lumotlarni o'chirish. \ud83d\udccc Function-based views yordamida har bir operatsiyani alohida funksiya sifatida yozamiz.","title":"\u2705 2. CRUD OPERATSIYALARINI TUSHUNISH"},{"location":"drf/implementing-crud-operations/#3-model-va-serializerni-tekshirish","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz:","title":"\u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH"},{"location":"drf/implementing-crud-operations/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/implementing-crud-operations/#serializer-tekshirish","text":"\ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): class Meta: model = Task fields = ['id', 'title', 'completed', 'created_at']","title":"\u2747\ufe0f Serializer tekshirish:"},{"location":"drf/implementing-crud-operations/#4-function-based-views-yaratish","text":"\ud83d\udccc myapp/views.py faylini yangilaymiz va CRUD operatsiyalari uchun function-based views yozamiz: from rest_framework.decorators import api_view from rest_framework.response import Response from rest_framework import status from .models import Task from .serializers import TaskSerializer @api_view(['GET', 'POST']) def task_list(request): if request.method == 'GET': tasks = Task.objects.all() serializer = TaskSerializer(tasks, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = TaskSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) @api_view(['GET', 'PUT', 'DELETE']) def task_detail(request, pk): try: task = Task.objects.get(pk=pk) except Task.DoesNotExist: return Response(status=status.HTTP_404_NOT_FOUND) if request.method == 'GET': serializer = TaskSerializer(task) return Response(serializer.data) elif request.method == 'PUT': serializer = TaskSerializer(task, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == 'DELETE': task.delete() return Response(status=status.HTTP_204_NO_CONTENT) \ud83d\udccc Tushuntirish : - task_list : GET (barcha vazifalarni o'qish) va POST (yangi vazifa qo'shish) so'rovlarini boshqaradi. - task_detail : GET (bitta vazifani o'qish), PUT (vazifani yangilash) va DELETE (vazifani o'chirish) so'rovlarini boshqaradi. - @api_view dekoratori DRFning API funksiyalarini yoqadi.","title":"\u2705 4. FUNCTION-BASED VIEWS YARATISH"},{"location":"drf/implementing-crud-operations/#5-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylini yangilaymiz va function-based views uchun URL marshrutlarini qo'shamiz: from django.urls import path from myapp.views import task_list, task_detail urlpatterns = [ path('tasks/', task_list, name='task-list'), path('tasks/<int:pk>/', task_detail, name='task-detail'), ] \ud83d\udccc Tushuntirish : - /tasks/ manzili vazifalar ro'yxatini ko'rish va yangi vazifa qo'shish uchun. - /tasks/<pk>/ manzili bitta vazifani ko'rish, yangilash yoki o'chirish uchun.","title":"\u2705 5. URL SOZLASH"},{"location":"drf/implementing-crud-operations/#6-crud-operatsiyalarini-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda yoki Postman kabi vositalar yordamida quyidagi manzillarni sinab ko'ring:","title":"\u2705 6. CRUD OPERATSIYALARINI SINAB KO'RISH"},{"location":"drf/implementing-crud-operations/#create-yangi-vazifa-qoshish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (Postman orqali): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"completed\": false}' \ud83d\udccc DRF interfeysi orqali ham yangi vazifa qo'shishingiz mumkin.","title":"\u2747\ufe0f Create (Yangi vazifa qo'shish):"},{"location":"drf/implementing-crud-operations/#read-malumotlarni-oqish","text":"Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc Brauzerda bu manzilga o'tsangiz, barcha vazifalar JSON formatida chiqadi. Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ (1 - vazifa ID si) \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/1/","title":"\u2747\ufe0f Read (Ma'lumotlarni o'qish):"},{"location":"drf/implementing-crud-operations/#update-malumotlarni-yangilash","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PUT \ud83d\udccc Masalan (vazifani yangilash uchun): curl -X PUT http://127.0.0.1:8000/tasks/1/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangilangan vazifa\", \"completed\": true}'","title":"\u2747\ufe0f Update (Ma'lumotlarni yangilash):"},{"location":"drf/implementing-crud-operations/#delete-malumotlarni-ochirish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Bu 1-ID li vazifani o'chiradi.","title":"\u2747\ufe0f Delete (Ma'lumotlarni o'chirish):"},{"location":"drf/implementing-crud-operations/#7-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 7. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/implementing-crud-operations/#admin-foydalanuvchisini-tekshirish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa: python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/implementing-crud-operations/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida quyidagi kod bo'lishi kerak: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalarni qo'shing, tahrirlang yoki o'chiring.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/implementing-crud-operations/#8-crud-sinovi-uchun-masalalar","text":"\ud83d\udccc API funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. Brauzer orqali /tasks/ manzilida vazifalar ro'yxatini ko'ring. 2. Postman yoki DRF interfeysi yordamida yangi vazifa qo'shing (masalan, title: \"Test vazifa\", completed: False ). 3. /tasks/1/ manzilida bitta vazifani yangilang (masalan, completed ni true ga o'zgartiring). 4. /tasks/1/ manzilidan foydalanib, 1-ID li vazifani o'chiring.","title":"\u2705 8. CRUD SINOVI UCHUN MASALALAR"},{"location":"drf/introduction/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 INTRODUCTION TO DJANGO REST FRAMEWORK \u2705 DJANGO REST FRAMEWORK (DRF) NIMA? \ud83d\udccc DRF \u2013 bu Django REST Framework degan so\u2018zlarning qisqartmasi. Bu Django frameworki ustiga qo\u2018shimcha kutubxona bo\u2018lib, u orqali biz API (Application Programming Interface) yaratamiz. \ud83d\udccc DRF yordamida biz backend (ma\u2019lumotlar bazasi bilan ishlovchi qism) bilan frontend yoki mobil ilovalar o\u2018rtasida JSON formatidagi muloqotni tashkil qilamiz. \ud83d\udccc Bu kutubxona nafaqat CRUD amallarni amalga oshirish, balki authentication, permission, pagination, throttling, filtering, versioning kabi ilg\u2018or funksiyalarni ham osonlashtiradi. \u2705 DRF NIMA UCHUN KERAK? \ud83d\udccc Django odatda veb sahifalar (HTML) bilan ishlashga moslashgan. Ammo ko\u2018plab zamonaviy ilovalar (masalan, mobil ilovalar, frontend (React, Vue)) uchun API (Application Programming Interface) talab qilinadi. \ud83d\udccc DRF aynan shunday holatlarda: \ud83d\udd01 Django ma'lumotlarini JSON formatida frontend/mobil ilovaga uzatishda \u2705 CRUD (Create, Read, Update, Delete) amallarini API orqali bajarishda \ud83d\udd10 Token/Session asosida authentication va permission larni tashkil qilishda \ud83e\uddea API larni tez, xavfsiz va testga yaroqli qilishda juda foydalidir. \u2705 REST API NIMA? \ud83d\udccc REST (Representational State Transfer) \u2014 bu internet orqali resurslar (odatda ma\u2019lumotlar) bilan ishlash usuli. \ud83d\udccc REST API bu: GET \u2014 ma'lumot olish POST \u2014 ma'lumot yaratish PUT/PATCH \u2014 ma'lumotni yangilash DELETE \u2014 ma'lumotni o\u2018chirish \u2705 NEGA DRF KERAK? \ud83d\udccc Faraz qilaylik, sizda Kitob modeli bor: # models.py # Django framework'dan models moduli import qilinmoqda, bu model yaratish uchun kerak bo'ladi from django.db import models # Kitob nomli model (jadval) yaratilmoqda, u models.Model dan meros oladi class Book(models.Model): # 'name' - kitob nomini saqlash uchun CharField, maksimal uzunligi 100 ta belgidan iborat name = models.CharField(max_length=100) # 'author' - kitob muallifining ismi, CharField, maksimal uzunligi 100 ta belgidan iborat author = models.CharField(max_length=100) # 'date' - kitob chop etilgan sana, DateField tipida saqlanadi (faqat sana, vaqt emas) date = models.DateField() \ud83d\udccc Agar siz bu modelni React frontend yoki mobil ilova bilan ulamoqchi bo\u2018lsangiz, sizga API kerak bo\u2018ladi. Django oddiy holatda bunday JSON API bermaydi. Bu yerda DRF yordamga keladi. \u2705 DRF O\u2018RNATISH pip install djangorestframework \ud83d\udccc settings.py faylga DRF ni qo\u2018shing: INSTALLED_APPS = [ ... # Django REST Framework (DRF) \u2014 bu Django uchun API yaratish imkonini beradigan kuchli kutubxona. # Uni INSTALLED_APPS ga qo\u2018shish orqali DRF ning komponentlari (serializers, views, permissions va h.k.) loyihada ishlay oladi. # Masalan, DRF yordamida JSON formatda API endpointlar, CRUD amallarini bajaruvchi class-based yoki function-based viewlar yozish mumkin. # Bu qatorda 'rest_framework' yozilishi orqali DRF Django tomonidan tan olinadi va ishga tushiriladi. 'rest_framework', ] from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('api/', include('base.urls')), ] \u2747\ufe0f DRFDA ODDIY API YARATISH \u2733\ufe0f 1. Model # models.py from django.db import models class Student(models.Model): name = models.CharField(max_length=50) age = models.IntegerField() email = models.EmailField() def __str__(self): return self.name \u2733\ufe0f 2. Serializers \ud83d\udccc DRF da serializer \u2013 bu Django modelidagi ma\u2019lumotlarni JSON, XML yoki boshqa formatlarga o\u2018tkazish uchun ishlatiladigan vosita. Shu bilan birga, u ma\u2019lumotlarni tekshirish (validation) va yaratish/yangilash (create/update) imkonini beradi. # serializers.py from rest_framework import serializers from .models import Student class StudentSerializer(serializers.ModelSerializer): class Meta: model = Student fields = ['id', 'name', 'age', 'email'] \u2733\ufe0f 3. Views # views.py from rest_framework.decorators import api_view from rest_framework.response import Response from .models import Student from .serializers import StudentSerializer @api_view(['GET']) def student_list(request): students = Student.objects.all() # Barcha studentlarni olish serializer = StudentSerializer(students, many=True) # JSONga aylantirish return Response(serializer.data) # Foydalanuvchiga yuborish many=True \u2192 ko\u2018p obyektlarni JSON formatga aylantirish uchun serializer.data \u2192 JSON ma\u2019lumotlar \u2733\ufe0f 4. urls # urls.py from django.urls import path from .views import student_list urlpatterns = [ path('students/', student_list), ] \u2733\ufe0f POST so\u2018rov bilan yangi student qo\u2018shish @api_view(['GET', 'POST']) def student_list(request): if request.method == 'GET': students = Student.objects.all() serializer = StudentSerializer(students, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = StudentSerializer(data=request.data) # Foydalanuvchidan ma'lumot olish if serializer.is_valid(): # Tekshirish serializer.save() # Bazaga saqlash return Response(serializer.data, status=201) return Response(serializer.errors, status=400) # Xato bo\u2018lsa \u2705 AMALIYOT \u2747\ufe0f Simple Book API Django loyihasi va books ilovasini yaratish. Kitoblar modeli yaratish (title, author, published_year). Modelni ma\u2019lumotlar bazasiga tatbiq qilish (migratsiyalar). Modelni admin panelda ro\u2018yxatga olish va kitoblar qo\u2018shish. Serializer yaratish (model \u2192 JSON). Faqat GET operatsiyasi qiladigan API view yaratish. Endpoint URLini sozlash. Brauzer yoki Postman orqali APIni test qilish (kitoblar ro\u2018yxatini olish).","title":"Introduction to DRF"},{"location":"drf/introduction/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/introduction/#introduction-to-django-rest-framework","text":"","title":"\ud83e\udde9 INTRODUCTION TO DJANGO REST FRAMEWORK"},{"location":"drf/introduction/#django-rest-framework-drf-nima","text":"\ud83d\udccc DRF \u2013 bu Django REST Framework degan so\u2018zlarning qisqartmasi. Bu Django frameworki ustiga qo\u2018shimcha kutubxona bo\u2018lib, u orqali biz API (Application Programming Interface) yaratamiz. \ud83d\udccc DRF yordamida biz backend (ma\u2019lumotlar bazasi bilan ishlovchi qism) bilan frontend yoki mobil ilovalar o\u2018rtasida JSON formatidagi muloqotni tashkil qilamiz. \ud83d\udccc Bu kutubxona nafaqat CRUD amallarni amalga oshirish, balki authentication, permission, pagination, throttling, filtering, versioning kabi ilg\u2018or funksiyalarni ham osonlashtiradi.","title":"\u2705 DJANGO REST FRAMEWORK (DRF) NIMA?"},{"location":"drf/introduction/#drf-nima-uchun-kerak","text":"\ud83d\udccc Django odatda veb sahifalar (HTML) bilan ishlashga moslashgan. Ammo ko\u2018plab zamonaviy ilovalar (masalan, mobil ilovalar, frontend (React, Vue)) uchun API (Application Programming Interface) talab qilinadi. \ud83d\udccc DRF aynan shunday holatlarda: \ud83d\udd01 Django ma'lumotlarini JSON formatida frontend/mobil ilovaga uzatishda \u2705 CRUD (Create, Read, Update, Delete) amallarini API orqali bajarishda \ud83d\udd10 Token/Session asosida authentication va permission larni tashkil qilishda \ud83e\uddea API larni tez, xavfsiz va testga yaroqli qilishda juda foydalidir.","title":"\u2705 DRF NIMA UCHUN KERAK?"},{"location":"drf/introduction/#rest-api-nima","text":"\ud83d\udccc REST (Representational State Transfer) \u2014 bu internet orqali resurslar (odatda ma\u2019lumotlar) bilan ishlash usuli. \ud83d\udccc REST API bu: GET \u2014 ma'lumot olish POST \u2014 ma'lumot yaratish PUT/PATCH \u2014 ma'lumotni yangilash DELETE \u2014 ma'lumotni o\u2018chirish","title":"\u2705 REST API NIMA?"},{"location":"drf/introduction/#nega-drf-kerak","text":"\ud83d\udccc Faraz qilaylik, sizda Kitob modeli bor: # models.py # Django framework'dan models moduli import qilinmoqda, bu model yaratish uchun kerak bo'ladi from django.db import models # Kitob nomli model (jadval) yaratilmoqda, u models.Model dan meros oladi class Book(models.Model): # 'name' - kitob nomini saqlash uchun CharField, maksimal uzunligi 100 ta belgidan iborat name = models.CharField(max_length=100) # 'author' - kitob muallifining ismi, CharField, maksimal uzunligi 100 ta belgidan iborat author = models.CharField(max_length=100) # 'date' - kitob chop etilgan sana, DateField tipida saqlanadi (faqat sana, vaqt emas) date = models.DateField() \ud83d\udccc Agar siz bu modelni React frontend yoki mobil ilova bilan ulamoqchi bo\u2018lsangiz, sizga API kerak bo\u2018ladi. Django oddiy holatda bunday JSON API bermaydi. Bu yerda DRF yordamga keladi.","title":"\u2705 NEGA DRF KERAK?"},{"location":"drf/introduction/#drf-ornatish","text":"pip install djangorestframework \ud83d\udccc settings.py faylga DRF ni qo\u2018shing: INSTALLED_APPS = [ ... # Django REST Framework (DRF) \u2014 bu Django uchun API yaratish imkonini beradigan kuchli kutubxona. # Uni INSTALLED_APPS ga qo\u2018shish orqali DRF ning komponentlari (serializers, views, permissions va h.k.) loyihada ishlay oladi. # Masalan, DRF yordamida JSON formatda API endpointlar, CRUD amallarini bajaruvchi class-based yoki function-based viewlar yozish mumkin. # Bu qatorda 'rest_framework' yozilishi orqali DRF Django tomonidan tan olinadi va ishga tushiriladi. 'rest_framework', ] from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('api/', include('base.urls')), ]","title":"\u2705 DRF O\u2018RNATISH"},{"location":"drf/introduction/#drfda-oddiy-api-yaratish","text":"","title":"\u2747\ufe0f DRFDA ODDIY API YARATISH"},{"location":"drf/introduction/#1-model","text":"# models.py from django.db import models class Student(models.Model): name = models.CharField(max_length=50) age = models.IntegerField() email = models.EmailField() def __str__(self): return self.name","title":"\u2733\ufe0f 1. Model"},{"location":"drf/introduction/#2-serializers","text":"\ud83d\udccc DRF da serializer \u2013 bu Django modelidagi ma\u2019lumotlarni JSON, XML yoki boshqa formatlarga o\u2018tkazish uchun ishlatiladigan vosita. Shu bilan birga, u ma\u2019lumotlarni tekshirish (validation) va yaratish/yangilash (create/update) imkonini beradi. # serializers.py from rest_framework import serializers from .models import Student class StudentSerializer(serializers.ModelSerializer): class Meta: model = Student fields = ['id', 'name', 'age', 'email']","title":"\u2733\ufe0f 2. Serializers"},{"location":"drf/introduction/#3-views","text":"# views.py from rest_framework.decorators import api_view from rest_framework.response import Response from .models import Student from .serializers import StudentSerializer @api_view(['GET']) def student_list(request): students = Student.objects.all() # Barcha studentlarni olish serializer = StudentSerializer(students, many=True) # JSONga aylantirish return Response(serializer.data) # Foydalanuvchiga yuborish many=True \u2192 ko\u2018p obyektlarni JSON formatga aylantirish uchun serializer.data \u2192 JSON ma\u2019lumotlar","title":"\u2733\ufe0f 3. Views"},{"location":"drf/introduction/#4-urls","text":"# urls.py from django.urls import path from .views import student_list urlpatterns = [ path('students/', student_list), ]","title":"\u2733\ufe0f 4. urls"},{"location":"drf/introduction/#post-sorov-bilan-yangi-student-qoshish","text":"@api_view(['GET', 'POST']) def student_list(request): if request.method == 'GET': students = Student.objects.all() serializer = StudentSerializer(students, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = StudentSerializer(data=request.data) # Foydalanuvchidan ma'lumot olish if serializer.is_valid(): # Tekshirish serializer.save() # Bazaga saqlash return Response(serializer.data, status=201) return Response(serializer.errors, status=400) # Xato bo\u2018lsa","title":"\u2733\ufe0f POST so\u2018rov bilan yangi student qo\u2018shish"},{"location":"drf/introduction/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"drf/introduction/#simple-book-api","text":"Django loyihasi va books ilovasini yaratish. Kitoblar modeli yaratish (title, author, published_year). Modelni ma\u2019lumotlar bazasiga tatbiq qilish (migratsiyalar). Modelni admin panelda ro\u2018yxatga olish va kitoblar qo\u2018shish. Serializer yaratish (model \u2192 JSON). Faqat GET operatsiyasi qiladigan API view yaratish. Endpoint URLini sozlash. Brauzer yoki Postman orqali APIni test qilish (kitoblar ro\u2018yxatini olish).","title":"\u2747\ufe0f Simple Book API"},{"location":"drf/jwt-authentication/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 12-DARS: JWT AUTENTIFIKATSIYASI BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida JSON Web Token (JWT) autentifikatsiyasini sozlashni bosqichma-bosqich o'rganamiz. JWT autentifikatsiyasi token-ga asoslangan autentifikatsiyaning zamonaviy va xavfsiz shakli bo'lib, foydalanuvchi ma'lumotlarini token ichida saqlaydi. Har bir qadam tushunarli va faqat JWT autentifikatsiyasiga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, ruxsatlar va sahifalash asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (ruxsatlar, filtrlash va sahifalash bilan). - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. JWT AUTENTIFIKATSIYASINI TUSHUNISH \ud83d\udccc JWT (JSON Web Token) uch qismdan iborat: Header , Payload va Signature . U foydalanuvchi ma'lumotlarini (masalan, user ID) token ichida shifrlangan holda saqlaydi va server uni tekshiradi. \ud83d\udccc Afzalliklari: - Stateless: Serverda token saqlanmaydi, bu esa server resurslarini tejaydi. - Xavfsiz: Token imzo orqali himoyalanadi. - Moslashuvchan: Access va refresh tokenlar orqali qulay autentifikatsiya. \ud83d\udccc DRFda JWT sozlash uchun djangorestframework-simplejwt paketidan foydalanamiz. \u2705 3. JWT PAKETINI O'RNATISH \ud83d\udccc djangorestframework-simplejwt paketini o'rnatamiz: pip install djangorestframework-simplejwt \u2705 4. LOYIHA SOZLAMALARINI YANGILASH \ud83d\udccc myproject/settings.py faylida JWT autentifikatsiyasini qo'shamiz: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', # Oldingi token autentifikatsiyasi uchun (ixtiyoriy) 'django_filters', 'myapp', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', # JWT autentifikatsiyasi ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } \u2705 5. JWT URL LARINI SOZLASH \ud83d\udccc myproject/urls.py faylini yangilaymiz va JWT token olish/yangilash endpointlarini qo'shamiz: from django.urls import path, include from rest_framework.routers import DefaultRouter from myapp.views import TaskViewSet from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), # Access va refresh token olish path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), # Refresh token yordamida yangi access token olish ] \ud83d\udccc Tushuntirish : - TokenObtainPairView : Foydalanuvchi login/parol orqali access va refresh tokenlarini olish uchun. - TokenRefreshView : Refresh token yordamida yangi access token olish uchun. \u2705 6. MODEL VA SERIALIZERNI TEKSHIRISH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz: \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title \u2747\ufe0f Serializer tekshirish : \ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \u2705 7. VIEWSET NI TEKSHIRISH \ud83d\udccc myapp/views.py faylida TaskViewSet oldingi darsdagidek qoladi, chunki JWT autentifikatsiyasi global sozlamalar orqali qo'llaniladi: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user) \u2705 8. JWT AUTENTIFIKATSIYASINI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \u2747\ufe0f Foydalanuvchi yaratish : \ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \u2747\ufe0f JWT token olish : \ud83d\udccc Manzil : http://127.0.0.1:8000/api/token/ \ud83d\udccc Usul : POST \ud83d\udccc Access va refresh tokenlarni olish: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"user1\", \"password\": \"pass123\"}' \ud83d\udccc Javob quyidagicha bo'ladi: { \"refresh\": \"<refresh_token>\", \"access\": \"<access_token>\" } \ud83d\udccc access_token ni saqlang, chunki u API so'rovlarida ishlatiladi. refresh_token esa yangi access token olish uchun ishlatiladi. \u2747\ufe0f API so'rovlarida JWT ishlatish : \ud83d\udccc API so'rovlarida Authorization sarlavhasida Bearer <access_token> yuboring. Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET bash curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" Yangi vazifa qo'shish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST bash curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test vazifa\"}' Vazifani yangilash : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH bash curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' Vazifani o'chirish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE bash curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" \u2747\ufe0f Refresh token bilan yangi access token olish : \ud83d\udccc Manzil : http://127.0.0.1:8000/api/token/refresh/ \ud83d\udccc Usul : POST curl -X POST http://127.0.0.1:8000/api/token/refresh/ -H \"Content-Type: application/json\" -d '{\"refresh\": \"<refresh_token>\"}' \ud83d\udccc Javobda yangi access_token qaytadi. \u2747\ufe0f Tokensiz so'rov sinovi : \ud83d\udccc Tokensiz so'rov yuborsangiz, 401 Unauthorized xatosi qaytadi: curl http://127.0.0.1:8000/tasks/ \u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang. \u2705 10. SINOV UCHUN MASALALAR \ud83d\udccc JWT autentifikatsiyasini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /api/token/ manzilidan access va refresh tokenlarni oling. 2. Access token bilan /tasks/ manzilida yangi vazifa qo'shing. 3. Refresh token yordamida yangi access token oling va u bilan so'rov yuboring. 4. Tokensiz so'rov yuboring va 401 Unauthorized xatosini oling.","title":"JWT Authentication"},{"location":"drf/jwt-authentication/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/jwt-authentication/#12-dars-jwt-autentifikatsiyasi-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida JSON Web Token (JWT) autentifikatsiyasini sozlashni bosqichma-bosqich o'rganamiz. JWT autentifikatsiyasi token-ga asoslangan autentifikatsiyaning zamonaviy va xavfsiz shakli bo'lib, foydalanuvchi ma'lumotlarini token ichida saqlaydi. Har bir qadam tushunarli va faqat JWT autentifikatsiyasiga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, ruxsatlar va sahifalash asosida davom etamiz.","title":"\ud83e\udde9 12-DARS: JWT AUTENTIFIKATSIYASI BILAN ISHLASH"},{"location":"drf/jwt-authentication/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (ruxsatlar, filtrlash va sahifalash bilan). - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/jwt-authentication/#2-jwt-autentifikatsiyasini-tushunish","text":"\ud83d\udccc JWT (JSON Web Token) uch qismdan iborat: Header , Payload va Signature . U foydalanuvchi ma'lumotlarini (masalan, user ID) token ichida shifrlangan holda saqlaydi va server uni tekshiradi. \ud83d\udccc Afzalliklari: - Stateless: Serverda token saqlanmaydi, bu esa server resurslarini tejaydi. - Xavfsiz: Token imzo orqali himoyalanadi. - Moslashuvchan: Access va refresh tokenlar orqali qulay autentifikatsiya. \ud83d\udccc DRFda JWT sozlash uchun djangorestframework-simplejwt paketidan foydalanamiz.","title":"\u2705 2. JWT AUTENTIFIKATSIYASINI TUSHUNISH"},{"location":"drf/jwt-authentication/#3-jwt-paketini-ornatish","text":"\ud83d\udccc djangorestframework-simplejwt paketini o'rnatamiz: pip install djangorestframework-simplejwt","title":"\u2705 3. JWT PAKETINI O'RNATISH"},{"location":"drf/jwt-authentication/#4-loyiha-sozlamalarini-yangilash","text":"\ud83d\udccc myproject/settings.py faylida JWT autentifikatsiyasini qo'shamiz: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', # Oldingi token autentifikatsiyasi uchun (ixtiyoriy) 'django_filters', 'myapp', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', # JWT autentifikatsiyasi ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, }","title":"\u2705 4. LOYIHA SOZLAMALARINI YANGILASH"},{"location":"drf/jwt-authentication/#5-jwt-url-larini-sozlash","text":"\ud83d\udccc myproject/urls.py faylini yangilaymiz va JWT token olish/yangilash endpointlarini qo'shamiz: from django.urls import path, include from rest_framework.routers import DefaultRouter from myapp.views import TaskViewSet from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), # Access va refresh token olish path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), # Refresh token yordamida yangi access token olish ] \ud83d\udccc Tushuntirish : - TokenObtainPairView : Foydalanuvchi login/parol orqali access va refresh tokenlarini olish uchun. - TokenRefreshView : Refresh token yordamida yangi access token olish uchun.","title":"\u2705 5. JWT URL LARINI SOZLASH"},{"location":"drf/jwt-authentication/#6-model-va-serializerni-tekshirish","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz:","title":"\u2705 6. MODEL VA SERIALIZERNI TEKSHIRISH"},{"location":"drf/jwt-authentication/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/jwt-authentication/#serializer-tekshirish","text":"\ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value","title":"\u2747\ufe0f Serializer tekshirish:"},{"location":"drf/jwt-authentication/#7-viewset-ni-tekshirish","text":"\ud83d\udccc myapp/views.py faylida TaskViewSet oldingi darsdagidek qoladi, chunki JWT autentifikatsiyasi global sozlamalar orqali qo'llaniladi: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user)","title":"\u2705 7. VIEWSET NI TEKSHIRISH"},{"location":"drf/jwt-authentication/#8-jwt-autentifikatsiyasini-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver","title":"\u2705 8. JWT AUTENTIFIKATSIYASINI SINAB KO'RISH"},{"location":"drf/jwt-authentication/#foydalanuvchi-yaratish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123","title":"\u2747\ufe0f Foydalanuvchi yaratish:"},{"location":"drf/jwt-authentication/#jwt-token-olish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/api/token/ \ud83d\udccc Usul : POST \ud83d\udccc Access va refresh tokenlarni olish: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"user1\", \"password\": \"pass123\"}' \ud83d\udccc Javob quyidagicha bo'ladi: { \"refresh\": \"<refresh_token>\", \"access\": \"<access_token>\" } \ud83d\udccc access_token ni saqlang, chunki u API so'rovlarida ishlatiladi. refresh_token esa yangi access token olish uchun ishlatiladi.","title":"\u2747\ufe0f JWT token olish:"},{"location":"drf/jwt-authentication/#api-sorovlarida-jwt-ishlatish","text":"\ud83d\udccc API so'rovlarida Authorization sarlavhasida Bearer <access_token> yuboring. Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET bash curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" Yangi vazifa qo'shish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST bash curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test vazifa\"}' Vazifani yangilash : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH bash curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' Vazifani o'chirish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE bash curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\"","title":"\u2747\ufe0f API so'rovlarida JWT ishlatish:"},{"location":"drf/jwt-authentication/#refresh-token-bilan-yangi-access-token-olish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/api/token/refresh/ \ud83d\udccc Usul : POST curl -X POST http://127.0.0.1:8000/api/token/refresh/ -H \"Content-Type: application/json\" -d '{\"refresh\": \"<refresh_token>\"}' \ud83d\udccc Javobda yangi access_token qaytadi.","title":"\u2747\ufe0f Refresh token bilan yangi access token olish:"},{"location":"drf/jwt-authentication/#tokensiz-sorov-sinovi","text":"\ud83d\udccc Tokensiz so'rov yuborsangiz, 401 Unauthorized xatosi qaytadi: curl http://127.0.0.1:8000/tasks/","title":"\u2747\ufe0f Tokensiz so'rov sinovi:"},{"location":"drf/jwt-authentication/#9-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/jwt-authentication/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/jwt-authentication/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/jwt-authentication/#10-sinov-uchun-masalalar","text":"\ud83d\udccc JWT autentifikatsiyasini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /api/token/ manzilidan access va refresh tokenlarni oling. 2. Access token bilan /tasks/ manzilida yangi vazifa qo'shing. 3. Refresh token yordamida yangi access token oling va u bilan so'rov yuboring. 4. Tokensiz so'rov yuboring va 401 Unauthorized xatosini oling.","title":"\u2705 10. SINOV UCHUN MASALALAR"},{"location":"drf/setting-up-django-project-and-drf/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 1-DARS: DJANGO LOYIHASI VA DRF SOZLASH Bu darsda Django va Django REST Framework (DRF) yordamida loyiha yaratish va oddiy API sozlashni bosqichma-bosqich o'rganamiz. Har bir qadam tushunarli va aniq bo'ladi. \u2705 1. MUHITNI TAYYORLASH \u2747\ufe0f Python o'rnatish : \ud83d\udccc Python 3.8 yoki undan yuqori versiyani o'rnating (https://www.python.org/downloads/). \u2747\ufe0f Virtual muhit yaratish : \ud83d\udccc Virtual muhit loyiha uchun alohida muhit yaratadi, bu boshqa loyihalarga ta'sir qilmaslikni ta'minlaydi. python -m venv env source env/bin/activate # Windows uchun: env\\Scripts\\activate \u2747\ufe0f Django va DRF o'rnatish : \ud83d\udccc Bu Django va DRF kutubxonalarini o'rnatadi. pip install django djangorestframework \u2705 2. DJANGO LOYIHASINI YARATISH \u2747\ufe0f Loyiha yaratish : \ud83d\udccc Quyidagi buyruq myproject nomli yangi loyiha jildini yaratadi. django-admin startproject myproject . \u2747\ufe0f Loyha tuzilishi : myproject/ \u251c\u2500\u2500 manage.py \u251c\u2500\u2500 myproject/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 settings.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u251c\u2500\u2500 asgi.py \u2502 \u2514\u2500\u2500 wsgi.py manage.py : Loyiha boshqaruvi uchun asosiy fayl. settings.py : Loyiha sozlamalari. urls.py : URL marshrutlari. \u2747\ufe0f Serverni ishga tushirish : \ud83d\udccc Serverni ishga tushirib, loyiha ishlayotganini tekshiramiz. python manage.py runserver \ud83d\udccc Brauzerda http://127.0.0.1:8000/ manziliga o'ting. \"Django welcome\" sahifasini ko'rasiz. \u2705 3. DJANGO ILOVASINI YARATISH \ud83d\udccc Django loyihasida ilovalar (apps) alohida modullar sifatida ishlaydi. \u2747\ufe0f Ilova yaratish : python manage.py startapp myapp \ud83d\udccc Bu myapp nomli ilova jildini yaratadi. \u2747\ufe0f Ilovani loyihaga qo'shish : \ud83d\udccc myproject/settings.py faylini oching va INSTALLED_APPS ro'yxatiga quyidagini qo'shing: INSTALLED_APPS = [ ... 'myapp', 'rest_framework', # DRF ni qo'shamiz ] \u2705 4. MA'LUMOTLAR BAZASINI SOZLASH \ud83d\udccc Django standart ravishda SQLite bilan ishlaydi, bu oddiy loyihalar uchun yetarli. \u2747\ufe0f Model yaratish : \ud83d\udccc myapp/models.py faylida oddiy model yaratamiz: from django.db import models class Item(models.Model): name = models.CharField(max_length=100) description = models.TextField() created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.name \u2747\ufe0f Migratsiyalarni yaratish va qo'llash : \ud83d\udccc Modelni ma'lumotlar bazasida jadvallar sifatida yaratish uchun: python manage.py makemigrations python manage.py migrate \u2705 5. DRF BILAN API YARATISH \ud83d\udccc DRF yordamida oddiy API yaratamiz. \u2747\ufe0f Serializer yaratish : \ud83d\udccc myapp/serializers.py faylini yarating va quyidagi kodni qo'shing: from rest_framework import serializers from .models import Item class ItemSerializer(serializers.ModelSerializer): class Meta: model = Item fields = ['id', 'name', 'description', 'created_at'] \u2747\ufe0f View yaratish : \ud83d\udccc myapp/views.py faylida API view yaratamiz: from rest_framework import viewsets from .models import Item from .serializers import ItemSerializer class ItemViewSet(viewsets.ModelViewSet): queryset = Item.objects.all() serializer_class = ItemSerializer \u2747\ufe0f URL sozlash : \ud83d\udccc myproject/urls.py faylini yangilang: from django.urls import path, include from rest_framework.routers import DefaultRouter from myapp.views import ItemViewSet router = DefaultRouter() router.register(r'items', ItemViewSet) urlpatterns = [ path('', include(router.urls)), ] \u2705 6. API NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda http://127.0.0.1:8000/items/ manziliga o'ting. DRF interfeysi orqali ma'lumotlarni ko'rishingiz, qo'shishingiz va o'zgartirishingiz mumkin. \u2705 7. MA'LUMOT QO'SHISH (IXTIYORIY) \ud83d\udccc Django admin paneli orqali ma'lumot qo'shish uchun: \u2747\ufe0f Admin foydalanuvchisini yaratish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida modelni ro'yxatdan o'tkazing: from django.contrib import admin from .models import Item admin.site.register(Item) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va ma'lumot qo'shing.","title":"Setting Up a Django Project and DRF"},{"location":"drf/setting-up-django-project-and-drf/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/setting-up-django-project-and-drf/#1-dars-django-loyihasi-va-drf-sozlash","text":"Bu darsda Django va Django REST Framework (DRF) yordamida loyiha yaratish va oddiy API sozlashni bosqichma-bosqich o'rganamiz. Har bir qadam tushunarli va aniq bo'ladi.","title":"\ud83e\udde9 1-DARS: DJANGO LOYIHASI VA DRF SOZLASH"},{"location":"drf/setting-up-django-project-and-drf/#1-muhitni-tayyorlash","text":"","title":"\u2705 1. MUHITNI TAYYORLASH"},{"location":"drf/setting-up-django-project-and-drf/#python-ornatish","text":"\ud83d\udccc Python 3.8 yoki undan yuqori versiyani o'rnating (https://www.python.org/downloads/).","title":"\u2747\ufe0f Python o'rnatish:"},{"location":"drf/setting-up-django-project-and-drf/#virtual-muhit-yaratish","text":"\ud83d\udccc Virtual muhit loyiha uchun alohida muhit yaratadi, bu boshqa loyihalarga ta'sir qilmaslikni ta'minlaydi. python -m venv env source env/bin/activate # Windows uchun: env\\Scripts\\activate","title":"\u2747\ufe0f Virtual muhit yaratish:"},{"location":"drf/setting-up-django-project-and-drf/#django-va-drf-ornatish","text":"\ud83d\udccc Bu Django va DRF kutubxonalarini o'rnatadi. pip install django djangorestframework","title":"\u2747\ufe0f Django va DRF o'rnatish:"},{"location":"drf/setting-up-django-project-and-drf/#2-django-loyihasini-yaratish","text":"","title":"\u2705 2. DJANGO LOYIHASINI YARATISH"},{"location":"drf/setting-up-django-project-and-drf/#loyiha-yaratish","text":"\ud83d\udccc Quyidagi buyruq myproject nomli yangi loyiha jildini yaratadi. django-admin startproject myproject .","title":"\u2747\ufe0f Loyiha yaratish:"},{"location":"drf/setting-up-django-project-and-drf/#loyha-tuzilishi","text":"myproject/ \u251c\u2500\u2500 manage.py \u251c\u2500\u2500 myproject/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 settings.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u251c\u2500\u2500 asgi.py \u2502 \u2514\u2500\u2500 wsgi.py manage.py : Loyiha boshqaruvi uchun asosiy fayl. settings.py : Loyiha sozlamalari. urls.py : URL marshrutlari.","title":"\u2747\ufe0f Loyha tuzilishi:"},{"location":"drf/setting-up-django-project-and-drf/#serverni-ishga-tushirish","text":"\ud83d\udccc Serverni ishga tushirib, loyiha ishlayotganini tekshiramiz. python manage.py runserver \ud83d\udccc Brauzerda http://127.0.0.1:8000/ manziliga o'ting. \"Django welcome\" sahifasini ko'rasiz.","title":"\u2747\ufe0f Serverni ishga tushirish:"},{"location":"drf/setting-up-django-project-and-drf/#3-django-ilovasini-yaratish","text":"\ud83d\udccc Django loyihasida ilovalar (apps) alohida modullar sifatida ishlaydi.","title":"\u2705 3. DJANGO ILOVASINI YARATISH"},{"location":"drf/setting-up-django-project-and-drf/#ilova-yaratish","text":"python manage.py startapp myapp \ud83d\udccc Bu myapp nomli ilova jildini yaratadi.","title":"\u2747\ufe0f Ilova yaratish:"},{"location":"drf/setting-up-django-project-and-drf/#ilovani-loyihaga-qoshish","text":"\ud83d\udccc myproject/settings.py faylini oching va INSTALLED_APPS ro'yxatiga quyidagini qo'shing: INSTALLED_APPS = [ ... 'myapp', 'rest_framework', # DRF ni qo'shamiz ]","title":"\u2747\ufe0f Ilovani loyihaga qo'shish:"},{"location":"drf/setting-up-django-project-and-drf/#4-malumotlar-bazasini-sozlash","text":"\ud83d\udccc Django standart ravishda SQLite bilan ishlaydi, bu oddiy loyihalar uchun yetarli.","title":"\u2705 4. MA'LUMOTLAR BAZASINI SOZLASH"},{"location":"drf/setting-up-django-project-and-drf/#model-yaratish","text":"\ud83d\udccc myapp/models.py faylida oddiy model yaratamiz: from django.db import models class Item(models.Model): name = models.CharField(max_length=100) description = models.TextField() created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.name","title":"\u2747\ufe0f Model yaratish:"},{"location":"drf/setting-up-django-project-and-drf/#migratsiyalarni-yaratish-va-qollash","text":"\ud83d\udccc Modelni ma'lumotlar bazasida jadvallar sifatida yaratish uchun: python manage.py makemigrations python manage.py migrate","title":"\u2747\ufe0f Migratsiyalarni yaratish va qo'llash:"},{"location":"drf/setting-up-django-project-and-drf/#5-drf-bilan-api-yaratish","text":"\ud83d\udccc DRF yordamida oddiy API yaratamiz.","title":"\u2705 5. DRF BILAN API YARATISH"},{"location":"drf/setting-up-django-project-and-drf/#serializer-yaratish","text":"\ud83d\udccc myapp/serializers.py faylini yarating va quyidagi kodni qo'shing: from rest_framework import serializers from .models import Item class ItemSerializer(serializers.ModelSerializer): class Meta: model = Item fields = ['id', 'name', 'description', 'created_at']","title":"\u2747\ufe0f Serializer yaratish:"},{"location":"drf/setting-up-django-project-and-drf/#view-yaratish","text":"\ud83d\udccc myapp/views.py faylida API view yaratamiz: from rest_framework import viewsets from .models import Item from .serializers import ItemSerializer class ItemViewSet(viewsets.ModelViewSet): queryset = Item.objects.all() serializer_class = ItemSerializer","title":"\u2747\ufe0f View yaratish:"},{"location":"drf/setting-up-django-project-and-drf/#url-sozlash","text":"\ud83d\udccc myproject/urls.py faylini yangilang: from django.urls import path, include from rest_framework.routers import DefaultRouter from myapp.views import ItemViewSet router = DefaultRouter() router.register(r'items', ItemViewSet) urlpatterns = [ path('', include(router.urls)), ]","title":"\u2747\ufe0f URL sozlash:"},{"location":"drf/setting-up-django-project-and-drf/#6-api-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda http://127.0.0.1:8000/items/ manziliga o'ting. DRF interfeysi orqali ma'lumotlarni ko'rishingiz, qo'shishingiz va o'zgartirishingiz mumkin.","title":"\u2705 6. API NI SINAB KO'RISH"},{"location":"drf/setting-up-django-project-and-drf/#7-malumot-qoshish-ixtiyoriy","text":"\ud83d\udccc Django admin paneli orqali ma'lumot qo'shish uchun:","title":"\u2705 7. MA'LUMOT QO'SHISH (IXTIYORIY)"},{"location":"drf/setting-up-django-project-and-drf/#admin-foydalanuvchisini-yaratish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini yaratish:"},{"location":"drf/setting-up-django-project-and-drf/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida modelni ro'yxatdan o'tkazing: from django.contrib import admin from .models import Item admin.site.register(Item) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va ma'lumot qo'shing.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/signals-and-drf/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 13-DARS: SIGNALLAR VA DRF BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida Django signallari bilan ishlashni bosqichma-bosqich o'rganamiz. Signallar ma'lumotlar bazasidagi o'zgarishlarga (masalan, yangi obyekt yaratilishi yoki o'chirilishi) avtomatik ravishda javob berish imkonini beradi. Har bir qadam tushunarli va faqat signallar va DRF integratsiyasiga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar va sahifalash asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash va sahifalash bilan). - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. SIGNALLARNI TUSHUNISH \ud83d\udccc Django signallari ma'lumotlar bazasidagi hodisalarga (masalan, obyekt yaratilishi, yangilanishi yoki o'chirilishi) avtomatik javob berish uchun ishlatiladi. DRFda signallar API orqali amalga oshirilgan o'zgarishlarga qo'shimcha logika qo'shishda foydalidir. \ud83d\udccc Asosiy signallar: - post_save : Obyekt saqlanganda ishga tushadi. - pre_save : Obyekt saqlanishidan oldin ishga tushadi. - post_delete : Obyekt o'chirilganda ishga tushadi. \ud83d\udccc DRF bilan signallarni ishlatish API operatsiyalariga qo'shimcha funksionallik qo'shish uchun qulaydir (masalan, log yozish yoki bildirishnoma yuborish). \u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz: \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title \u2747\ufe0f Serializer tekshirish : \ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \u2705 4. SIGNALLARNI SOZLASH \ud83d\udccc Signallar yordamida vazifa yaratilganda yoki o'chirilganda log yozishni amalga oshiramiz. myapp/signals.py faylini yarating va quyidagi kodni qo'shing: from django.db.models.signals import post_save, post_delete from django.dispatch import receiver from .models import Task import logging # Logger sozlash logger = logging.getLogger(__name__) @receiver(post_save, sender=Task) def log_task_creation(sender, instance, created, **kwargs): if created: logger.info(f\"Yangi vazifa yaratildi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") else: logger.info(f\"Vazifa yangilandi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") @receiver(post_delete, sender=Task) def log_task_deletion(sender, instance, **kwargs): logger.info(f\"Vazifa o'chirildi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") \ud83d\udccc Tushuntirish : - post_save : Vazifa yaratilganda yoki yangilanganda ishga tushadi. - post_delete : Vazifa o'chirilganda ishga tushadi. - logger.info : O'zgarishlarni log fayliga yozadi. \u2705 5. SIGNALLARNI ILovaga ULASH \ud83d\udccc Signallarni ilovaga ulash uchun myapp/apps.py faylini yangilaymiz: from django.apps import AppConfig class MyappConfig(AppConfig): default_auto_field = 'django.db.models.BigAutoField' name = 'myapp' def ready(self): import myapp.signals # Signallarni import qilish \ud83d\udccc myproject/settings.py faylida INSTALLED_APPS da myapp ni aniq belgilang: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp.apps.MyappConfig', # To'g'ri AppConfig ] \u2705 6. LOGGING SOZLAMALARINI QO'SHISH \ud83d\udccc Loglarni ko'rish uchun myproject/settings.py fayliga logging sozlamalarini qo'shamiz: LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'handlers': { 'file': { 'level': 'INFO', 'class': 'logging.FileHandler', 'filename': 'debug.log', }, 'console': { 'level': 'INFO', 'class': 'logging.StreamHandler', }, }, 'loggers': { 'myapp': { 'handlers': ['file', 'console'], 'level': 'INFO', 'propagate': True, }, }, } \ud83d\udccc Tushuntirish : - Loglar debug.log fayliga yoziladi va konsolda ko'rinadi. - level: 'INFO' : Faqat INFO va undan yuqori darajadagi xabarlar yoziladi. \u2705 7. VIEWSET NI TEKSHIRISH \ud83d\udccc myapp/views.py faylida TaskViewSet oldingi darsdagidek qoladi: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user) \u2705 8. URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), ] \u2705 9. SIGNALLARNI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \u2747\ufe0f Foydalanuvchi va token yaratish : \ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc JWT token oling: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"user1\", \"password\": \"pass123\"}' \u2747\ufe0f Vazifa yaratish va signal sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test vazifa\"}' \ud83d\udccc Konsolda yoki debug.log faylida quyidagi logni ko'rasiz: Yangi vazifa yaratildi: Yangi vazifa (ID: 1, Owner: user1) \u2747\ufe0f Vazifa yangilash va signal sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' \ud83d\udccc Log: Vazifa yangilandi: Yangi vazifa (ID: 1, Owner: user1) \u2747\ufe0f Vazifa o'chirish va signal sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" \ud83d\udccc Log: Vazifa o'chirildi: Yangi vazifa (ID: 1, Owner: user1) \u2705 10. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang va loglarni tekshiring. \u2705 11. SINOV UCHUN MASALALAR \ud83d\udccc Signallarni sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va debug.log da logni tekshiring. 2. /tasks/1/ manzilida vazifani yangilang va logni ko'ring. 3. /tasks/1/ manzilida vazifani o'chiring va logni tekshiring. 4. Admin panelida vazifa qo'shing va signal ishlaganligini tasdiqlang.","title":"Signals and DRF"},{"location":"drf/signals-and-drf/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/signals-and-drf/#13-dars-signallar-va-drf-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida Django signallari bilan ishlashni bosqichma-bosqich o'rganamiz. Signallar ma'lumotlar bazasidagi o'zgarishlarga (masalan, yangi obyekt yaratilishi yoki o'chirilishi) avtomatik ravishda javob berish imkonini beradi. Har bir qadam tushunarli va faqat signallar va DRF integratsiyasiga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar va sahifalash asosida davom etamiz.","title":"\ud83e\udde9 13-DARS: SIGNALLAR VA DRF BILAN ISHLASH"},{"location":"drf/signals-and-drf/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash va sahifalash bilan). - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/signals-and-drf/#2-signallarni-tushunish","text":"\ud83d\udccc Django signallari ma'lumotlar bazasidagi hodisalarga (masalan, obyekt yaratilishi, yangilanishi yoki o'chirilishi) avtomatik javob berish uchun ishlatiladi. DRFda signallar API orqali amalga oshirilgan o'zgarishlarga qo'shimcha logika qo'shishda foydalidir. \ud83d\udccc Asosiy signallar: - post_save : Obyekt saqlanganda ishga tushadi. - pre_save : Obyekt saqlanishidan oldin ishga tushadi. - post_delete : Obyekt o'chirilganda ishga tushadi. \ud83d\udccc DRF bilan signallarni ishlatish API operatsiyalariga qo'shimcha funksionallik qo'shish uchun qulaydir (masalan, log yozish yoki bildirishnoma yuborish).","title":"\u2705 2. SIGNALLARNI TUSHUNISH"},{"location":"drf/signals-and-drf/#3-model-va-serializerni-tekshirish","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz:","title":"\u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH"},{"location":"drf/signals-and-drf/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/signals-and-drf/#serializer-tekshirish","text":"\ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value","title":"\u2747\ufe0f Serializer tekshirish:"},{"location":"drf/signals-and-drf/#4-signallarni-sozlash","text":"\ud83d\udccc Signallar yordamida vazifa yaratilganda yoki o'chirilganda log yozishni amalga oshiramiz. myapp/signals.py faylini yarating va quyidagi kodni qo'shing: from django.db.models.signals import post_save, post_delete from django.dispatch import receiver from .models import Task import logging # Logger sozlash logger = logging.getLogger(__name__) @receiver(post_save, sender=Task) def log_task_creation(sender, instance, created, **kwargs): if created: logger.info(f\"Yangi vazifa yaratildi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") else: logger.info(f\"Vazifa yangilandi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") @receiver(post_delete, sender=Task) def log_task_deletion(sender, instance, **kwargs): logger.info(f\"Vazifa o'chirildi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") \ud83d\udccc Tushuntirish : - post_save : Vazifa yaratilganda yoki yangilanganda ishga tushadi. - post_delete : Vazifa o'chirilganda ishga tushadi. - logger.info : O'zgarishlarni log fayliga yozadi.","title":"\u2705 4. SIGNALLARNI SOZLASH"},{"location":"drf/signals-and-drf/#5-signallarni-ilovaga-ulash","text":"\ud83d\udccc Signallarni ilovaga ulash uchun myapp/apps.py faylini yangilaymiz: from django.apps import AppConfig class MyappConfig(AppConfig): default_auto_field = 'django.db.models.BigAutoField' name = 'myapp' def ready(self): import myapp.signals # Signallarni import qilish \ud83d\udccc myproject/settings.py faylida INSTALLED_APPS da myapp ni aniq belgilang: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'myapp.apps.MyappConfig', # To'g'ri AppConfig ]","title":"\u2705 5. SIGNALLARNI ILovaga ULASH"},{"location":"drf/signals-and-drf/#6-logging-sozlamalarini-qoshish","text":"\ud83d\udccc Loglarni ko'rish uchun myproject/settings.py fayliga logging sozlamalarini qo'shamiz: LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'handlers': { 'file': { 'level': 'INFO', 'class': 'logging.FileHandler', 'filename': 'debug.log', }, 'console': { 'level': 'INFO', 'class': 'logging.StreamHandler', }, }, 'loggers': { 'myapp': { 'handlers': ['file', 'console'], 'level': 'INFO', 'propagate': True, }, }, } \ud83d\udccc Tushuntirish : - Loglar debug.log fayliga yoziladi va konsolda ko'rinadi. - level: 'INFO' : Faqat INFO va undan yuqori darajadagi xabarlar yoziladi.","title":"\u2705 6. LOGGING SOZLAMALARINI QO'SHISH"},{"location":"drf/signals-and-drf/#7-viewset-ni-tekshirish","text":"\ud83d\udccc myapp/views.py faylida TaskViewSet oldingi darsdagidek qoladi: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination def perform_create(self, serializer): serializer.save(owner=self.request.user)","title":"\u2705 7. VIEWSET NI TEKSHIRISH"},{"location":"drf/signals-and-drf/#8-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), ]","title":"\u2705 8. URL SOZLASH"},{"location":"drf/signals-and-drf/#9-signallarni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver","title":"\u2705 9. SIGNALLARNI SINAB KO'RISH"},{"location":"drf/signals-and-drf/#foydalanuvchi-va-token-yaratish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc JWT token oling: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"user1\", \"password\": \"pass123\"}'","title":"\u2747\ufe0f Foydalanuvchi va token yaratish:"},{"location":"drf/signals-and-drf/#vazifa-yaratish-va-signal-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test vazifa\"}' \ud83d\udccc Konsolda yoki debug.log faylida quyidagi logni ko'rasiz: Yangi vazifa yaratildi: Yangi vazifa (ID: 1, Owner: user1)","title":"\u2747\ufe0f Vazifa yaratish va signal sinovi:"},{"location":"drf/signals-and-drf/#vazifa-yangilash-va-signal-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' \ud83d\udccc Log: Vazifa yangilandi: Yangi vazifa (ID: 1, Owner: user1)","title":"\u2747\ufe0f Vazifa yangilash va signal sinovi:"},{"location":"drf/signals-and-drf/#vazifa-ochirish-va-signal-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Bearer <access_token>\" \ud83d\udccc Log: Vazifa o'chirildi: Yangi vazifa (ID: 1, Owner: user1)","title":"\u2747\ufe0f Vazifa o'chirish va signal sinovi:"},{"location":"drf/signals-and-drf/#10-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 10. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/signals-and-drf/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/signals-and-drf/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang va loglarni tekshiring.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/signals-and-drf/#11-sinov-uchun-masalalar","text":"\ud83d\udccc Signallarni sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va debug.log da logni tekshiring. 2. /tasks/1/ manzilida vazifani yangilang va logni ko'ring. 3. /tasks/1/ manzilida vazifani o'chiring va logni tekshiring. 4. Admin panelida vazifa qo'shing va signal ishlaganligini tasdiqlang.","title":"\u2705 11. SINOV UCHUN MASALALAR"},{"location":"drf/throttling-and-rate-limiting/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 9-DARS: THROTTLING VA RATE LIMITING BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida throttling (so'rov cheklovi) va rate limiting (tezlikni cheklash) ni sozlashni bosqichma-bosqich o'rganamiz. Throttling API resurslarini ortiqcha ishlatishni oldini oladi va serverni himoya qiladi. Har bir qadam tushunarli va faqat throttling va rate limiting ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, token autentifikatsiyasi va ruxsatlar asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (autentifikatsiya va ruxsatlar bilan). - Token autentifikatsiyasi va /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. THROTTLING VA RATE LIMITING NI TUSHUNISH \ud83d\udccc Throttling (so'rov cheklovi) DRFda API ga keladigan so'rovlar sonini cheklash uchun ishlatiladi. Bu serverni haddan tashqari yuklanishdan himoya qiladi va xavfsizlikni oshiradi. \ud83d\udccc Rate Limiting : Muayyan vaqt oralig'ida foydalanuvchi yoki IP manzilidan keladigan so'rovlar sonini cheklaydi. \ud83d\udccc DRFning o'rnatilgan throttling sinflari: - AnonRateThrottle : Autentifikatsiya qilinmagan (anonim) foydalanuvchilar uchun cheklov. - UserRateThrottle : Autentifikatsiya qilingan foydalanuvchilar uchun cheklov. - ScopedRateThrottle : Muayyan endpointlar uchun maxsus cheklovlar. \u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz: \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title \u2747\ufe0f Serializer tekshirish : \ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \u2705 4. THROTTLING SOZLAMALARINI QO'SHISH \ud83d\udccc DRFning o'rnatilgan throttling sinflarini ishlatish uchun myproject/settings.py faylini yangilaymiz: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'myapp', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', # Anonim foydalanuvchilar uchun soatiga 10 ta so'rov 'user': '20/hour', # Autentifikatsiya qilingan foydalanuvchilar uchun soatiga 20 ta so'rov }, } \ud83d\udccc Tushuntirish : - DEFAULT_THROTTLE_CLASSES : Standart throttling sinflarini belgilaydi. - DEFAULT_THROTTLE_RATES : Har bir sinf uchun cheklov stavkalarini sozlaydi (masalan, 10/hour \u2014 soatiga 10 ta so'rov). - anon : Autentifikatsiya qilinmagan foydalanuvchilar uchun. - user : Autentifikatsiya qilingan foydalanuvchilar uchun. \u2705 5. VIEWSET NI TEKSHIRISH \ud83d\udccc myapp/views.py faylida TaskViewSet oldingi darsdagidek qoladi, chunki throttling global sozlamalar orqali qo'llaniladi: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] def perform_create(self, serializer): serializer.save(owner=self.request.user) \ud83d\udccc Throttling global sozlamalar orqali avtomatik qo'llaniladi, shuning uchun viewsetda qo'shimcha o'zgartirish talab qilinmaydi. \u2705 6. MAXSUS THROTTLE SINF YARATISH \ud83d\udccc Muayyan endpoint uchun maxsus throttling sinfini yaratamiz. myapp/throttles.py faylini yarating va quyidagi kodni qo'shing: from rest_framework.throttling import UserRateThrottle class CustomTaskThrottle(UserRateThrottle): scope = 'task-create' def get_rate(self): return '5/hour' # Vazifa yaratish uchun soatiga 5 ta so'rov \ud83d\udccc Tushuntirish : - CustomTaskThrottle : UserRateThrottle dan meros oladi va faqat vazifa yaratish (POST) so'rovlari uchun cheklov qo'yadi. - scope : Throttle sozlamalarida ishlatiladigan identifikator. \ud83d\udccc myproject/settings.py faylida yangi scope ni qo'shing: REST_FRAMEWORK = { ... 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', 'task-create': '5/hour', # Yangi scope }, } \ud83d\udccc TaskViewSet ni yangilaymiz va POST so'rovlariga maxsus throttle qo'shamiz: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .throttles import CustomTaskThrottle from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] throttle_classes = [CustomTaskThrottle] # Maxsus throttle faqat POST uchun def perform_create(self, serializer): serializer.save(owner=self.request.user) \u2705 7. URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), ] \u2705 8. THROTTLING NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> . \u2747\ufe0f Foydalanuvchi va token yaratish : \ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc Token oling: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user1&password=pass123\" \u2747\ufe0f Throttling sinovi (Yangi vazifa qo'shish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc 5 marta ketma-ket POST so'rov yuboring: curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user1_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Test vazifa\", \"description\": \"Test\"}' \ud83d\udccc 6-so'rovda 429 Too Many Requests xatosi qaytadi, chunki task-create scope soatiga 5 ta so'rov bilan cheklangan. \u2747\ufe0f Read sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc 20 marta ketma-ket GET so'rov yuboring: curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user1_token>\" \ud83d\udccc 21-so'rovda 429 Too Many Requests xatosi qaytadi, chunki user throttle soatiga 20 ta so'rov bilan cheklangan. \u2747\ufe0f Anonim foydalanuvchi sinovi : \ud83d\udccc Tokensiz GET so'rov yuboring: curl http://127.0.0.1:8000/tasks/ \ud83d\udccc 10 marta ketma-ket so'rov yuborsangiz, 11-so'rovda 429 Too Many Requests xatosi qaytadi, chunki anon throttle soatiga 10 ta so'rov bilan cheklangan. \u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang. \u2705 10. SINOV UCHUN MASALALAR \ud83d\udccc Throttling ni sinash uchun quyidagi amallarni bajarib ko'ring: 1. user1 bilan 5 ta POST so'rov yuboring va 6-so'rovda 429 xatosini oling. 2. user1 bilan 20 ta GET so'rov yuboring va 21-so'rovda 429 xatosini oling. 3. Tokensiz 10 ta GET so'rov yuboring va 11-so'rovda 429 xatosini oling. 4. Admin panelida vazifa qo'shing va API orqali ko'ring.","title":"Throttling and Rate Limiting"},{"location":"drf/throttling-and-rate-limiting/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/throttling-and-rate-limiting/#9-dars-throttling-va-rate-limiting-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida throttling (so'rov cheklovi) va rate limiting (tezlikni cheklash) ni sozlashni bosqichma-bosqich o'rganamiz. Throttling API resurslarini ortiqcha ishlatishni oldini oladi va serverni himoya qiladi. Har bir qadam tushunarli va faqat throttling va rate limiting ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, token autentifikatsiyasi va ruxsatlar asosida davom etamiz.","title":"\ud83e\udde9 9-DARS: THROTTLING VA RATE LIMITING BILAN ISHLASH"},{"location":"drf/throttling-and-rate-limiting/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (autentifikatsiya va ruxsatlar bilan). - Token autentifikatsiyasi va /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/throttling-and-rate-limiting/#2-throttling-va-rate-limiting-ni-tushunish","text":"\ud83d\udccc Throttling (so'rov cheklovi) DRFda API ga keladigan so'rovlar sonini cheklash uchun ishlatiladi. Bu serverni haddan tashqari yuklanishdan himoya qiladi va xavfsizlikni oshiradi. \ud83d\udccc Rate Limiting : Muayyan vaqt oralig'ida foydalanuvchi yoki IP manzilidan keladigan so'rovlar sonini cheklaydi. \ud83d\udccc DRFning o'rnatilgan throttling sinflari: - AnonRateThrottle : Autentifikatsiya qilinmagan (anonim) foydalanuvchilar uchun cheklov. - UserRateThrottle : Autentifikatsiya qilingan foydalanuvchilar uchun cheklov. - ScopedRateThrottle : Muayyan endpointlar uchun maxsus cheklovlar.","title":"\u2705 2. THROTTLING VA RATE LIMITING NI TUSHUNISH"},{"location":"drf/throttling-and-rate-limiting/#3-model-va-serializerni-tekshirish","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz:","title":"\u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH"},{"location":"drf/throttling-and-rate-limiting/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/throttling-and-rate-limiting/#serializer-tekshirish","text":"\ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value","title":"\u2747\ufe0f Serializer tekshirish:"},{"location":"drf/throttling-and-rate-limiting/#4-throttling-sozlamalarini-qoshish","text":"\ud83d\udccc DRFning o'rnatilgan throttling sinflarini ishlatish uchun myproject/settings.py faylini yangilaymiz: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'myapp', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', # Anonim foydalanuvchilar uchun soatiga 10 ta so'rov 'user': '20/hour', # Autentifikatsiya qilingan foydalanuvchilar uchun soatiga 20 ta so'rov }, } \ud83d\udccc Tushuntirish : - DEFAULT_THROTTLE_CLASSES : Standart throttling sinflarini belgilaydi. - DEFAULT_THROTTLE_RATES : Har bir sinf uchun cheklov stavkalarini sozlaydi (masalan, 10/hour \u2014 soatiga 10 ta so'rov). - anon : Autentifikatsiya qilinmagan foydalanuvchilar uchun. - user : Autentifikatsiya qilingan foydalanuvchilar uchun.","title":"\u2705 4. THROTTLING SOZLAMALARINI QO'SHISH"},{"location":"drf/throttling-and-rate-limiting/#5-viewset-ni-tekshirish","text":"\ud83d\udccc myapp/views.py faylida TaskViewSet oldingi darsdagidek qoladi, chunki throttling global sozlamalar orqali qo'llaniladi: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] def perform_create(self, serializer): serializer.save(owner=self.request.user) \ud83d\udccc Throttling global sozlamalar orqali avtomatik qo'llaniladi, shuning uchun viewsetda qo'shimcha o'zgartirish talab qilinmaydi.","title":"\u2705 5. VIEWSET NI TEKSHIRISH"},{"location":"drf/throttling-and-rate-limiting/#6-maxsus-throttle-sinf-yaratish","text":"\ud83d\udccc Muayyan endpoint uchun maxsus throttling sinfini yaratamiz. myapp/throttles.py faylini yarating va quyidagi kodni qo'shing: from rest_framework.throttling import UserRateThrottle class CustomTaskThrottle(UserRateThrottle): scope = 'task-create' def get_rate(self): return '5/hour' # Vazifa yaratish uchun soatiga 5 ta so'rov \ud83d\udccc Tushuntirish : - CustomTaskThrottle : UserRateThrottle dan meros oladi va faqat vazifa yaratish (POST) so'rovlari uchun cheklov qo'yadi. - scope : Throttle sozlamalarida ishlatiladigan identifikator. \ud83d\udccc myproject/settings.py faylida yangi scope ni qo'shing: REST_FRAMEWORK = { ... 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', 'task-create': '5/hour', # Yangi scope }, } \ud83d\udccc TaskViewSet ni yangilaymiz va POST so'rovlariga maxsus throttle qo'shamiz: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .throttles import CustomTaskThrottle from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] throttle_classes = [CustomTaskThrottle] # Maxsus throttle faqat POST uchun def perform_create(self, serializer): serializer.save(owner=self.request.user)","title":"\u2705 6. MAXSUS THROTTLE SINF YARATISH"},{"location":"drf/throttling-and-rate-limiting/#7-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), ]","title":"\u2705 7. URL SOZLASH"},{"location":"drf/throttling-and-rate-limiting/#8-throttling-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> .","title":"\u2705 8. THROTTLING NI SINAB KO'RISH"},{"location":"drf/throttling-and-rate-limiting/#foydalanuvchi-va-token-yaratish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc Token oling: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user1&password=pass123\"","title":"\u2747\ufe0f Foydalanuvchi va token yaratish:"},{"location":"drf/throttling-and-rate-limiting/#throttling-sinovi-yangi-vazifa-qoshish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc 5 marta ketma-ket POST so'rov yuboring: curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user1_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Test vazifa\", \"description\": \"Test\"}' \ud83d\udccc 6-so'rovda 429 Too Many Requests xatosi qaytadi, chunki task-create scope soatiga 5 ta so'rov bilan cheklangan.","title":"\u2747\ufe0f Throttling sinovi (Yangi vazifa qo'shish):"},{"location":"drf/throttling-and-rate-limiting/#read-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc 20 marta ketma-ket GET so'rov yuboring: curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user1_token>\" \ud83d\udccc 21-so'rovda 429 Too Many Requests xatosi qaytadi, chunki user throttle soatiga 20 ta so'rov bilan cheklangan.","title":"\u2747\ufe0f Read sinovi:"},{"location":"drf/throttling-and-rate-limiting/#anonim-foydalanuvchi-sinovi","text":"\ud83d\udccc Tokensiz GET so'rov yuboring: curl http://127.0.0.1:8000/tasks/ \ud83d\udccc 10 marta ketma-ket so'rov yuborsangiz, 11-so'rovda 429 Too Many Requests xatosi qaytadi, chunki anon throttle soatiga 10 ta so'rov bilan cheklangan.","title":"\u2747\ufe0f Anonim foydalanuvchi sinovi:"},{"location":"drf/throttling-and-rate-limiting/#9-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/throttling-and-rate-limiting/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/throttling-and-rate-limiting/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/throttling-and-rate-limiting/#10-sinov-uchun-masalalar","text":"\ud83d\udccc Throttling ni sinash uchun quyidagi amallarni bajarib ko'ring: 1. user1 bilan 5 ta POST so'rov yuboring va 6-so'rovda 429 xatosini oling. 2. user1 bilan 20 ta GET so'rov yuboring va 21-so'rovda 429 xatosini oling. 3. Tokensiz 10 ta GET so'rov yuboring va 11-so'rovda 429 xatosini oling. 4. Admin panelida vazifa qo'shing va API orqali ko'ring.","title":"\u2705 10. SINOV UCHUN MASALALAR"},{"location":"drf/using-generic-api-views/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 5-DARS: GENERIC API VIEWS BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida Generic API Views yordamida CRUD (Create, Read, Update, Delete) operatsiyalarini bosqichma-bosqich amalga oshiramiz. Generic API Views kod yozishni soddalashtiradi va takrorlanadigan logikani kamaytiradi. Har bir qadam tushunarli va faqat Generic API Views ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - Ma'lumotlar bazasi migratsiyalari qo'llanilgan. - rest_framework INSTALLED_APPS ro'yxatida qo'shilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. GENERIC API VIEWS NI TUSHUNISH \ud83d\udccc DRFning Generic API Views sinflari umumiy API operatsiyalari uchun tayyor yechimlarni taqdim etadi. Ular function-based views (FBV) ga nisbatan kamroq kod yozishni talab qiladi va ModelViewSet dan farqli o'laroq, ko'proq moslashuvchanlik beradi. Asosiy generic sinflar: - ListCreateAPIView : Ro'yxatni ko'rish (GET) va yangi obyekt qo'shish (POST). - RetrieveUpdateDestroyAPIView : Bitta obyektni ko'rish (GET), yangilash (PUT/PATCH) va o'chirish (DELETE). \u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz: \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title \u2747\ufe0f Serializer tekshirish : \ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status'] read_only_fields = ['id', 'created_at'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \u2705 4. GENERIC API VIEWS YARATISH \ud83d\udccc myapp/views.py faylini yangilaymiz va Generic API Views yordamida CRUD operatsiyalarini sozlaymiz: from rest_framework import generics from .models import Task from .serializers import TaskSerializer class TaskListCreateView(generics.ListCreateAPIView): queryset = Task.objects.all() serializer_class = TaskSerializer class TaskRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView): queryset = Task.objects.all() serializer_class = TaskSerializer \ud83d\udccc Tushuntirish : - TaskListCreateView : ListCreateAPIView sinfidan foydalanadi, bu GET (ro'yxatni ko'rish) va POST (yangi vazifa qo'shish) so'rovlarini boshqaradi. - TaskRetrieveUpdateDestroyView : RetrieveUpdateDestroyAPIView sinfidan foydalanadi, bu GET (bitta vazifani ko'rish), PUT/PATCH (yangilash) va DELETE (o'chirish) so'rovlarini boshqaradi. - queryset : Qaysi ma'lumotlar bilan ishlashni belgilaydi. - serializer_class : Ma'lumotlarni seriyalash va deserialash uchun ishlatiladigan serializer. \u2705 5. URL SOZLASH \ud83d\udccc myproject/urls.py faylini yangilaymiz va Generic API Views uchun URL marshrutlarini qo'shamiz: from django.urls import path from myapp.views import TaskListCreateView, TaskRetrieveUpdateDestroyView urlpatterns = [ path('tasks/', TaskListCreateView.as_view(), name='task-list-create'), path('tasks/<int:pk>/', TaskRetrieveUpdateDestroyView.as_view(), name='task-detail'), ] \ud83d\udccc Tushuntirish : - /tasks/ manzili vazifalar ro'yxatini ko'rish va yangi vazifa qo'shish uchun. - /tasks/<pk>/ manzili bitta vazifani ko'rish, yangilash yoki o'chirish uchun. - as_view() metodi sinfni API so'rovlariga moslashtiradi. \u2705 6. GENERIC API VIEWS NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda yoki Postman kabi vositalar yordamida quyidagi manzillarni sinab ko'ring: \u2747\ufe0f Create (Yangi vazifa qo'shish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (Postman orqali): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Bu test vazifa\", \"completed\": false}' \ud83d\udccc Agar title 3 belgidan kam bo'lsa, ModelSerializer xato qaytaradi. \u2747\ufe0f Read (Ma'lumotlarni o'qish) : Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc JSON formatida barcha vazifalar, shu jumladan status maydoni ko'rinadi. Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/1/ \u2747\ufe0f Update (Ma'lumotlarni yangilash) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PUT yoki PATCH \ud83d\udccc Masalan (faqat description ni yangilash): curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Content-Type: application/json\" -d '{\"description\": \"Yangilangan tavsif\"}' \u2747\ufe0f Delete (Ma'lumotlarni o'chirish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/ \u2705 7. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : \ud83d\udccc Agar hali yaratilmagan bo'lsa: python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida quyidagi kod bo'lishi kerak: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalarni qo'shing, tahrirlang yoki o'chiring. \u2705 8. SINOV UCHUN MASALALAR \ud83d\udccc Generic API Views funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va title 3 belgidan kam bo'lsa, xato oling. 2. /tasks/ manziliga GET so'rov yuboring va status maydonini tekshiring. 3. /tasks/1/ manzilida vazifani yangilang, faqat completed ni true ga o'zgartiring. 4. /tasks/1/ manzilidan foydalanib, 1-ID li vazifani o'chiring.","title":"Using Generic API Views"},{"location":"drf/using-generic-api-views/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/using-generic-api-views/#5-dars-generic-api-views-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida Generic API Views yordamida CRUD (Create, Read, Update, Delete) operatsiyalarini bosqichma-bosqich amalga oshiramiz. Generic API Views kod yozishni soddalashtiradi va takrorlanadigan logikani kamaytiradi. Har bir qadam tushunarli va faqat Generic API Views ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz.","title":"\ud83e\udde9 5-DARS: GENERIC API VIEWS BILAN ISHLASH"},{"location":"drf/using-generic-api-views/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - Ma'lumotlar bazasi migratsiyalari qo'llanilgan. - rest_framework INSTALLED_APPS ro'yxatida qo'shilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/using-generic-api-views/#2-generic-api-views-ni-tushunish","text":"\ud83d\udccc DRFning Generic API Views sinflari umumiy API operatsiyalari uchun tayyor yechimlarni taqdim etadi. Ular function-based views (FBV) ga nisbatan kamroq kod yozishni talab qiladi va ModelViewSet dan farqli o'laroq, ko'proq moslashuvchanlik beradi. Asosiy generic sinflar: - ListCreateAPIView : Ro'yxatni ko'rish (GET) va yangi obyekt qo'shish (POST). - RetrieveUpdateDestroyAPIView : Bitta obyektni ko'rish (GET), yangilash (PUT/PATCH) va o'chirish (DELETE).","title":"\u2705 2. GENERIC API VIEWS NI TUSHUNISH"},{"location":"drf/using-generic-api-views/#3-model-va-serializerni-tekshirish","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz:","title":"\u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH"},{"location":"drf/using-generic-api-views/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/using-generic-api-views/#serializer-tekshirish","text":"\ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status'] read_only_fields = ['id', 'created_at'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value","title":"\u2747\ufe0f Serializer tekshirish:"},{"location":"drf/using-generic-api-views/#4-generic-api-views-yaratish","text":"\ud83d\udccc myapp/views.py faylini yangilaymiz va Generic API Views yordamida CRUD operatsiyalarini sozlaymiz: from rest_framework import generics from .models import Task from .serializers import TaskSerializer class TaskListCreateView(generics.ListCreateAPIView): queryset = Task.objects.all() serializer_class = TaskSerializer class TaskRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView): queryset = Task.objects.all() serializer_class = TaskSerializer \ud83d\udccc Tushuntirish : - TaskListCreateView : ListCreateAPIView sinfidan foydalanadi, bu GET (ro'yxatni ko'rish) va POST (yangi vazifa qo'shish) so'rovlarini boshqaradi. - TaskRetrieveUpdateDestroyView : RetrieveUpdateDestroyAPIView sinfidan foydalanadi, bu GET (bitta vazifani ko'rish), PUT/PATCH (yangilash) va DELETE (o'chirish) so'rovlarini boshqaradi. - queryset : Qaysi ma'lumotlar bilan ishlashni belgilaydi. - serializer_class : Ma'lumotlarni seriyalash va deserialash uchun ishlatiladigan serializer.","title":"\u2705 4. GENERIC API VIEWS YARATISH"},{"location":"drf/using-generic-api-views/#5-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylini yangilaymiz va Generic API Views uchun URL marshrutlarini qo'shamiz: from django.urls import path from myapp.views import TaskListCreateView, TaskRetrieveUpdateDestroyView urlpatterns = [ path('tasks/', TaskListCreateView.as_view(), name='task-list-create'), path('tasks/<int:pk>/', TaskRetrieveUpdateDestroyView.as_view(), name='task-detail'), ] \ud83d\udccc Tushuntirish : - /tasks/ manzili vazifalar ro'yxatini ko'rish va yangi vazifa qo'shish uchun. - /tasks/<pk>/ manzili bitta vazifani ko'rish, yangilash yoki o'chirish uchun. - as_view() metodi sinfni API so'rovlariga moslashtiradi.","title":"\u2705 5. URL SOZLASH"},{"location":"drf/using-generic-api-views/#6-generic-api-views-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda yoki Postman kabi vositalar yordamida quyidagi manzillarni sinab ko'ring:","title":"\u2705 6. GENERIC API VIEWS NI SINAB KO'RISH"},{"location":"drf/using-generic-api-views/#create-yangi-vazifa-qoshish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (Postman orqali): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Bu test vazifa\", \"completed\": false}' \ud83d\udccc Agar title 3 belgidan kam bo'lsa, ModelSerializer xato qaytaradi.","title":"\u2747\ufe0f Create (Yangi vazifa qo'shish):"},{"location":"drf/using-generic-api-views/#read-malumotlarni-oqish","text":"Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc JSON formatida barcha vazifalar, shu jumladan status maydoni ko'rinadi. Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/1/","title":"\u2747\ufe0f Read (Ma'lumotlarni o'qish):"},{"location":"drf/using-generic-api-views/#update-malumotlarni-yangilash","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PUT yoki PATCH \ud83d\udccc Masalan (faqat description ni yangilash): curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Content-Type: application/json\" -d '{\"description\": \"Yangilangan tavsif\"}'","title":"\u2747\ufe0f Update (Ma'lumotlarni yangilash):"},{"location":"drf/using-generic-api-views/#delete-malumotlarni-ochirish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/","title":"\u2747\ufe0f Delete (Ma'lumotlarni o'chirish):"},{"location":"drf/using-generic-api-views/#7-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 7. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/using-generic-api-views/#admin-foydalanuvchisini-tekshirish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa: python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/using-generic-api-views/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida quyidagi kod bo'lishi kerak: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalarni qo'shing, tahrirlang yoki o'chiring.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/using-generic-api-views/#8-sinov-uchun-masalalar","text":"\ud83d\udccc Generic API Views funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va title 3 belgidan kam bo'lsa, xato oling. 2. /tasks/ manziliga GET so'rov yuboring va status maydonini tekshiring. 3. /tasks/1/ manzilida vazifani yangilang, faqat completed ni true ga o'zgartiring. 4. /tasks/1/ manzilidan foydalanib, 1-ID li vazifani o'chiring.","title":"\u2705 8. SINOV UCHUN MASALALAR"},{"location":"drf/viewsets-and-routers/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 6-DARS: VIEWSETS VA ROUTERS BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida ViewSets va Routers dan foydalanib, API endpointlarini samarali sozlashni bosqichma-bosqich o'rganamiz. ViewSets va Routers kod yozishni soddalashtiradi va URL marshrutlarini avtomatlashtiradi. Har bir qadam tushunarli va faqat ViewSets va Routers ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - Ma'lumotlar bazasi migratsiyalari qo'llanilgan. - rest_framework INSTALLED_APPS ro'yxatida qo'shilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. VIEWSETS VA ROUTERS NI TUSHUNISH \ud83d\udccc ViewSets : DRFning ViewSets sinflari bir nechta API operatsiyalarini (masalan, CRUD) bitta sinf ichida birlashtiradi. Ular Generic API Views dan farqli o'laroq, barcha operatsiyalarni bitta sinfda boshqarish imkonini beradi. Eng keng tarqalgan ViewSet turi \u2014 ModelViewSet , u to'liq CRUD funksiyalarini qo'llab-quvvatlaydi. \ud83d\udccc Routers : DRFning Routers komponenti ViewSets uchun URL marshrutlarini avtomatik ravishda yaratadi, bu esa URL sozlamalarini soddalashtiradi. \u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz: \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title \u2747\ufe0f Serializer tekshirish : \ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status'] read_only_fields = ['id', 'created_at'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \u2705 4. VIEWSET YARATISH \ud83d\udccc myapp/views.py faylini yangilaymiz va ModelViewSet yordamida ViewSet sozlaymiz: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer \ud83d\udccc Tushuntirish : - ModelViewSet : Barcha CRUD operatsiyalarini (list, retrieve, create, update, delete) avtomatik qo'llab-quvvatlaydi. - queryset : Qaysi ma'lumotlar bilan ishlashni belgilaydi ( Task modelining barcha obyektlari). - serializer_class : Ma'lumotlarni seriyalash va deserialash uchun ishlatiladigan serializer ( TaskSerializer ). \u2705 5. ROUTER BILAN URL SOZLASH \ud83d\udccc DRFning DefaultRouter yordamida URL marshrutlarini avtomatik sozlaymiz. myproject/urls.py faylini yangilaymiz: from django.urls import path, include from rest_framework.routers import DefaultRouter from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), ] \ud83d\udccc Tushuntirish : - DefaultRouter : /tasks/ va /tasks/<pk>/ kabi marshrutlarni avtomatik yaratadi. - router.register(r'tasks', TaskViewSet) : TaskViewSet ni tasks prefiksi bilan bog'laydi. - include(router.urls) : Router tomonidan yaratilgan barcha URL larni loyihaga qo'shadi. \ud83d\udccc Router quyidagi endpointlarni yaratadi: - GET /tasks/ : Barcha vazifalarni ro'yxatlash. - POST /tasks/ : Yangi vazifa qo'shish. - GET /tasks/<pk>/ : Bitta vazifani ko'rish. - PUT/PATCH /tasks/<pk>/ : Vazifani yangilash. - DELETE /tasks/<pk>/ : Vazifani o'chirish. \u2705 6. VIEWSETS VA ROUTERS NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda yoki Postman kabi vositalar yordamida quyidagi manzillarni sinab ko'ring: \u2747\ufe0f Create (Yangi vazifa qo'shish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (Postman orqali): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Bu test vazifa\", \"completed\": false}' \ud83d\udccc Agar title 3 belgidan kam bo'lsa, TaskSerializer xato qaytaradi. \u2747\ufe0f Read (Ma'lumotlarni o'qish) : Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc JSON formatida barcha vazifalar, shu jumladan status maydoni ko'rinadi. Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/1/ \u2747\ufe0f Update (Ma'lumotlarni yangilash) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH \ud83d\udccc Masalan (faqat completed ni yangilash): curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Content-Type: application/json\" -d '{\"completed\": true}' \u2747\ufe0f Delete (Ma'lumotlarni o'chirish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/ \u2705 7. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : \ud83d\udccc Agar hali yaratilmagan bo'lsa: python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida quyidagi kod bo'lishi kerak: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalarni qo'shing, tahrirlang yoki o'chiring. \u2705 8. SINOV UCHUN MASALALAR \ud83d\udccc ViewSets va Routers funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va title 3 belgidan kam bo'lsa, xato oling. 2. /tasks/ manziliga GET so'rov yuboring va status maydonini tekshiring. 3. /tasks/1/ manzilida vazifani yangilang, faqat description ni o'zgartiring. 4. /tasks/1/ manzilidan foydalanib, 1-ID li vazifani o'chiring.","title":"ViewSets and Routers"},{"location":"drf/viewsets-and-routers/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/viewsets-and-routers/#6-dars-viewsets-va-routers-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida ViewSets va Routers dan foydalanib, API endpointlarini samarali sozlashni bosqichma-bosqich o'rganamiz. ViewSets va Routers kod yozishni soddalashtiradi va URL marshrutlarini avtomatlashtiradi. Har bir qadam tushunarli va faqat ViewSets va Routers ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz.","title":"\ud83e\udde9 6-DARS: VIEWSETS VA ROUTERS BILAN ISHLASH"},{"location":"drf/viewsets-and-routers/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - Ma'lumotlar bazasi migratsiyalari qo'llanilgan. - rest_framework INSTALLED_APPS ro'yxatida qo'shilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/viewsets-and-routers/#2-viewsets-va-routers-ni-tushunish","text":"\ud83d\udccc ViewSets : DRFning ViewSets sinflari bir nechta API operatsiyalarini (masalan, CRUD) bitta sinf ichida birlashtiradi. Ular Generic API Views dan farqli o'laroq, barcha operatsiyalarni bitta sinfda boshqarish imkonini beradi. Eng keng tarqalgan ViewSet turi \u2014 ModelViewSet , u to'liq CRUD funksiyalarini qo'llab-quvvatlaydi. \ud83d\udccc Routers : DRFning Routers komponenti ViewSets uchun URL marshrutlarini avtomatik ravishda yaratadi, bu esa URL sozlamalarini soddalashtiradi.","title":"\u2705 2. VIEWSETS VA ROUTERS NI TUSHUNISH"},{"location":"drf/viewsets-and-routers/#3-model-va-serializerni-tekshirish","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz:","title":"\u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH"},{"location":"drf/viewsets-and-routers/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/viewsets-and-routers/#serializer-tekshirish","text":"\ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status'] read_only_fields = ['id', 'created_at'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value","title":"\u2747\ufe0f Serializer tekshirish:"},{"location":"drf/viewsets-and-routers/#4-viewset-yaratish","text":"\ud83d\udccc myapp/views.py faylini yangilaymiz va ModelViewSet yordamida ViewSet sozlaymiz: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer \ud83d\udccc Tushuntirish : - ModelViewSet : Barcha CRUD operatsiyalarini (list, retrieve, create, update, delete) avtomatik qo'llab-quvvatlaydi. - queryset : Qaysi ma'lumotlar bilan ishlashni belgilaydi ( Task modelining barcha obyektlari). - serializer_class : Ma'lumotlarni seriyalash va deserialash uchun ishlatiladigan serializer ( TaskSerializer ).","title":"\u2705 4. VIEWSET YARATISH"},{"location":"drf/viewsets-and-routers/#5-router-bilan-url-sozlash","text":"\ud83d\udccc DRFning DefaultRouter yordamida URL marshrutlarini avtomatik sozlaymiz. myproject/urls.py faylini yangilaymiz: from django.urls import path, include from rest_framework.routers import DefaultRouter from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), ] \ud83d\udccc Tushuntirish : - DefaultRouter : /tasks/ va /tasks/<pk>/ kabi marshrutlarni avtomatik yaratadi. - router.register(r'tasks', TaskViewSet) : TaskViewSet ni tasks prefiksi bilan bog'laydi. - include(router.urls) : Router tomonidan yaratilgan barcha URL larni loyihaga qo'shadi. \ud83d\udccc Router quyidagi endpointlarni yaratadi: - GET /tasks/ : Barcha vazifalarni ro'yxatlash. - POST /tasks/ : Yangi vazifa qo'shish. - GET /tasks/<pk>/ : Bitta vazifani ko'rish. - PUT/PATCH /tasks/<pk>/ : Vazifani yangilash. - DELETE /tasks/<pk>/ : Vazifani o'chirish.","title":"\u2705 5. ROUTER BILAN URL SOZLASH"},{"location":"drf/viewsets-and-routers/#6-viewsets-va-routers-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda yoki Postman kabi vositalar yordamida quyidagi manzillarni sinab ko'ring:","title":"\u2705 6. VIEWSETS VA ROUTERS NI SINAB KO'RISH"},{"location":"drf/viewsets-and-routers/#create-yangi-vazifa-qoshish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (Postman orqali): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Bu test vazifa\", \"completed\": false}' \ud83d\udccc Agar title 3 belgidan kam bo'lsa, TaskSerializer xato qaytaradi.","title":"\u2747\ufe0f Create (Yangi vazifa qo'shish):"},{"location":"drf/viewsets-and-routers/#read-malumotlarni-oqish","text":"Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc JSON formatida barcha vazifalar, shu jumladan status maydoni ko'rinadi. Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : GET \ud83d\udccc Masalan: bash curl http://127.0.0.1:8000/tasks/1/","title":"\u2747\ufe0f Read (Ma'lumotlarni o'qish):"},{"location":"drf/viewsets-and-routers/#update-malumotlarni-yangilash","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH \ud83d\udccc Masalan (faqat completed ni yangilash): curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Content-Type: application/json\" -d '{\"completed\": true}'","title":"\u2747\ufe0f Update (Ma'lumotlarni yangilash):"},{"location":"drf/viewsets-and-routers/#delete-malumotlarni-ochirish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/","title":"\u2747\ufe0f Delete (Ma'lumotlarni o'chirish):"},{"location":"drf/viewsets-and-routers/#7-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 7. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/viewsets-and-routers/#admin-foydalanuvchisini-tekshirish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa: python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/viewsets-and-routers/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida quyidagi kod bo'lishi kerak: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida admin paneliga kiring va vazifalarni qo'shing, tahrirlang yoki o'chiring.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/viewsets-and-routers/#8-sinov-uchun-masalalar","text":"\ud83d\udccc ViewSets va Routers funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va title 3 belgidan kam bo'lsa, xato oling. 2. /tasks/ manziliga GET so'rov yuboring va status maydonini tekshiring. 3. /tasks/1/ manzilida vazifani yangilang, faqat description ni o'zgartiring. 4. /tasks/1/ manzilidan foydalanib, 1-ID li vazifani o'chiring.","title":"\u2705 8. SINOV UCHUN MASALALAR"},{"location":"drf/websockets-and-django-channels/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 17-DARS: WEBSOCKETS VA DJANGO CHANNELS BILAN ISHLASH Bu darsda Django REST Framework (DRF) va Django Channels yordamida WebSocket integratsiyasini sozlashni bosqichma-bosqich o'rganamiz. WebSocket real vaqtda ikki tomonlama aloqani ta'minlaydi, masalan, vazifa yaratilganda foydalanuvchilarga bildirishnoma yuborish uchun. Har bir qadam tushunarli va faqat WebSocket va Django Channels ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash, Celery va keshlash asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash, Celery va keshlash bilan). - Signallar va Celery myapp/signals.py va myapp/tasks.py fayllarida sozlangan. - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. WEBSOCKET VA DJANGO CHANNELS NI TUSHUNISH \ud83d\udccc WebSocket : HTTP dan farqli o'laroq, server va klient o'rtasida doimiy, ikki tomonlama aloqani ta'minlaydi. Bu real vaqtda ma'lumot uzatish (masalan, bildirishnomalar) uchun ideal. \ud83d\udccc Django Channels : Django da WebSocket va asinxron vazifalarni boshqarish uchun ishlatiladi. U Redis kabi xabar brokeri orqali ishlaydi. \ud83d\udccc Ushbu darsda vazifa yaratilganda barcha ulangan foydalanuvchilarga WebSocket orqali bildirishnoma yuboramiz. \u2705 3. DJANGO CHANNELS VA REDIS NI O'RNATISH \ud83d\udccc Quyidagi paketlarni o'rnatamiz: pip install channels channels-redis \ud83d\udccc Redis allaqachon Celery va keshlash uchun o'rnatilgan. Redis serveri ishlayotganligiga ishonch hosil qiling: redis-server redis-cli ping # Javob: PONG \u2705 4. LOYIHA SOZLAMALARINI YANGILASH \ud83d\udccc myproject/settings.py faylida Channels va Redis sozlamalarini qo'shamiz: INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'channels', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } # Celery sozlamalari CELERY_BROKER_URL = 'redis://localhost:6379/0' CELERY_RESULT_BACKEND = 'redis://localhost:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = True # Keshlash sozlamalari CACHES = { 'default': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://127.0.0.1:6379/1', 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', } } } # Channels sozlamalari ASGI_APPLICATION = 'myproject.asgi.application' CHANNEL_LAYERS = { 'default': { 'BACKEND': 'channels_redis.core.RedisChannelLayer', 'CONFIG': { 'hosts': [('127.0.0.1', 6379)], }, }, } \ud83d\udccc Tushuntirish : - channels ni INSTALLED_APPS ga qo'shdik. - ASGI_APPLICATION : Django Channels uchun ASGI ilovasini belgilaydi. - CHANNEL_LAYERS : Redis ni WebSocket xabarlari uchun ishlatadi. \u2705 5. ASGI SOZLASH \ud83d\udccc myproject/asgi.py faylini yangilaymiz yoki yarating: import os from django.core.asgi import get_asgi_application from channels.routing import ProtocolTypeRouter, URLRouter from channels.auth import AuthMiddlewareStack import myapp.routing os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings') application = ProtocolTypeRouter({ 'http': get_asgi_application(), 'websocket': AuthMiddlewareStack( URLRouter( myapp.routing.websocket_urlpatterns ) ), }) \ud83d\udccc Tushuntirish : - ProtocolTypeRouter : HTTP va WebSocket so'rovlarini boshqaradi. - AuthMiddlewareStack : WebSocket ulanishlarida autentifikatsiyani qo'llab-quvvatlaydi. \u2705 6. WEBSOCKET ROUTING \ud83d\udccc myapp/routing.py faylini yarating va WebSocket marshrutlarini sozlang: from django.urls import re_path from . import consumers websocket_urlpatterns = [ re_path(r'ws/tasks/$', consumers.TaskConsumer.as_asgi()), ] \ud83d\udccc Tushuntirish : - ws/tasks/ : WebSocket ulanishi uchun endpoint. - TaskConsumer : WebSocket xabarlarini boshqaradi. \u2705 7. WEBSOCKET CONSUMER YARATISH \ud83d\udccc myapp/consumers.py faylini yarating va quyidagi kodni qo'shing: from channels.generic.websocket import AsyncWebsocketConsumer import json class TaskConsumer(AsyncWebsocketConsumer): async def connect(self): await self.channel_layer.group_add('tasks', self.channel_name) await self.accept() async def disconnect(self, close_code): await self.channel_layer.group_discard('tasks', self.channel_name) async def task_notification(self, event): await self.send(text_data=json.dumps({ 'message': event['message'] })) \ud83d\udccc Tushuntirish : - connect : Foydalanuvchi WebSocket ga ulanganda tasks guruhiga qo'shiladi. - disconnect : Ulanish uzilganda guruhdan chiqariladi. - task_notification : Guruhdagi barcha foydalanuvchilarga xabar yuboradi. \u2705 8. SIGNAL ORQALI WEBSOCKET BILDIRISHNOMASI \ud83d\udccc myapp/signals.py faylini yangilaymiz va vazifa yaratilganda WebSocket orqali bildirishnoma yuboramiz: from django.db.models.signals import post_save, post_delete from django.dispatch import receiver from .models import Task from .tasks import log_task_creation from channels.layers import get_channel_layer from asgiref.sync import async_to_sync import logging logger = logging.getLogger(__name__) @receiver(post_save, sender=Task) def handle_task_creation(sender, instance, created, **kwargs): if created: # Celery vazifasini fon rejimida ishga tushirish log_task_creation.delay(instance.id, instance.title, instance.owner.username) # WebSocket orqali bildirishnoma yuborish channel_layer = get_channel_layer() async_to_sync(channel_layer.group_send)( 'tasks', { 'type': 'task_notification', 'message': f\"Yangi vazifa yaratildi: {instance.title} (Owner: {instance.owner.username})\" } ) else: logger.info(f\"Vazifa yangilandi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") @receiver(post_delete, sender=Task) def log_task_deletion(sender, instance, **kwargs): logger.info(f\"Vazifa o'chirildi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") \ud83d\udccc Tushuntirish : - group_send : tasks guruhidagi barcha ulangan foydalanuvchilarga xabar yuboradi. - async_to_sync : Asinxron Channels funksiyasini sinxron signalda ishlatish uchun. \u2705 9. KLIENT-SAYT WEBSOCKET INTEGRATSIYASI \ud83d\udccc WebSocket ni sinash uchun oddiy HTML sahifasi yarating. myapp/templates/index.html faylini yarating: <!DOCTYPE html> <html> <head> <title>WebSocket Test</title> </head> <body> <h1>WebSocket Bildirishnomalari</h1> <div id=\"notifications\"></div> <script> const socket = new WebSocket('ws://localhost:8000/ws/tasks/'); socket.onmessage = function(event) { const data = JSON.parse(event.data); const notifications = document.getElementById('notifications'); const p = document.createElement('p'); p.textContent = data.message; notifications.appendChild(p); }; socket.onopen = function(event) { console.log('WebSocket ulandi'); }; socket.onclose = function(event) { console.log('WebSocket uzildi'); }; </script> </body> </html> \ud83d\udccc myapp/urls.py faylini yarating va HTML sahifasi uchun URL qo'shing: from django.urls import path from django.views.generic import TemplateView urlpatterns = [ path('', TemplateView.as_view(template_name='index.html'), name='index'), ] \ud83d\udccc myproject/urls.py faylini yangilang: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), path('ws/', include('myapp.urls')), # WebSocket sahifasi uchun ] \u2705 10. WEBSOCKET NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring (Django Channels Daphne bilan ishlaydi): pip install daphne daphne -b 0.0.0.0 -p 8000 myproject.asgi:application \ud83d\udccc Redis serveri ishlayotganligiga ishonch hosil qiling: redis-server \ud83d\udccc Celery worker ni ishga tushiring (ixtiyoriy): celery -A myproject worker --loglevel=info \u2747\ufe0f Foydalanuvchi va token yaratish : \ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: testuser, password: testpass123 \ud83d\udccc JWT token oling: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"testuser\", \"password\": \"testpass123\"}' \u2747\ufe0f WebSocket sinovi : Brauzerda http://localhost:8000/ws/ manzilini oching. Yangi vazifa qo'shing: bash curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test\"}' Brauzerda bildirishnoma paydo bo'ladi: Yangi vazifa yaratildi: Yangi vazifa (Owner: testuser) . \u2705 11. TESTLARNI YANGILASH \ud83d\udccc WebSocket ni sinash uchun myapp/tests.py fayliga test qo'shamiz: from django.test import TestCase from rest_framework.test import APITestCase from rest_framework import status from django.urls import reverse from django.contrib.auth.models import User from rest_framework_simplejwt.tokens import RefreshToken from .models import Task from .serializers import TaskSerializer from django.core.cache import cache from channels.testing import WebsocketCommunicator from myapp.consumers import TaskConsumer import logging logger = logging.getLogger(__name__) # Oldingi testlar (TaskModelTest, TaskSerializerTest, TaskSignalTest, TaskAPITest) shu yerda qoladi class TaskWebSocketTest(TestCase): async def test_task_notification(self): communicator = WebsocketCommunicator(TaskConsumer.as_asgi(), \"/ws/tasks/\") connected, subprotocol = await communicator.connect() self.assertTrue(connected) # Foydalanuvchi va vazifa yaratish user = User.objects.create_user(username='testuser', password='testpass123') task = Task.objects.create(title='Test vazifa', owner=user) # Bildirishnoma olish response = await communicator.receive_from() data = json.loads(response) self.assertEqual(data['message'], f\"Yangi vazifa yaratildi: Test vazifa (Owner: testuser)\") await communicator.disconnect() \ud83d\udccc Testlarni ishga tushirish: python manage.py test \u2705 12. SINOV UCHUN MASALALAR \ud83d\udccc WebSocket ni sinash uchun quyidagi amallarni bajarib ko'ring: 1. http://localhost:8000/ws/ manzilida WebSocket sahifasini oching. 2. /tasks/ manzilida yangi vazifa qo'shing va brauzerda bildirishnoma oling. 3. Bir nechta brauzer oynasini ochib, guruh bildirishnomasini sinab ko'ring. 4. python manage.py test bilan WebSocket testini sinab ko'ring.","title":"WebSockets and Django Channels"},{"location":"drf/websockets-and-django-channels/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/websockets-and-django-channels/#17-dars-websockets-va-django-channels-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) va Django Channels yordamida WebSocket integratsiyasini sozlashni bosqichma-bosqich o'rganamiz. WebSocket real vaqtda ikki tomonlama aloqani ta'minlaydi, masalan, vazifa yaratilganda foydalanuvchilarga bildirishnoma yuborish uchun. Har bir qadam tushunarli va faqat WebSocket va Django Channels ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, JWT autentifikatsiyasi, ruxsatlar, sahifalash, Celery va keshlash asosida davom etamiz.","title":"\ud83e\udde9 17-DARS: WEBSOCKETS VA DJANGO CHANNELS BILAN ISHLASH"},{"location":"drf/websockets-and-django-channels/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (JWT autentifikatsiyasi, ruxsatlar, filtrlash, sahifalash, Celery va keshlash bilan). - Signallar va Celery myapp/signals.py va myapp/tasks.py fayllarida sozlangan. - /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/websockets-and-django-channels/#2-websocket-va-django-channels-ni-tushunish","text":"\ud83d\udccc WebSocket : HTTP dan farqli o'laroq, server va klient o'rtasida doimiy, ikki tomonlama aloqani ta'minlaydi. Bu real vaqtda ma'lumot uzatish (masalan, bildirishnomalar) uchun ideal. \ud83d\udccc Django Channels : Django da WebSocket va asinxron vazifalarni boshqarish uchun ishlatiladi. U Redis kabi xabar brokeri orqali ishlaydi. \ud83d\udccc Ushbu darsda vazifa yaratilganda barcha ulangan foydalanuvchilarga WebSocket orqali bildirishnoma yuboramiz.","title":"\u2705 2. WEBSOCKET VA DJANGO CHANNELS NI TUSHUNISH"},{"location":"drf/websockets-and-django-channels/#3-django-channels-va-redis-ni-ornatish","text":"\ud83d\udccc Quyidagi paketlarni o'rnatamiz: pip install channels channels-redis \ud83d\udccc Redis allaqachon Celery va keshlash uchun o'rnatilgan. Redis serveri ishlayotganligiga ishonch hosil qiling: redis-server redis-cli ping # Javob: PONG","title":"\u2705 3. DJANGO CHANNELS VA REDIS NI O'RNATISH"},{"location":"drf/websockets-and-django-channels/#4-loyiha-sozlamalarini-yangilash","text":"\ud83d\udccc myproject/settings.py faylida Channels va Redis sozlamalarini qo'shamiz: INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'rest_framework.authtoken', 'django_filters', 'channels', 'myapp.apps.MyappConfig', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework_simplejwt.authentication.JWTAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, } # Celery sozlamalari CELERY_BROKER_URL = 'redis://localhost:6379/0' CELERY_RESULT_BACKEND = 'redis://localhost:6379/0' CELERY_ACCEPT_CONTENT = ['json'] CELERY_TASK_SERIALIZER = 'json' CELERY_RESULT_SERIALIZER = 'json' CELERY_TIMEZONE = 'Asia/Tashkent' CELERY_TASK_ALWAYS_EAGER = True # Keshlash sozlamalari CACHES = { 'default': { 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://127.0.0.1:6379/1', 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', } } } # Channels sozlamalari ASGI_APPLICATION = 'myproject.asgi.application' CHANNEL_LAYERS = { 'default': { 'BACKEND': 'channels_redis.core.RedisChannelLayer', 'CONFIG': { 'hosts': [('127.0.0.1', 6379)], }, }, } \ud83d\udccc Tushuntirish : - channels ni INSTALLED_APPS ga qo'shdik. - ASGI_APPLICATION : Django Channels uchun ASGI ilovasini belgilaydi. - CHANNEL_LAYERS : Redis ni WebSocket xabarlari uchun ishlatadi.","title":"\u2705 4. LOYIHA SOZLAMALARINI YANGILASH"},{"location":"drf/websockets-and-django-channels/#5-asgi-sozlash","text":"\ud83d\udccc myproject/asgi.py faylini yangilaymiz yoki yarating: import os from django.core.asgi import get_asgi_application from channels.routing import ProtocolTypeRouter, URLRouter from channels.auth import AuthMiddlewareStack import myapp.routing os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings') application = ProtocolTypeRouter({ 'http': get_asgi_application(), 'websocket': AuthMiddlewareStack( URLRouter( myapp.routing.websocket_urlpatterns ) ), }) \ud83d\udccc Tushuntirish : - ProtocolTypeRouter : HTTP va WebSocket so'rovlarini boshqaradi. - AuthMiddlewareStack : WebSocket ulanishlarida autentifikatsiyani qo'llab-quvvatlaydi.","title":"\u2705 5. ASGI SOZLASH"},{"location":"drf/websockets-and-django-channels/#6-websocket-routing","text":"\ud83d\udccc myapp/routing.py faylini yarating va WebSocket marshrutlarini sozlang: from django.urls import re_path from . import consumers websocket_urlpatterns = [ re_path(r'ws/tasks/$', consumers.TaskConsumer.as_asgi()), ] \ud83d\udccc Tushuntirish : - ws/tasks/ : WebSocket ulanishi uchun endpoint. - TaskConsumer : WebSocket xabarlarini boshqaradi.","title":"\u2705 6. WEBSOCKET ROUTING"},{"location":"drf/websockets-and-django-channels/#7-websocket-consumer-yaratish","text":"\ud83d\udccc myapp/consumers.py faylini yarating va quyidagi kodni qo'shing: from channels.generic.websocket import AsyncWebsocketConsumer import json class TaskConsumer(AsyncWebsocketConsumer): async def connect(self): await self.channel_layer.group_add('tasks', self.channel_name) await self.accept() async def disconnect(self, close_code): await self.channel_layer.group_discard('tasks', self.channel_name) async def task_notification(self, event): await self.send(text_data=json.dumps({ 'message': event['message'] })) \ud83d\udccc Tushuntirish : - connect : Foydalanuvchi WebSocket ga ulanganda tasks guruhiga qo'shiladi. - disconnect : Ulanish uzilganda guruhdan chiqariladi. - task_notification : Guruhdagi barcha foydalanuvchilarga xabar yuboradi.","title":"\u2705 7. WEBSOCKET CONSUMER YARATISH"},{"location":"drf/websockets-and-django-channels/#8-signal-orqali-websocket-bildirishnomasi","text":"\ud83d\udccc myapp/signals.py faylini yangilaymiz va vazifa yaratilganda WebSocket orqali bildirishnoma yuboramiz: from django.db.models.signals import post_save, post_delete from django.dispatch import receiver from .models import Task from .tasks import log_task_creation from channels.layers import get_channel_layer from asgiref.sync import async_to_sync import logging logger = logging.getLogger(__name__) @receiver(post_save, sender=Task) def handle_task_creation(sender, instance, created, **kwargs): if created: # Celery vazifasini fon rejimida ishga tushirish log_task_creation.delay(instance.id, instance.title, instance.owner.username) # WebSocket orqali bildirishnoma yuborish channel_layer = get_channel_layer() async_to_sync(channel_layer.group_send)( 'tasks', { 'type': 'task_notification', 'message': f\"Yangi vazifa yaratildi: {instance.title} (Owner: {instance.owner.username})\" } ) else: logger.info(f\"Vazifa yangilandi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") @receiver(post_delete, sender=Task) def log_task_deletion(sender, instance, **kwargs): logger.info(f\"Vazifa o'chirildi: {instance.title} (ID: {instance.id}, Owner: {instance.owner.username})\") \ud83d\udccc Tushuntirish : - group_send : tasks guruhidagi barcha ulangan foydalanuvchilarga xabar yuboradi. - async_to_sync : Asinxron Channels funksiyasini sinxron signalda ishlatish uchun.","title":"\u2705 8. SIGNAL ORQALI WEBSOCKET BILDIRISHNOMASI"},{"location":"drf/websockets-and-django-channels/#9-klient-sayt-websocket-integratsiyasi","text":"\ud83d\udccc WebSocket ni sinash uchun oddiy HTML sahifasi yarating. myapp/templates/index.html faylini yarating: <!DOCTYPE html> <html> <head> <title>WebSocket Test</title> </head> <body> <h1>WebSocket Bildirishnomalari</h1> <div id=\"notifications\"></div> <script> const socket = new WebSocket('ws://localhost:8000/ws/tasks/'); socket.onmessage = function(event) { const data = JSON.parse(event.data); const notifications = document.getElementById('notifications'); const p = document.createElement('p'); p.textContent = data.message; notifications.appendChild(p); }; socket.onopen = function(event) { console.log('WebSocket ulandi'); }; socket.onclose = function(event) { console.log('WebSocket uzildi'); }; </script> </body> </html> \ud83d\udccc myapp/urls.py faylini yarating va HTML sahifasi uchun URL qo'shing: from django.urls import path from django.views.generic import TemplateView urlpatterns = [ path('', TemplateView.as_view(template_name='index.html'), name='index'), ] \ud83d\udccc myproject/urls.py faylini yangilang: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'), path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'), path('ws/', include('myapp.urls')), # WebSocket sahifasi uchun ]","title":"\u2705 9. KLIENT-SAYT WEBSOCKET INTEGRATSIYASI"},{"location":"drf/websockets-and-django-channels/#10-websocket-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring (Django Channels Daphne bilan ishlaydi): pip install daphne daphne -b 0.0.0.0 -p 8000 myproject.asgi:application \ud83d\udccc Redis serveri ishlayotganligiga ishonch hosil qiling: redis-server \ud83d\udccc Celery worker ni ishga tushiring (ixtiyoriy): celery -A myproject worker --loglevel=info","title":"\u2705 10. WEBSOCKET NI SINAB KO'RISH"},{"location":"drf/websockets-and-django-channels/#foydalanuvchi-va-token-yaratish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: testuser, password: testpass123 \ud83d\udccc JWT token oling: curl -X POST http://127.0.0.1:8000/api/token/ -H \"Content-Type: application/json\" -d '{\"username\": \"testuser\", \"password\": \"testpass123\"}'","title":"\u2747\ufe0f Foydalanuvchi va token yaratish:"},{"location":"drf/websockets-and-django-channels/#websocket-sinovi","text":"Brauzerda http://localhost:8000/ws/ manzilini oching. Yangi vazifa qo'shing: bash curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Bearer <access_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Test\"}' Brauzerda bildirishnoma paydo bo'ladi: Yangi vazifa yaratildi: Yangi vazifa (Owner: testuser) .","title":"\u2747\ufe0f WebSocket sinovi:"},{"location":"drf/websockets-and-django-channels/#11-testlarni-yangilash","text":"\ud83d\udccc WebSocket ni sinash uchun myapp/tests.py fayliga test qo'shamiz: from django.test import TestCase from rest_framework.test import APITestCase from rest_framework import status from django.urls import reverse from django.contrib.auth.models import User from rest_framework_simplejwt.tokens import RefreshToken from .models import Task from .serializers import TaskSerializer from django.core.cache import cache from channels.testing import WebsocketCommunicator from myapp.consumers import TaskConsumer import logging logger = logging.getLogger(__name__) # Oldingi testlar (TaskModelTest, TaskSerializerTest, TaskSignalTest, TaskAPITest) shu yerda qoladi class TaskWebSocketTest(TestCase): async def test_task_notification(self): communicator = WebsocketCommunicator(TaskConsumer.as_asgi(), \"/ws/tasks/\") connected, subprotocol = await communicator.connect() self.assertTrue(connected) # Foydalanuvchi va vazifa yaratish user = User.objects.create_user(username='testuser', password='testpass123') task = Task.objects.create(title='Test vazifa', owner=user) # Bildirishnoma olish response = await communicator.receive_from() data = json.loads(response) self.assertEqual(data['message'], f\"Yangi vazifa yaratildi: Test vazifa (Owner: testuser)\") await communicator.disconnect() \ud83d\udccc Testlarni ishga tushirish: python manage.py test","title":"\u2705 11. TESTLARNI YANGILASH"},{"location":"drf/websockets-and-django-channels/#12-sinov-uchun-masalalar","text":"\ud83d\udccc WebSocket ni sinash uchun quyidagi amallarni bajarib ko'ring: 1. http://localhost:8000/ws/ manzilida WebSocket sahifasini oching. 2. /tasks/ manzilida yangi vazifa qo'shing va brauzerda bildirishnoma oling. 3. Bir nechta brauzer oynasini ochib, guruh bildirishnomasini sinab ko'ring. 4. python manage.py test bilan WebSocket testini sinab ko'ring.","title":"\u2705 12. SINOV UCHUN MASALALAR"},{"location":"drf/working-with-modelserializer/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 4-DARS: MODELSERIALIZER BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida ModelSerializer sinfidan foydalanib, ma'lumotlarni seriyalash va deserialash jarayonlarini bosqichma-bosqich o'rganamiz. Har bir qadam tushunarli va faqat ModelSerializer ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - Ma'lumotlar bazasi migratsiyalari qo'llanilgan. - rest_framework INSTALLED_APPS ro'yxatida qo'shilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. MODELSERIALIZER NI TUSHUNISH \ud83d\udccc ModelSerializer DRFning asosiy komponentlaridan biri bo'lib, Django modellarini JSON formatiga aylantirish (seriyalash) va JSON dan model obyektlariga aylantirish (deserialash) jarayonlarini soddalashtiradi. U quyidagi afzalliklarni beradi: - Model maydonlarini avtomatik aniqlaydi. - Validatsiya qoidalarini modelga asoslangan holda yaratadi. - CRUD operatsiyalari uchun tayyor metodlarni taqdim etadi. \u2705 3. MODEL VA SERIALIZER SOZLASH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz va ModelSerializer ni kengaytiramiz. \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title \ud83d\udccc Yangilik sifatida description maydonini qo'shdik, bu ixtiyoriy maydon ( blank=True, null=True ). \u2747\ufe0f ModelSerializer yaratish : \ud83d\udccc myapp/serializers.py faylini yangilaymiz va ModelSerializer ni kengaytirib, qo'shimcha validatsiya va maydonlarni sozlaymiz: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at'] read_only_fields = ['id', 'created_at'] def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \ud83d\udccc Tushuntirish : - fields : API orqali ko'rsatiladigan maydonlar ro'yxati. - read_only_fields : Faqat o'qish uchun maydonlar (masalan, id va created_at foydalanuvchi tomonidan o'zgartirilmaydi). - validate_title : Sarlavha uzunligini tekshiruvchi maxsus validatsiya qoidasi. \u2705 4. FUNCTION-BASED VIEWS BILAN MODELSERIALIZER ISHLATISH \ud83d\udccc Oldingi darsda function-based views (FBV) yordamida CRUD operatsiyalarini sozlagan edik. ModelSerializer dan foydalanish uchun myapp/views.py faylini qayta ko'rib chiqamiz: from rest_framework.decorators import api_view from rest_framework.response import Response from rest_framework import status from .models import Task from .serializers import TaskSerializer @api_view(['GET', 'POST']) def task_list(request): if request.method == 'GET': tasks = Task.objects.all() serializer = TaskSerializer(tasks, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = TaskSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) @api_view(['GET', 'PUT', 'DELETE']) def task_detail(request, pk): try: task = Task.objects.get(pk=pk) except Task.DoesNotExist: return Response(status=status.HTTP_404_NOT_FOUND) if request.method == 'GET': serializer = TaskSerializer(task) return Response(serializer.data) elif request.method == 'PUT': serializer = TaskSerializer(task, data=request.data, partial=True) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == 'DELETE': task.delete() return Response(status=status.HTTP_204_NO_CONTENT) \ud83d\udccc Tushuntirish : - TaskSerializer barcha CRUD operatsiyalarida ishlatiladi. - partial=True (PUT so'rovida) qisman yangilash imkonini beradi, ya'ni faqat o'zgartirilgan maydonlar yangilanadi. - serializer.is_valid() ModelSerializer ning validatsiya qoidalarini (masalan, validate_title ) tekshiradi. \u2705 5. URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path from myapp.views import task_list, task_detail urlpatterns = [ path('tasks/', task_list, name='task-list'), path('tasks/<int:pk>/', task_detail, name='task-detail'), ] \u2705 6. MODELSERIALIZER NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda yoki Postman kabi vositalar yordamida quyidagi manzillarni sinab ko'ring: \u2747\ufe0f Create (Yangi vazifa qo'shish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan : curl -X POST http://127.0.0.1:8000/tasks/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Bu test vazifa\", \"completed\": false}' \ud83d\udccc Agar title 3 belgidan kam bo'lsa, ModelSerializer xato qaytaradi. \u2747\ufe0f Read (Ma'lumotlarni o'qish) : Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : GET \u2747\ufe0f Update (Ma'lumotlarni yangilash) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PUT \ud83d\udccc Masalan (faqat description ni yangilash): curl -X PUT http://127.0.0.1:8000/tasks/1/ -H \"Content-Type: application/json\" -d '{\"description\": \"Yangilangan tavsif\"}' \u2747\ufe0f Delete (Ma'lumotlarni o'chirish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/ \u2705 7. MODELSERIALIZER NI KENGAYTIRISH \ud83d\udccc ModelSerializer ni yanada moslashtirish uchun qo'shimcha funksiyalar qo'shamiz. myapp/serializers.py faylini yangilaymiz: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status'] read_only_fields = ['id', 'created_at'] status = serializers.SerializerMethodField() def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \ud83d\udccc Tushuntirish : - status : SerializerMethodField yordamida completed maydoniga asoslangan virtual maydon qo'shildi. - get_status : completed holatiga qarab \"Bajarilgan\" yoki \"Bajarilmagan\" qaytaradi. \ud83d\udccc Yangi serializer ni sinash uchun /tasks/ manziliga GET so'rov yuboring. Har bir vazifada status maydoni paydo bo'ladi. \u2705 8. SINOV UCHUN MASALALAR \ud83d\udccc ModelSerializer funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va title 3 belgidan kam bo'lsa, xato oling. 2. /tasks/1/ manzilida vazifani yangilang, faqat description ni o'zgartiring. 3. /tasks/ manziliga GET so'rov yuboring va status maydonini tekshiring. 4. Admin panelida bir nechta vazifa qo'shing va API orqali ularni ko'ring. \u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang.","title":"Working with ModelSerializer"},{"location":"drf/working-with-modelserializer/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/working-with-modelserializer/#4-dars-modelserializer-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida ModelSerializer sinfidan foydalanib, ma'lumotlarni seriyalash va deserialash jarayonlarini bosqichma-bosqich o'rganamiz. Har bir qadam tushunarli va faqat ModelSerializer ga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli asosida davom etamiz.","title":"\ud83e\udde9 4-DARS: MODELSERIALIZER BILAN ISHLASH"},{"location":"drf/working-with-modelserializer/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - Ma'lumotlar bazasi migratsiyalari qo'llanilgan. - rest_framework INSTALLED_APPS ro'yxatida qo'shilgan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/working-with-modelserializer/#2-modelserializer-ni-tushunish","text":"\ud83d\udccc ModelSerializer DRFning asosiy komponentlaridan biri bo'lib, Django modellarini JSON formatiga aylantirish (seriyalash) va JSON dan model obyektlariga aylantirish (deserialash) jarayonlarini soddalashtiradi. U quyidagi afzalliklarni beradi: - Model maydonlarini avtomatik aniqlaydi. - Validatsiya qoidalarini modelga asoslangan holda yaratadi. - CRUD operatsiyalari uchun tayyor metodlarni taqdim etadi.","title":"\u2705 2. MODELSERIALIZER NI TUSHUNISH"},{"location":"drf/working-with-modelserializer/#3-model-va-serializer-sozlash","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz va ModelSerializer ni kengaytiramiz.","title":"\u2705 3. MODEL VA SERIALIZER SOZLASH"},{"location":"drf/working-with-modelserializer/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) def __str__(self): return self.title \ud83d\udccc Yangilik sifatida description maydonini qo'shdik, bu ixtiyoriy maydon ( blank=True, null=True ).","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/working-with-modelserializer/#modelserializer-yaratish","text":"\ud83d\udccc myapp/serializers.py faylini yangilaymiz va ModelSerializer ni kengaytirib, qo'shimcha validatsiya va maydonlarni sozlaymiz: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at'] read_only_fields = ['id', 'created_at'] def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \ud83d\udccc Tushuntirish : - fields : API orqali ko'rsatiladigan maydonlar ro'yxati. - read_only_fields : Faqat o'qish uchun maydonlar (masalan, id va created_at foydalanuvchi tomonidan o'zgartirilmaydi). - validate_title : Sarlavha uzunligini tekshiruvchi maxsus validatsiya qoidasi.","title":"\u2747\ufe0f ModelSerializer yaratish:"},{"location":"drf/working-with-modelserializer/#4-function-based-views-bilan-modelserializer-ishlatish","text":"\ud83d\udccc Oldingi darsda function-based views (FBV) yordamida CRUD operatsiyalarini sozlagan edik. ModelSerializer dan foydalanish uchun myapp/views.py faylini qayta ko'rib chiqamiz: from rest_framework.decorators import api_view from rest_framework.response import Response from rest_framework import status from .models import Task from .serializers import TaskSerializer @api_view(['GET', 'POST']) def task_list(request): if request.method == 'GET': tasks = Task.objects.all() serializer = TaskSerializer(tasks, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = TaskSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) @api_view(['GET', 'PUT', 'DELETE']) def task_detail(request, pk): try: task = Task.objects.get(pk=pk) except Task.DoesNotExist: return Response(status=status.HTTP_404_NOT_FOUND) if request.method == 'GET': serializer = TaskSerializer(task) return Response(serializer.data) elif request.method == 'PUT': serializer = TaskSerializer(task, data=request.data, partial=True) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == 'DELETE': task.delete() return Response(status=status.HTTP_204_NO_CONTENT) \ud83d\udccc Tushuntirish : - TaskSerializer barcha CRUD operatsiyalarida ishlatiladi. - partial=True (PUT so'rovida) qisman yangilash imkonini beradi, ya'ni faqat o'zgartirilgan maydonlar yangilanadi. - serializer.is_valid() ModelSerializer ning validatsiya qoidalarini (masalan, validate_title ) tekshiradi.","title":"\u2705 4. FUNCTION-BASED VIEWS BILAN MODELSERIALIZER ISHLATISH"},{"location":"drf/working-with-modelserializer/#5-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path from myapp.views import task_list, task_detail urlpatterns = [ path('tasks/', task_list, name='task-list'), path('tasks/<int:pk>/', task_detail, name='task-detail'), ]","title":"\u2705 5. URL SOZLASH"},{"location":"drf/working-with-modelserializer/#6-modelserializer-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc Brauzerda yoki Postman kabi vositalar yordamida quyidagi manzillarni sinab ko'ring:","title":"\u2705 6. MODELSERIALIZER NI SINAB KO'RISH"},{"location":"drf/working-with-modelserializer/#create-yangi-vazifa-qoshish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan : curl -X POST http://127.0.0.1:8000/tasks/ -H \"Content-Type: application/json\" -d '{\"title\": \"Yangi vazifa\", \"description\": \"Bu test vazifa\", \"completed\": false}' \ud83d\udccc Agar title 3 belgidan kam bo'lsa, ModelSerializer xato qaytaradi.","title":"\u2747\ufe0f Create (Yangi vazifa qo'shish):"},{"location":"drf/working-with-modelserializer/#read-malumotlarni-oqish","text":"Barcha vazifalarni ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET Bitta vazifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : GET","title":"\u2747\ufe0f Read (Ma'lumotlarni o'qish):"},{"location":"drf/working-with-modelserializer/#update-malumotlarni-yangilash","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PUT \ud83d\udccc Masalan (faqat description ni yangilash): curl -X PUT http://127.0.0.1:8000/tasks/1/ -H \"Content-Type: application/json\" -d '{\"description\": \"Yangilangan tavsif\"}'","title":"\u2747\ufe0f Update (Ma'lumotlarni yangilash):"},{"location":"drf/working-with-modelserializer/#delete-malumotlarni-ochirish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Masalan : curl -X DELETE http://127.0.0.1:8000/tasks/1/","title":"\u2747\ufe0f Delete (Ma'lumotlarni o'chirish):"},{"location":"drf/working-with-modelserializer/#7-modelserializer-ni-kengaytirish","text":"\ud83d\udccc ModelSerializer ni yanada moslashtirish uchun qo'shimcha funksiyalar qo'shamiz. myapp/serializers.py faylini yangilaymiz: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status'] read_only_fields = ['id', 'created_at'] status = serializers.SerializerMethodField() def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \ud83d\udccc Tushuntirish : - status : SerializerMethodField yordamida completed maydoniga asoslangan virtual maydon qo'shildi. - get_status : completed holatiga qarab \"Bajarilgan\" yoki \"Bajarilmagan\" qaytaradi. \ud83d\udccc Yangi serializer ni sinash uchun /tasks/ manziliga GET so'rov yuboring. Har bir vazifada status maydoni paydo bo'ladi.","title":"\u2705 7. MODELSERIALIZER NI KENGAYTIRISH"},{"location":"drf/working-with-modelserializer/#8-sinov-uchun-masalalar","text":"\ud83d\udccc ModelSerializer funksionalligini sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida yangi vazifa qo'shing va title 3 belgidan kam bo'lsa, xato oling. 2. /tasks/1/ manzilida vazifani yangilang, faqat description ni o'zgartiring. 3. /tasks/ manziliga GET so'rov yuboring va status maydonini tekshiring. 4. Admin panelida bir nechta vazifa qo'shing va API orqali ularni ko'ring.","title":"\u2705 8. SINOV UCHUN MASALALAR"},{"location":"drf/working-with-modelserializer/#9-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/working-with-modelserializer/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/working-with-modelserializer/#modelni-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang.","title":"\u2747\ufe0f Modelni ro'yxatdan o'tkazish:"},{"location":"drf/working-with-pagination/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 11-DARS: SAHIFALASH BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida sahifalash (pagination) ni sozlashni bosqichma-bosqich o'rganamiz. Sahifalash katta hajmdagi ma'lumotlarni kichik qismlarga bo'lib, API javoblarini optimallashtiradi va foydalanuvchi tajribasini yaxshilaydi. Har bir qadam tushunarli va faqat sahifalashga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, token autentifikatsiyasi, ruxsatlar va filtrlash asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (autentifikatsiya, ruxsatlar va filtrlash bilan). - Token autentifikatsiyasi va /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. SAHIFALASH NI TUSHUNISH \ud83d\udccc Sahifalash (pagination) API javoblarida ma'lumotlarni kichik qismlarga bo'lib, har bir sahifada cheklangan miqdordagi ma'lumotni qaytaradi. Bu server yukini kamaytiradi va foydalanuvchiga ma'lumotlarni boshqarishni osonlashtiradi. \ud83d\udccc DRFning o'rnatilgan sahifalash sinflari: - PageNumberPagination : Sahifa raqami asosida sahifalash (masalan, ?page=2). - LimitOffsetPagination : Belgilangan miqdor va ofset asosida sahifalash. - CursorPagination : Kursor asosida sahifalash, katta ma'lumotlar uchun samarali. \u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz: \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title \u2747\ufe0f Serializer tekshirish : \ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \u2705 4. SAHIFALASH SOZLAMALARINI QO'SHISH \ud83d\udccc DRFning PageNumberPagination sinfidan foydalanamiz. myproject/settings.py faylini yangilaymiz: REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, # Har bir sahifada 5 ta vazifa } \ud83d\udccc Tushuntirish : - DEFAULT_PAGINATION_CLASS : Standart sahifalash sinfi sifatida PageNumberPagination ni belgilaydi. - PAGE_SIZE : Har bir sahifada ko'rsatiladigan ma'lumotlar soni (5 ta vazifa). \u2705 5. MAXSUS SAHIFALASH SINF YARATISH \ud83d\udccc Maxsus sahifalash sinfini yaratib, sahifalash javobini moslashtiramiz. myapp/pagination.py faylini yarating va quyidagi kodni qo'shing: from rest_framework.pagination import PageNumberPagination from rest_framework.response import Response class CustomTaskPagination(PageNumberPagination): page_size = 3 # Har bir sahifada 3 ta vazifa page_size_query_param = 'page_size' # Foydalanuvchi sahifa hajmini o'zgartirishi mumkin max_page_size = 100 # Maksimal sahifa hajmi def get_paginated_response(self, data): return Response({ 'count': self.page.paginator.count, 'next': self.get_next_link(), 'previous': self.get_previous_link(), 'results': data }) \ud83d\udccc Tushuntirish : - page_size : Har bir sahifada 3 ta vazifa ko'rsatiladi. - page_size_query_param : Foydalanuvchi ?page_size=10 kabi parametr yordamida sahifa hajmini o'zgartirishi mumkin. - max_page_size : Sahifa hajmi 100 dan oshmaydi. - get_paginated_response : Sahifalash javobini moslashtiradi (count, next, previous, results). \u2705 6. VIEWSET NI SAHIFALASH BILAN YANGILASH \ud83d\udccc myapp/views.py faylida TaskViewSet ni yangilaymiz va maxsus sahifalash sinfini qo'shamiz: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination # Maxsus sahifalash sinfi def perform_create(self, serializer): serializer.save(owner=self.request.user) \u2705 7. URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), ] \u2705 8. SAHIFALASH NI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> . \u2747\ufe0f Foydalanuvchi va token yaratish : \ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc Token oling: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user1&password=pass123\" \u2747\ufe0f Standart sahifalash sinovi : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc Har bir sahifada 3 ta vazifa ko'rinadi: curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user1_token>\" \ud83d\udccc Javob quyidagicha bo'ladi: { \"count\": 10, \"next\": \"http://127.0.0.1:8000/tasks/?page=2\", \"previous\": null, \"results\": [ {...}, {...}, {...} // 3 ta vazifa ] } \u2747\ufe0f Muayyan sahifani ko'rish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?page=2 \ud83d\udccc Usul : GET curl http://127.0.0.1:8000/tasks/?page=2 -H \"Authorization: Token <user1_token>\" \u2747\ufe0f Sahifa hajmini o'zgartirish : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?page_size=5 \ud83d\udccc Usul : GET \ud83d\udccc Har bir sahifada 5 ta vazifa ko'rinadi: curl http://127.0.0.1:8000/tasks/?page_size=5 -H \"Authorization: Token <user1_token>\" \u2747\ufe0f Filtrlash bilan birgalikda sahifalash : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?completed=true&page=1 \ud83d\udccc Usul : GET curl http://127.0.0.1:8000/tasks/?completed=true&page=1 -H \"Authorization: Token <user1_token>\" \u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang. \u2705 10. SINOV UCHUN MASALALAR \ud83d\udccc Sahifalashni sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida birinchi sahifani oling va 3 ta vazifa ekanligini tekshiring. 2. /tasks/?page=2 manzilidan ikkinchi sahifani oling. 3. /tasks/?page_size=5 manzilida sahifa hajmini 5 ga o'zgartiring. 4. /tasks/?completed=true&page_size=2 manzilida faqat bajarilgan vazifalarni sahifalab ko'ring.","title":"Working with Pagination"},{"location":"drf/working-with-pagination/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/working-with-pagination/#11-dars-sahifalash-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida sahifalash (pagination) ni sozlashni bosqichma-bosqich o'rganamiz. Sahifalash katta hajmdagi ma'lumotlarni kichik qismlarga bo'lib, API javoblarini optimallashtiradi va foydalanuvchi tajribasini yaxshilaydi. Har bir qadam tushunarli va faqat sahifalashga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli, token autentifikatsiyasi, ruxsatlar va filtrlash asosida davom etamiz.","title":"\ud83e\udde9 11-DARS: SAHIFALASH BILAN ISHLASH"},{"location":"drf/working-with-pagination/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan (shu jumladan owner maydoni). - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan (autentifikatsiya, ruxsatlar va filtrlash bilan). - Token autentifikatsiyasi va /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/working-with-pagination/#2-sahifalash-ni-tushunish","text":"\ud83d\udccc Sahifalash (pagination) API javoblarida ma'lumotlarni kichik qismlarga bo'lib, har bir sahifada cheklangan miqdordagi ma'lumotni qaytaradi. Bu server yukini kamaytiradi va foydalanuvchiga ma'lumotlarni boshqarishni osonlashtiradi. \ud83d\udccc DRFning o'rnatilgan sahifalash sinflari: - PageNumberPagination : Sahifa raqami asosida sahifalash (masalan, ?page=2). - LimitOffsetPagination : Belgilangan miqdor va ofset asosida sahifalash. - CursorPagination : Kursor asosida sahifalash, katta ma'lumotlar uchun samarali.","title":"\u2705 2. SAHIFALASH NI TUSHUNISH"},{"location":"drf/working-with-pagination/#3-model-va-serializerni-tekshirish","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz:","title":"\u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH"},{"location":"drf/working-with-pagination/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/working-with-pagination/#serializer-tekshirish","text":"\ud83d\udccc myapp/serializers.py faylida TaskSerializer quyidagicha bo'lishi kerak: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value","title":"\u2747\ufe0f Serializer tekshirish:"},{"location":"drf/working-with-pagination/#4-sahifalash-sozlamalarini-qoshish","text":"\ud83d\udccc DRFning PageNumberPagination sinfidan foydalanamiz. myproject/settings.py faylini yangilaymiz: REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], 'DEFAULT_THROTTLE_CLASSES': [ 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle', ], 'DEFAULT_THROTTLE_RATES': { 'anon': '10/hour', 'user': '20/hour', }, 'DEFAULT_FILTER_BACKENDS': [ 'django_filters.rest_framework.DjangoFilterBackend', ], 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination', 'PAGE_SIZE': 5, # Har bir sahifada 5 ta vazifa } \ud83d\udccc Tushuntirish : - DEFAULT_PAGINATION_CLASS : Standart sahifalash sinfi sifatida PageNumberPagination ni belgilaydi. - PAGE_SIZE : Har bir sahifada ko'rsatiladigan ma'lumotlar soni (5 ta vazifa).","title":"\u2705 4. SAHIFALASH SOZLAMALARINI QO'SHISH"},{"location":"drf/working-with-pagination/#5-maxsus-sahifalash-sinf-yaratish","text":"\ud83d\udccc Maxsus sahifalash sinfini yaratib, sahifalash javobini moslashtiramiz. myapp/pagination.py faylini yarating va quyidagi kodni qo'shing: from rest_framework.pagination import PageNumberPagination from rest_framework.response import Response class CustomTaskPagination(PageNumberPagination): page_size = 3 # Har bir sahifada 3 ta vazifa page_size_query_param = 'page_size' # Foydalanuvchi sahifa hajmini o'zgartirishi mumkin max_page_size = 100 # Maksimal sahifa hajmi def get_paginated_response(self, data): return Response({ 'count': self.page.paginator.count, 'next': self.get_next_link(), 'previous': self.get_previous_link(), 'results': data }) \ud83d\udccc Tushuntirish : - page_size : Har bir sahifada 3 ta vazifa ko'rsatiladi. - page_size_query_param : Foydalanuvchi ?page_size=10 kabi parametr yordamida sahifa hajmini o'zgartirishi mumkin. - max_page_size : Sahifa hajmi 100 dan oshmaydi. - get_paginated_response : Sahifalash javobini moslashtiradi (count, next, previous, results).","title":"\u2705 5. MAXSUS SAHIFALASH SINF YARATISH"},{"location":"drf/working-with-pagination/#6-viewset-ni-sahifalash-bilan-yangilash","text":"\ud83d\udccc myapp/views.py faylida TaskViewSet ni yangilaymiz va maxsus sahifalash sinfini qo'shamiz: from rest_framework import viewsets from django_filters.rest_framework import DjangoFilterBackend from rest_framework.filters import SearchFilter, OrderingFilter from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from .pagination import CustomTaskPagination from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] filterset_fields = ['completed', 'owner'] search_fields = ['title', 'description'] ordering_fields = ['created_at', 'completed'] ordering = ['created_at'] pagination_class = CustomTaskPagination # Maxsus sahifalash sinfi def perform_create(self, serializer): serializer.save(owner=self.request.user)","title":"\u2705 6. VIEWSET NI SAHIFALASH BILAN YANGILASH"},{"location":"drf/working-with-pagination/#7-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), ]","title":"\u2705 7. URL SOZLASH"},{"location":"drf/working-with-pagination/#8-sahifalash-ni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> .","title":"\u2705 8. SAHIFALASH NI SINAB KO'RISH"},{"location":"drf/working-with-pagination/#foydalanuvchi-va-token-yaratish","text":"\ud83d\udccc Agar hali yaratilmagan bo'lsa, foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 \ud83d\udccc Token oling: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user1&password=pass123\"","title":"\u2747\ufe0f Foydalanuvchi va token yaratish:"},{"location":"drf/working-with-pagination/#standart-sahifalash-sinovi","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc Har bir sahifada 3 ta vazifa ko'rinadi: curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user1_token>\" \ud83d\udccc Javob quyidagicha bo'ladi: { \"count\": 10, \"next\": \"http://127.0.0.1:8000/tasks/?page=2\", \"previous\": null, \"results\": [ {...}, {...}, {...} // 3 ta vazifa ] }","title":"\u2747\ufe0f Standart sahifalash sinovi:"},{"location":"drf/working-with-pagination/#muayyan-sahifani-korish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?page=2 \ud83d\udccc Usul : GET curl http://127.0.0.1:8000/tasks/?page=2 -H \"Authorization: Token <user1_token>\"","title":"\u2747\ufe0f Muayyan sahifani ko'rish:"},{"location":"drf/working-with-pagination/#sahifa-hajmini-ozgartirish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?page_size=5 \ud83d\udccc Usul : GET \ud83d\udccc Har bir sahifada 5 ta vazifa ko'rinadi: curl http://127.0.0.1:8000/tasks/?page_size=5 -H \"Authorization: Token <user1_token>\"","title":"\u2747\ufe0f Sahifa hajmini o'zgartirish:"},{"location":"drf/working-with-pagination/#filtrlash-bilan-birgalikda-sahifalash","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/?completed=true&page=1 \ud83d\udccc Usul : GET curl http://127.0.0.1:8000/tasks/?completed=true&page=1 -H \"Authorization: Token <user1_token>\"","title":"\u2747\ufe0f Filtrlash bilan birgalikda sahifalash:"},{"location":"drf/working-with-pagination/#9-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/working-with-pagination/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/working-with-pagination/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/working-with-pagination/#10-sinov-uchun-masalalar","text":"\ud83d\udccc Sahifalashni sinash uchun quyidagi amallarni bajarib ko'ring: 1. /tasks/ manzilida birinchi sahifani oling va 3 ta vazifa ekanligini tekshiring. 2. /tasks/?page=2 manzilidan ikkinchi sahifani oling. 3. /tasks/?page_size=5 manzilida sahifa hajmini 5 ga o'zgartiring. 4. /tasks/?completed=true&page_size=2 manzilida faqat bajarilgan vazifalarni sahifalab ko'ring.","title":"\u2705 10. SINOV UCHUN MASALALAR"},{"location":"drf/working-with-permissions/","text":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI \ud83e\udde9 8-DARS: RUXSATLAR BILAN ISHLASH Bu darsda Django REST Framework (DRF) yordamida ruxsatlar (permissions) ni sozlashni bosqichma-bosqich o'rganamiz. Ruxsatlar API resurslariga kirishni nazorat qiladi va foydalanuvchilarga faqat ruxsat berilgan amallarni bajarishga imkon beradi. Har bir qadam tushunarli va faqat ruxsatlarga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli va token autentifikatsiyasi asosida davom etamiz. \u2705 1. TAYYORLOV ISHLARI \ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan. - Token autentifikatsiyasi va /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting. \u2705 2. RUXSATLARNI TUSHUNISH \ud83d\udccc DRFda ruxsatlar (permissions) API endpointlariga kirishni nazorat qiladi. Ular foydalanuvchi autentifikatsiya qilinganligini yoki muayyan shartlarga javob berishini tekshiradi. DRFning o'rnatilgan ruxsat sinflari: - IsAuthenticated : Faqat autentifikatsiya qilingan foydalanuvchilar uchun ruxsat. - IsAdminUser : Faqat admin foydalanuvchilar uchun ruxsat. - IsAuthenticatedOrReadOnly : Autentifikatsiya qilinganlar uchun yozish, boshqalar uchun faqat o'qish. \ud83d\udccc Maxsus ruxsat sinflari ham yaratilishi mumkin. \u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH \ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz: \u2747\ufe0f Model tekshirish : \ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title \ud83d\udccc Yangilik sifatida owner maydoni qo'shildi, bu vazifaning egasini (foydalanuvchini) bog'laydi. \u2747\ufe0f Migratsiyalarni qo'llash : \ud83d\udccc owner maydoni qo'shilgani uchun migratsiyalarni yangilang: python manage.py makemigrations python manage.py migrate \u2747\ufe0f Serializer tekshirish : \ud83d\udccc myapp/serializers.py faylida TaskSerializer ni yangilaymiz: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \ud83d\udccc Tushuntirish : - owner : Faqat o'qish uchun maydon sifatida qo'shildi, foydalanuvchi nomini ko'rsatadi. - read_only_fields : owner foydalanuvchi tomonidan o'zgartirilmaydi. \u2705 4. MAXSUS RUXSAT SINFNI YARATISH \ud83d\udccc Faqat vazifa egasi (owner) o'z vazifalarini tahrirlashi yoki o'chirishi mumkin bo'lgan maxsus ruxsat sinfini yaratamiz. myapp/permissions.py faylini yarating va quyidagi kodni qo'shing: from rest_framework import permissions class IsOwnerOrReadOnly(permissions.BasePermission): def has_object_permission(self, request, view, obj): # GET, HEAD yoki OPTIONS so'rovlari uchun hamma ruxsat if request.method in permissions.SAFE_METHODS: return True # Yozish (POST, PUT, DELETE) uchun faqat egasi ruxsat return obj.owner == request.user \ud83d\udccc Tushuntirish : - IsOwnerOrReadOnly : GET (o'qish) so'rovlariga hamma ruxsat beriladi, lekin yozish (POST, PUT, DELETE) faqat vazifa egasi uchun mumkin. - has_object_permission : Har bir obyekt uchun ruxsatni tekshiradi. \u2705 5. VIEWSET NI RUXSATLAR BILAN YANGILASH \ud83d\udccc myapp/views.py faylida TaskViewSet ni yangilaymiz va maxsus ruxsat sinfini qo'shamiz: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] def perform_create(self, serializer): # Yangi vazifa yaratilganda owner ni so'rov yuborgan foydalanuvchi sifatida saqlaymiz serializer.save(owner=self.request.user) \ud83d\udccc Tushuntirish : - permission_classes : IsAuthenticated va IsOwnerOrReadOnly ruxsatlarini qo'llaydi. - perform_create : Yangi vazifa yaratilganda owner maydoniga joriy foydalanuvchini avtomatik belgilaydi. \u2705 6. LOYIHA SOZLAMALARINI TEKSHIRISH \ud83d\udccc myproject/settings.py faylida token autentifikatsiyasi sozlanganligiga ishonch hosil qiling: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'myapp', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], } \u2705 7. URL SOZLASH \ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), ] \u2705 8. RUXSATLARNI SINAB KO'RISH \ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> . \u2747\ufe0f Foydalanuvchi va token yaratish : \ud83d\udccc Ikkita foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 python manage.py createsuperuser # username: user2, password: pass456 \ud83d\udccc Har bir foydalanuvchi uchun token oling: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user1&password=pass123\" curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user2&password=pass456\" \u2747\ufe0f Create (Yangi vazifa qo'shish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (user1 uchun): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user1_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"User1 vazifasi\", \"description\": \"Test vazifa\"}' \u2747\ufe0f Read (Ma'lumotlarni o'qish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc Har qanday autentifikatsiya qilingan foydalanuvchi barcha vazifalarni ko'rishi mumkin: curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user2_token>\" \u2747\ufe0f Update (Ma'lumotlarni yangilash) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH \ud83d\udccc Masalan (user1 vazifani yangilaydi): curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token <user1_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' \ud83d\udccc Agar user2 bu vazifani yangilamoqchi bo'lsa, 403 Forbidden xatosi qaytadi: curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token <user2_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' \u2747\ufe0f Delete (Ma'lumotlarni o'chirish) : \ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Faqat user1 o'chirishi mumkin: curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token <user1_token>\" \u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY) \ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning: \u2747\ufe0f Admin foydalanuvchisini tekshirish : python manage.py createsuperuser \u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish : \ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang. \u2705 10. SINOV UCHUN MASALALAR \ud83d\udccc Ruxsatlarni sinash uchun quyidagi amallarni bajarib ko'ring: 1. user1 bilan yangi vazifa qo'shing va owner maydonini tekshiring. 2. user2 bilan user1 ning vazifasini yangilashga urinib ko'ring va 403 Forbidden xatosini oling. 3. user2 bilan /tasks/ manzilidan barcha vazifalarni ko'ring. 4. Tokensiz so'rov yuboring va 401 Unauthorized xatosini oling.","title":"Working with Permissions"},{"location":"drf/working-with-permissions/#django-rest-framework-asoslari","text":"","title":"\ud83c\udf10 DJANGO REST FRAMEWORK ASOSLARI"},{"location":"drf/working-with-permissions/#8-dars-ruxsatlar-bilan-ishlash","text":"Bu darsda Django REST Framework (DRF) yordamida ruxsatlar (permissions) ni sozlashni bosqichma-bosqich o'rganamiz. Ruxsatlar API resurslariga kirishni nazorat qiladi va foydalanuvchilarga faqat ruxsat berilgan amallarni bajarishga imkon beradi. Har bir qadam tushunarli va faqat ruxsatlarga qaratilgan bo'ladi. Oldingi darslarda sozlangan myproject loyihasi va myapp ilovasidagi Task modeli va token autentifikatsiyasi asosida davom etamiz.","title":"\ud83e\udde9 8-DARS: RUXSATLAR BILAN ISHLASH"},{"location":"drf/working-with-permissions/#1-tayyorlov-ishlari","text":"\ud83d\udccc Loyiha va ilova allaqachon sozlangan deb hisoblaymiz ( myproject , myapp , va Task modeli). Quyidagi sozlamalar mavjud bo'lishi kerak: - Task modeli myapp/models.py faylida belgilangan. - TaskSerializer myapp/serializers.py faylida yaratilgan. - TaskViewSet myapp/views.py faylida sozlangan. - Token autentifikatsiyasi va /tasks/ endpointi myproject/urls.py faylida sozlangan. \ud83d\udccc Agar bu sozlamalar hali amalga oshirilmagan bo'lsa, avvalgi darslarga qayting.","title":"\u2705 1. TAYYORLOV ISHLARI"},{"location":"drf/working-with-permissions/#2-ruxsatlarni-tushunish","text":"\ud83d\udccc DRFda ruxsatlar (permissions) API endpointlariga kirishni nazorat qiladi. Ular foydalanuvchi autentifikatsiya qilinganligini yoki muayyan shartlarga javob berishini tekshiradi. DRFning o'rnatilgan ruxsat sinflari: - IsAuthenticated : Faqat autentifikatsiya qilingan foydalanuvchilar uchun ruxsat. - IsAdminUser : Faqat admin foydalanuvchilar uchun ruxsat. - IsAuthenticatedOrReadOnly : Autentifikatsiya qilinganlar uchun yozish, boshqalar uchun faqat o'qish. \ud83d\udccc Maxsus ruxsat sinflari ham yaratilishi mumkin.","title":"\u2705 2. RUXSATLARNI TUSHUNISH"},{"location":"drf/working-with-permissions/#3-model-va-serializerni-tekshirish","text":"\ud83d\udccc Quyidagi sozlamalar oldingi darslarda amalga oshirilgan, lekin ularni qayta ko'rib chiqamiz:","title":"\u2705 3. MODEL VA SERIALIZERNI TEKSHIRISH"},{"location":"drf/working-with-permissions/#model-tekshirish","text":"\ud83d\udccc myapp/models.py faylida Task modeli quyidagicha bo'lishi kerak: from django.db import models class Task(models.Model): title = models.CharField(max_length=200) description = models.TextField(blank=True, null=True) completed = models.BooleanField(default=False) created_at = models.DateTimeField(auto_now_add=True) owner = models.ForeignKey('auth.User', related_name='tasks', on_delete=models.CASCADE, null=True) def __str__(self): return self.title \ud83d\udccc Yangilik sifatida owner maydoni qo'shildi, bu vazifaning egasini (foydalanuvchini) bog'laydi.","title":"\u2747\ufe0f Model tekshirish:"},{"location":"drf/working-with-permissions/#migratsiyalarni-qollash","text":"\ud83d\udccc owner maydoni qo'shilgani uchun migratsiyalarni yangilang: python manage.py makemigrations python manage.py migrate","title":"\u2747\ufe0f Migratsiyalarni qo'llash:"},{"location":"drf/working-with-permissions/#serializer-tekshirish","text":"\ud83d\udccc myapp/serializers.py faylida TaskSerializer ni yangilaymiz: from rest_framework import serializers from .models import Task class TaskSerializer(serializers.ModelSerializer): status = serializers.SerializerMethodField() owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Task fields = ['id', 'title', 'description', 'completed', 'created_at', 'status', 'owner'] read_only_fields = ['id', 'created_at', 'owner'] def get_status(self, obj): return \"Bajarilgan\" if obj.completed else \"Bajarilmagan\" def validate_title(self, value): if len(value) < 3: raise serializers.ValidationError(\"Sarlavha kamida 3 ta belgidan iborat bo'lishi kerak.\") return value \ud83d\udccc Tushuntirish : - owner : Faqat o'qish uchun maydon sifatida qo'shildi, foydalanuvchi nomini ko'rsatadi. - read_only_fields : owner foydalanuvchi tomonidan o'zgartirilmaydi.","title":"\u2747\ufe0f Serializer tekshirish:"},{"location":"drf/working-with-permissions/#4-maxsus-ruxsat-sinfni-yaratish","text":"\ud83d\udccc Faqat vazifa egasi (owner) o'z vazifalarini tahrirlashi yoki o'chirishi mumkin bo'lgan maxsus ruxsat sinfini yaratamiz. myapp/permissions.py faylini yarating va quyidagi kodni qo'shing: from rest_framework import permissions class IsOwnerOrReadOnly(permissions.BasePermission): def has_object_permission(self, request, view, obj): # GET, HEAD yoki OPTIONS so'rovlari uchun hamma ruxsat if request.method in permissions.SAFE_METHODS: return True # Yozish (POST, PUT, DELETE) uchun faqat egasi ruxsat return obj.owner == request.user \ud83d\udccc Tushuntirish : - IsOwnerOrReadOnly : GET (o'qish) so'rovlariga hamma ruxsat beriladi, lekin yozish (POST, PUT, DELETE) faqat vazifa egasi uchun mumkin. - has_object_permission : Har bir obyekt uchun ruxsatni tekshiradi.","title":"\u2705 4. MAXSUS RUXSAT SINFNI YARATISH"},{"location":"drf/working-with-permissions/#5-viewset-ni-ruxsatlar-bilan-yangilash","text":"\ud83d\udccc myapp/views.py faylida TaskViewSet ni yangilaymiz va maxsus ruxsat sinfini qo'shamiz: from rest_framework import viewsets from .models import Task from .serializers import TaskSerializer from .permissions import IsOwnerOrReadOnly from rest_framework.permissions import IsAuthenticated class TaskViewSet(viewsets.ModelViewSet): queryset = Task.objects.all() serializer_class = TaskSerializer permission_classes = [IsAuthenticated, IsOwnerOrReadOnly] def perform_create(self, serializer): # Yangi vazifa yaratilganda owner ni so'rov yuborgan foydalanuvchi sifatida saqlaymiz serializer.save(owner=self.request.user) \ud83d\udccc Tushuntirish : - permission_classes : IsAuthenticated va IsOwnerOrReadOnly ruxsatlarini qo'llaydi. - perform_create : Yangi vazifa yaratilganda owner maydoniga joriy foydalanuvchini avtomatik belgilaydi.","title":"\u2705 5. VIEWSET NI RUXSATLAR BILAN YANGILASH"},{"location":"drf/working-with-permissions/#6-loyiha-sozlamalarini-tekshirish","text":"\ud83d\udccc myproject/settings.py faylida token autentifikatsiyasi sozlanganligiga ishonch hosil qiling: INSTALLED_APPS = [ ... 'rest_framework', 'rest_framework.authtoken', 'myapp', ] REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.TokenAuthentication', ], 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAuthenticated', ], }","title":"\u2705 6. LOYIHA SOZLAMALARINI TEKSHIRISH"},{"location":"drf/working-with-permissions/#7-url-sozlash","text":"\ud83d\udccc myproject/urls.py faylida URL marshrutlari oldingi darsdagidek qoladi: from django.urls import path, include from rest_framework.routers import DefaultRouter from rest_framework.authtoken.views import obtain_auth_token from myapp.views import TaskViewSet router = DefaultRouter() router.register(r'tasks', TaskViewSet) urlpatterns = [ path('', include(router.urls)), path('api-token-auth/', obtain_auth_token, name='api_token_auth'), ]","title":"\u2705 7. URL SOZLASH"},{"location":"drf/working-with-permissions/#8-ruxsatlarni-sinab-korish","text":"\ud83d\udccc Serverni ishga tushiring: python manage.py runserver \ud83d\udccc API so'rovlarida tokenni Authorization sarlavhasida yuboring: Token <token> .","title":"\u2705 8. RUXSATLARNI SINAB KO'RISH"},{"location":"drf/working-with-permissions/#foydalanuvchi-va-token-yaratish","text":"\ud83d\udccc Ikkita foydalanuvchi yarating: python manage.py createsuperuser # username: user1, password: pass123 python manage.py createsuperuser # username: user2, password: pass456 \ud83d\udccc Har bir foydalanuvchi uchun token oling: curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user1&password=pass123\" curl -X POST http://127.0.0.1:8000/api-token-auth/ -d \"username=user2&password=pass456\"","title":"\u2747\ufe0f Foydalanuvchi va token yaratish:"},{"location":"drf/working-with-permissions/#create-yangi-vazifa-qoshish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : POST \ud83d\udccc Masalan (user1 uchun): curl -X POST http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user1_token>\" -H \"Content-Type: application/json\" -d '{\"title\": \"User1 vazifasi\", \"description\": \"Test vazifa\"}'","title":"\u2747\ufe0f Create (Yangi vazifa qo'shish):"},{"location":"drf/working-with-permissions/#read-malumotlarni-oqish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/ \ud83d\udccc Usul : GET \ud83d\udccc Har qanday autentifikatsiya qilingan foydalanuvchi barcha vazifalarni ko'rishi mumkin: curl http://127.0.0.1:8000/tasks/ -H \"Authorization: Token <user2_token>\"","title":"\u2747\ufe0f Read (Ma'lumotlarni o'qish):"},{"location":"drf/working-with-permissions/#update-malumotlarni-yangilash","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : PATCH \ud83d\udccc Masalan (user1 vazifani yangilaydi): curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token <user1_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}' \ud83d\udccc Agar user2 bu vazifani yangilamoqchi bo'lsa, 403 Forbidden xatosi qaytadi: curl -X PATCH http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token <user2_token>\" -H \"Content-Type: application/json\" -d '{\"completed\": true}'","title":"\u2747\ufe0f Update (Ma'lumotlarni yangilash):"},{"location":"drf/working-with-permissions/#delete-malumotlarni-ochirish","text":"\ud83d\udccc Manzil : http://127.0.0.1:8000/tasks/1/ \ud83d\udccc Usul : DELETE \ud83d\udccc Faqat user1 o'chirishi mumkin: curl -X DELETE http://127.0.0.1:8000/tasks/1/ -H \"Authorization: Token <user1_token>\"","title":"\u2747\ufe0f Delete (Ma'lumotlarni o'chirish):"},{"location":"drf/working-with-permissions/#9-admin-paneli-orqali-sinov-ixtiyoriy","text":"\ud83d\udccc Ma'lumotlarni qo'lda sinash uchun admin panelidan foydalaning:","title":"\u2705 9. ADMIN PANELI ORQALI SINOV (IXTIYORIY)"},{"location":"drf/working-with-permissions/#admin-foydalanuvchisini-tekshirish","text":"python manage.py createsuperuser","title":"\u2747\ufe0f Admin foydalanuvchisini tekshirish:"},{"location":"drf/working-with-permissions/#modelni-admin-panelida-royxatdan-otkazish","text":"\ud83d\udccc myapp/admin.py faylida: from django.contrib import admin from .models import Task admin.site.register(Task) \ud83d\udccc http://127.0.0.1:8000/admin/ manzilida vazifalarni qo'shing yoki tahrirlang.","title":"\u2747\ufe0f Modelni admin panelida ro'yxatdan o'tkazish:"},{"location":"drf/working-with-permissions/#10-sinov-uchun-masalalar","text":"\ud83d\udccc Ruxsatlarni sinash uchun quyidagi amallarni bajarib ko'ring: 1. user1 bilan yangi vazifa qo'shing va owner maydonini tekshiring. 2. user2 bilan user1 ning vazifasini yangilashga urinib ko'ring va 403 Forbidden xatosini oling. 3. user2 bilan /tasks/ manzilidan barcha vazifalarni ko'ring. 4. Tokensiz so'rov yuboring va 401 Unauthorized xatosini oling.","title":"\u2705 10. SINOV UCHUN MASALALAR"},{"location":"psql/basic-commands/","text":"\ud83d\udc18 PostgreSQL ASOSLARI \ud83e\udde9 2-DARS BASIC COMMANDS \u2705 DATABASE, TABLE, COLUMN va ROW haqida sodda tushuncha \ud83d\udcbe DATABASE (Ma\u2019lumotlar bazasi) \ud83d\udcd8 Database \u2014 bu katta ma\u2019lumotlar saqlanadigan joy . U kompyuter xotirasidagi katta fayl ga o\u2018xshaydi, lekin ichida ma\u2019lumotlar tartibli va boshqariladigan holda saqlanadi. Masalan: - Maktabda o\u2018quvchilar haqida ma\u2019lumotlar - Internet do\u2018konida mahsulotlar ro\u2018yxati - Ijtimoiy tarmoqda foydalanuvchilar profillari \ud83e\udde9 Ya\u2019ni database \u2014 bu ma\u2019lumotlar uchun uy . \ud83e\uddee TABLE (Jadval) \ud83d\udccb Table \u2014 bu database ichidagi bitta bo\u2018lim yoki varaq. Har bir table ma\u2019lum bir turdagi ma\u2019lumotni saqlaydi. Masalan: - Students \u2014 o\u2018quvchilar haqida ma\u2019lumot - Courses \u2014 kurslar haqida ma\u2019lumot - Teachers \u2014 o\u2018qituvchilar haqida ma\u2019lumot \ud83d\udd39 Table \u2014 bu Exceldagi jadval ga o\u2018xshaydi: unda ustunlar (columns) va qatorlar (rows) bo\u2018ladi. \ud83d\udcca COLUMN (Ustun) \ud83d\udcd7 Column \u2014 bu jadvaldagi ma\u2019lumot turi ni bildiradi. Har bir column faqat bitta turdagi ma\u2019lumotni saqlaydi. Masalan, Students jadvali uchun: Column nomi Ma\u2019lumot turi Tavsif id Raqam (integer) O\u2018quvchining raqami name Matn (text) O\u2018quvchining ismi age Raqam (integer) O\u2018quvchining yoshi email Matn (text) O\u2018quvchining elektron pochtasi \ud83d\udd39 Column \u2014 bu jadvaldagi ustun nomi va turi , ya\u2019ni \u201cqaysi ma\u2019lumot saqlanadi\u201d degan savolga javob beradi. \ud83e\uddcd ROW (Qator) \ud83d\udcd9 Row \u2014 bu jadvaldagi bitta to\u2018liq ma\u2019lumot yozuvi . Har bir row biror shaxs, buyum yoki hodisani ifodalaydi. Masalan: id name age email 1 Umid 20 umid@gmail.com Bu qator (row) \u2014 bitta o\u2018quvchi haqida to\u2018liq ma\u2019lumot. \ud83d\udd39 Har bir row \u2014 bu columnlar da belgilangan joylarga ma\u2019lumotni to\u2018ldirish natijasidir. \ud83d\udccc Agar bizda students nomli jadval bo'lsa, uning tarkibi quyidagicha bo'lishi mumkin: ID Name Surname Age Class 1 Ali Valiyev 20 A1 2 Madina Ismailova 21 A2 3 Bekzod Karimov 22 A3 Database - bunda bizning \"University\" nomli ma'lumotlar bazamiz bor deb tasavvur qilaylik. Table - students jadvali. Columns - ID , Name , Surname , Age , Class . Rows - har bir talaba haqida ma'lumotni ifodalovchi yozuvlar. \u2705 DATA TYPES \ud83d\udccc PostgreSQLda ma'lumot turlari ( data types ) ustunlarda saqlanadigan ma'lumotlarning turini belgilaydi va ular bilan qanday ishlash mumkinligini aniqlaydi. \u2747\ufe0f NUMBER \ud83d\udccc NUMBER \u2014 bu SQL ma'lumotlar bazasida sonlarni saqlash uchun ishlatiladigan asosiy ma'lumot turi hisoblanadi. NUMBER turlari yordamida butun sonlar, o\u2018nlik sonlar va boshqa raqamli qiymatlar saqlanadi. \u2733\ufe0f INTEGER \ud83d\udccc INTEGER (int, int4) \u2014 bu 4 baytli butun son turi bo\u2018lib, \u22122,147,483,648 dan +2,147,483,647 gacha bo\u2018lgan sonlarni saqlaydi. \ud83c\udfaf Oddiy ma\u2019lumot saqlash uchun example jadvali yaratish -- Example nomli jadval yaratilyapti -- Bu jadvalda faqat bitta ustun bor: num -- num ustuni INTEGER (butun son) tipida bo\u2018ladi CREATE TABLE Example ( num INTEGER ); \ud83c\udfaf Talabalar haqidagi ma\u2019lumotlarni saqlash uchun students jadvali yaratish -- students nomli jadval yaratilyapti CREATE TABLE students ( -- id ustuni yaratilmoqda -- Har bir talabaning yagona (unique) identifikatori sifatida ishlatiladi -- INTEGER tipida bo\u2018ladi va PRIMARY KEY (asosiy kalit) id INTEGER PRIMARY KEY, -- name ustuni yaratilmoqda -- Talabaning ismini saqlaydi -- Maksimal uzunligi 50 belgidan iborat bo\u2018lishi mumkin name VARCHAR(50), -- age ustuni yaratilmoqda -- Talabaning yoshini saqlaydi -- INTEGER (butun son) tipida bo\u2018ladi age INTEGER ); \u2733\ufe0f BIGINT \ud83d\udccc BIGINT (int8) \u2014 bu 8 baytli butun son turi bo\u2018lib, juda katta butun sonlarni saqlash uchun ishlatiladi. \ud83c\udfaf Oddiy BIGINT turidagi ustun yaratish uchun Example jadvali. -- Example nomli jadval yaratilyapti -- Bu jadvalda faqat bitta ustun bor: big_num -- big_num ustuni BIGINT (katta butun son) tipida bo\u2018ladi CREATE TABLE example ( big_num BIGINT ); \ud83c\udfaf Bank tranzaktsiyalarini saqlash uchun jadval yaratish -- transactions nomli jadval yaratilyapti CREATE TABLE transactions ( -- transaction_id ustuni yaratilmoqda -- Har bir tranzaktsiyaga noyob raqam beriladi -- Katta qiymatlarni saqlash uchun BIGINT ishlatiladi transaction_id BIGINT PRIMARY KEY, -- amount ustuni yaratilmoqda -- Tranzaksiya summasini saqlaydi -- BIGINT ishlatilmoqda, chunki ba'zi hollarda juda katta summalar bo\u2018lishi mumkin amount BIGINT, -- description ustuni yaratilmoqda -- Tranzaksiya haqida qisqa izoh description VARCHAR(100) ); \u2733\ufe0f SMALLINT \ud83d\udccc SMALLINT (int2) \u2014 bu 2 baytli butun son turi bo\u2018lib, kichik diapazondagi butun sonlarni saqlash uchun ishlatiladi. \ud83c\udfaf Oddiy SMALLINT turidagi ustun yaratish uchun example jadvali: -- Example nomli jadval yaratilyapti -- Bu jadvalda faqat bitta ustun bor: small_num -- small_num ustuni SMALLINT (kichik butun son) tipida bo\u2018ladi CREATE TABLE example ( small_num SMALLINT ); \ud83c\udfaf Xodimlarning lavozim darajasini saqlash uchun. -- employees nomli jadval yaratilyapti CREATE TABLE employees ( -- id ustuni: har bir xodimning ID raqami id INTEGER PRIMARY KEY, -- name ustuni: xodimning ismi name VARCHAR(50), -- level ustuni: xodimning lavozim darajasi -- Odatda bu 1 dan 10 gacha bo\u2018lgan kichik son bo\u2018ladi level SMALLINT ); \u2733\ufe0f DECIMAL OR NUMERIC \ud83d\udccc DECIMAL yoki NUMERIC \u2014 bu aniq o\u2018nlik kasr sonlarni saqlash uchun ishlatiladigan ma'lumot turi. Bu turda aniqlik (precision) va kasr sonlar soni (scale) aniq belgilanadi. \ud83c\udfaf example jadvali bilan amaliy misol -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- price ustuni yaratilmoqda -- Mahsulot yoki xizmat narxini saqlash uchun ishlatiladi -- DECIMAL(8, 2) tipida bo\u2018lib, maksimal qiymat 999999.99 bo\u2018lishi mumkin price DECIMAL(8, 2) ); DECIMAL ( precision , scale ) Precision: Jami raqamlar soni. Scale: Kasr qismidagi raqamlar soni. \u2733\ufe0f REAL \ud83d\udccc REAL \u2014 bu 4 baytli haqiqiy son (floating point) turi bo\u2018lib, o\u2018nlik kasr sonlarni taxminiy aniqlikda saqlaydi. -- Example nomli jadval yaratilyapti -- value ustuni REAL tipida, bu ustun haqiqiy sonlarni saqlaydi CREATE TABLE example ( value REAL ); \ud83c\udfaf Ob-havo ma\u2019lumotlari jadvali: -- weather_data nomli jadval yaratilyapti CREATE TABLE weather_data ( -- id: har bir yozuv uchun ID id INTEGER PRIMARY KEY, -- temperature: harorat, REAL tipida temperature REAL, -- humidity: namlik foizi, REAL tipida humidity REAL ); \u2733\ufe0f DOUBLE PRECISION DOUBLE PRECISION \u2014 bu 8 baytli aniqroq suzuvchi nuqtali haqiqiy sonlarni saqlash uchun ishlatiladigan ma'lumot turi, katta va kichik onlik sonlarni aniqlik bilan saqlaydi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- value ustuni yaratilmoqda -- Bu ustun DOUBLE PRECISION tipida bo\u2018ladi -- 8 baytli haqiqiy sonlarni (floating point) saqlaydi -- Katta aniqlikka ega kasr sonlarni saqlash uchun ishlatiladi value DOUBLE PRECISION ); \u2747\ufe0f TEXT TYPE \u2733\ufe0f CHAR(N) CHAR(n) \u2014 bu aniq uzunlikdagi matn turi, matn uzunligi n dan qisqa bo\u2018lsa, qolgan qismlar avtomatik bo\u2018sh joy (space) bilan to\u2018ldiriladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- code ustuni yaratilmoqda -- CHAR(5) - bu ustun sabit (belgilangan) uzunlikdagi matn saqlaydi -- Har doim 5 ta belgi joy ajratiladi -- Agar kiritilgan matn 5 ta belgidan kam bo\u2018lsa, qolgan joylar bo\u2018sh joy (space) bilan to\u2018ldiriladi code CHAR(5) ); \u2733\ufe0f VARCHAR(N) VARCHAR(n) \u2014 bu o\u2018zgaruvchan uzunlikdagi matn turi, matn uzunligi qancha bo\u2018lsa, shuncha joy egallaydi, lekin maksimal uzunlik n dan oshmaydi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- name ustuni yaratilmoqda -- VARCHAR(50) - bu ustun o\u2018zgaruvchan uzunlikdagi matn saqlaydi -- Maksimal uzunlik 50 ta belgi bilan cheklanadi -- Kiritilgan matn qancha uzunlikda bo\u2018lsa, shuncha joy egallaydi -- CHAR bilan farqi: bo\u2018sh joy bilan to\u2018ldirilmaydi, faqat kerakli joy egallanadi name VARCHAR(50) ); \u2733\ufe0f TEXT TEXT - bu cheksiz uzunlikdagi matn saqlash uchun ishlatiladigan ma'lumotlar turi. Matn uzunligi chegaralanmagan, ya'ni istalgan uzunlikdagi yozuvlar saqlanishi mumkin. VARCHAR(N) dan farqli ravishda maksimal uzunlik ko\u2018rsatilmaydi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- description ustuni yaratilmoqda -- TEXT - bu ustun cheksiz uzunlikdagi matn saqlaydi -- Matn uzunligi oldindan belgilab qo\u2018yilmaydi -- Juda katta (katta hajmli) matnlar uchun qulay description TEXT ); \u2747\ufe0f DATE AND TIME TYPES \u2733\ufe0f DATE DATE - bu faqat sana (yil, oy, kun) ni saqlaydigan ma'lumotlar turi. DATE turi vaqtni (soat, daqiqa, soniya) o\u2018z ichiga olmaydi \u2014 faqatgina sana qismi saqlanadi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- birth_date ustuni yaratilmoqda -- DATE - bu ustun faqat sanani (yil, oy, kun) saqlaydi -- Vaqt qismi (soat, daqiqa, soniya) bu yerda mavjud emas birth_date DATE ); \u2733\ufe0f TIME TIME \u2014 bu faqat vaqt (soat, daqiqa, soniya) ni saqlaydigan ma'lumotlar turi. Bu turda sana (yil, oy, kun) saqlanmaydi \u2014 faqat kun ichidagi vaqt ifodalanadi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- work_start ustuni yaratilmoqda -- TIME - bu ustun faqat vaqtni (soat, daqiqa, soniya) saqlaydi -- Sana (yil, oy, kun) bu yerda mavjud emas -- Masalan: '08:30:00', '17:45:30' kabi qiymatlar saqlanadi work_start TIME ); \u2733\ufe0f TIMESTAMP TIMESTAMP \u2014 bu sana va vaqtni birgalikda saqlovchi ma'lumotlar turi. Yil, oy, kun va soat, daqiqa, soniya birga saqlanadi. Ko\u2018pincha yozilgan vaqtni, o\u2018zgartirilgan vaqtni avtomatik yozib borishda ishlatiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- created_at ustuni yaratilmoqda -- TIMESTAMP - bu ustun sana va vaqtni birgalikda saqlaydi -- Sana: yil, oy, kun -- Vaqt: soat, daqiqa, soniya -- Masalan: '2025-07-13 22:30:15' kabi qiymat saqlanadi created_at TIMESTAMP ); \u2733\ufe0f TIMESTAMPTZ TIMESTAMPTZ (Timestamp with Time Zone) \u2014 bu sana va vaqtni soat mintaqasi bilan birga saqlaydigan ma'lumotlar turi. Yil, oy, kun, soat, daqiqa, soniya va vaqt zonasi (UTC+05, UTC-03 va h.k.) birgalikda saqlanadi. Bu tur ko\u2018pincha global loyihalarda, foydalanuvchining aniq vaqtini belgilash uchun ishlatiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- event_time ustuni yaratilmoqda -- TIMESTAMPTZ - bu ustun sana, vaqt va vaqt mintaqasini birga saqlaydi -- Masalan: '2025-07-13 18:45:00+05:00' -- Bu vaqt UTC+5 mintaqasiga tegishli ekanligini bildiradi event_time TIMESTAMPTZ ); \u2733\ufe0f INTERVAL INTERVAL \u2014 bu vaqt oralig\u2018ini (davrni) saqlovchi ma'lumotlar turi. Masalan: 1 kun, 3 soat, 2 oy 15 kun, 1 yil 5 oy 10 kun 4 soat 30 daqiqa kabi qiymatlar saqlanishi mumkin. Bu tur vaqtlar orasidagi farqni ifodalash yoki vaqt ustiga qo\u2018shish/ayirishda ishlatiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- duration ustuni yaratilmoqda -- INTERVAL - bu ustun vaqt oralig\u2018ini saqlaydi -- Masalan: '1 day', '3 hours', '2 months 15 days' kabi qiymatlar duration INTERVAL ); \u2747\ufe0f BOOLEAN TYPE \u2733\ufe0f BOOLEAN BOOLEAN \u2014 bu mantiqiy (true/false) qiymatlarni saqlovchi ma'lumotlar turi. Faqatgina TRUE, FALSE yoki NULL qiymatlarni qabul qiladi. Ko\u2018pincha holatni bildiruvchi ustunlarda ishlatiladi (masalan: foydalanuvchi faolmi yoki yo\u2018qmi). -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- is_active ustuni yaratilmoqda -- BOOLEAN - bu ustun TRUE yoki FALSE qiymatlarini saqlaydi -- TRUE - agar holat faol bo\u2018lsa -- FALSE - agar holat faol bo\u2018lmasa -- NULL - agar holat noma\u2019lum bo\u2018lsa is_active BOOLEAN ); \u2747\ufe0f ARRAY TYPE \u2733\ufe0f ARRAY ARRAY \u2014 bu bir xil turdagi bir nechta qiymatlarni bitta ustun ichida saqlash imkonini beruvchi massiv (array) ma'lumot turi. Massivdagi barcha elementlar bir xil ma'lumot turiga ega bo\u2018lishi kerak (masalan: INTEGER[], TEXT[]). -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- scores ustuni yaratilmoqda -- INTEGER[] - bu ustun butun sonlardan iborat massivni saqlaydi -- Masalan: {90, 85, 78} kabi qiymatlar -- Har bir qiymat massiv ichida, bir xil turda bo'lishi shart scores INTEGER[] ); \u2747\ufe0f JSON AND JSONB TYPES \u2733\ufe0f JSON JSON \u2014 bu JSON (JavaScript Object Notation) formatidagi tuzilgan ma'lumotlarni saqlovchi ma'lumot turi. Strukturaviy (nested) ma'lumotlarni, juftlik ko\u2018rinishidagi (kalit:qiymat) yozuvlarni saqlash uchun ishlatiladi. PostgreSQL JSON ustunlarida ma'lumotlarni o\u2018qish, izlash va o\u2018zgartirish uchun maxsus funksiyalarni qo\u2018llab-quvvatlaydi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- data ustuni yaratilmoqda -- JSON - bu ustun JSON formatidagi strukturalangan ma'lumotni saqlaydi -- Masalan: {'name': 'Umid', 'age': 25} kabi -- Kalit-qiymat juftliklari ko\u2018rinishida saqlanadi data JSON ); \u2733\ufe0f JSONB JSONB \u2014 bu JSON formatidagi ma'lumotlarni binary (ikkilik) formatda saqlovchi ma'lumot turi. JSON turiga o\u2018xshaydi, lekin JSONB tezroq ishlaydi, indekslash imkoniyatiga ega va tartiblanmagan (unordered) ko\u2018rinishda saqlanadi. Katta hajmdagi va murakkab tuzilgan JSON ma'lumotlar bilan samarali ishlash uchun tavsiya etiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- data ustuni yaratilmoqda -- JSONB - bu ustun JSON formatidagi ma'lumotni binary ko\u2018rinishda saqlaydi -- JSON ga nisbatan ko\u2018proq imkoniyat va tezlik taqdim etadi -- Masalan: {'product': 'laptop', 'price': 1500} kabi ma'lumotlar data JSONB ); \u2747\ufe0f UUID TYPE \u2733\ufe0f UUID UUID (Universally Unique Identifier) \u2014 bu butun dunyo bo\u2018yicha yagona (noyob) identifikatorlarni saqlash uchun ishlatiladigan ma'lumot turi. Ko\u2018pincha foydalanuvchi ID, mahsulot ID yoki boshqa unikal elementlarni aniqlashda ishlatiladi. UUID qiymatlari 128-bitli bo\u2018ladi va tasodifiy yoki belgilangan algoritm asosida yaratiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- user_id ustuni yaratilmoqda -- UUID - bu ustun noyob identifikatorlarni saqlaydi -- Masalan: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11' -- Har bir qiymat global darajada noyob bo\u2018ladi user_id UUID ); \u2747\ufe0f BINARY DATA TYPES \u2733\ufe0f BYTEA BYTEA (Byte Array) \u2014 bu binary (ikkilik) ma'lumotlarni saqlash uchun ishlatiladigan ma'lumot turi. Masalan, rasmlar, video, audio, fayllar, shifrlangan ma'lumotlar yoki boshqa raqamli kontent saqlashda ishlatiladi. Saqlangan ma'lumotlar ikkilamchi (2-lik) ko\u2018rinishda bazaga yoziladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- image ustuni yaratilmoqda -- BYTEA - bu ustun binary (ikkilik) ma'lumotlarni saqlaydi -- Masalan: rasm, fayl, video, audio va h.k. -- Ma'lumotlar 2-lik ko\u2018rinishda saqlanadi image BYTEA ); \u2747\ufe0f SERIAL AND BIGSERIAL TYPES \u2733\ufe0f SERIAL SERIAL \u2014 bu avtomatik ravishda o\u2018sib boruvchi butun son qiymatlarni yaratish uchun ishlatiladigan ma'lumot turi. Ko\u2018pincha asosiy kalit (primary key) sifatida ishlatiladi. Har bir yangi yozuv qo\u2018shilganda qiymat avtomatik tarzda 1 taga ortadi. SERIAL bu INTEGER ustuniga AUTO INCREMENT xususiyatini qo\u2018shadi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- id ustuni yaratilmoqda -- SERIAL - bu ustun avtomatik ravishda raqam hosil qiladi -- Har bir yangi yozuv uchun qiymat avtomatik 1 taga ortadi -- PRIMARY KEY - bu ustun asosiy kalit (noyob va NULL bo\u2018lmaydi) id SERIAL PRIMARY KEY ); \u2733\ufe0f BIGSERIAL BIGSERIAL \u2014 bu katta hajmdagi avtomatik o\u2018suvchi butun sonlarni yaratish uchun ishlatiladigan ma'lumot turi. SERIAL turiga o\u2018xshaydi, lekin katta raqamlar (64-bitgacha) bilan ishlash imkonini beradi. Ko\u2018pincha millionlab yozuvlar yoki katta hajmli bazalar uchun asosiy kalit (primary key) sifatida qo\u2018llaniladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- id ustuni yaratilmoqda -- BIGSERIAL - bu ustun avtomatik tarzda katta raqamlar yaratadi -- Har bir yangi yozuv uchun qiymat avtomatik 1 taga ortadi -- PRIMARY KEY - bu ustun asosiy kalit hisoblanadi -- Katta hajmli ma'lumotlar bazalari uchun mos id BIGSERIAL PRIMARY KEY ); \u2705 ASOSIY SQL BUYRUQLARI: CREATE DATABASE, CREATE TABLE, DROP, INSERT, SELECT \\h - SQL dagi buyruqlarni chiqarish \\? - PSQL ni ishlatish uchun buyruqlar \\q - dasturdan chiqish \\l - database larni ko'rish \\! cls - terminalni tozalash \\c database_name - ma'lumotlar bazasiga ulanish \\dt - jadvalni ko'rish \\d table_name - jadvalga ulanish \u2747\ufe0f CREATE DATABASE CREATE DATABASE : Yangi database yaratish. \\c database_name; - databasega ulanish CREATE DATABASE university; CREATE TABLE CREATE TABLE : Ma'lumotlar bazasi ichida yangi table(jadval) yaratadi. CREATE TABLE table_name ( column1 datatype, column2 datatype, ... ); Example: CREATE TABLE Students ( StudentID INT PRIMARY KEY, Name VARCHAR(50), Age INT, Grade VARCHAR(10) ); StudentID Name Age Grade \\dt - yaratilgan jadvalni ko'rish \\d table_name; - jadvalga ulanish DROP DROP : Ma'lumotlar bazasini yoki jadvalni o\u2018chirib tashlaydi. Ushbu buyruqni ehtiyotkorlik bilan ishlating, chunki u barcha ma'lumotlarni o\u2018chiradi. Database ni o\u2018chirish: DROP DATABASE database_name; Table ni o'chirish DROP TABLE table_name; Example: DROP TABLE Students; INSERT INSERT : Jadvalni elementlar bilan to'ldirish. INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...); Example: INSERT INTO Students (StudentID, Name, Age, Grade) VALUES (1, 'John Doe', 20, 'A'); StudentID Name Age Grade 1 John Doe 20 A SELECT SELECT : Jadvaldan ma'lumotlarni chiqarib beradi. Maxsus ustunlarni yoki shartlarni belgilash mumkin. SELECT column1, column2, ... FROM table_name WHERE condition; Example: SELECT Name, Age FROM Students WHERE Grade = 'A'; PRIMARY KEYS AND CONSTRAINTS [!NOTE] Ma'lumotlar bazasida asosiy kalit (primary key) va cheklovlar (constraints) ma'lumotlarning to'g'ri va tartibli saqlanishini ta'minlash uchun ishlatiladi. Primary key Primary key jadvaldagi har bir qatorni yagona tarzda identifikatsiya qiladi. U shuni ta'minlaydiki, jadvaldagi ikkita qator bir xil asosiy kalit qiymatiga ega bo'lmaydi va asosiy kalit hech qachon NULL bo'lmaydi. Characteristics of a Primary Key: Uniqueness: Har bir qator uchun asosiy kalit qiymati takrorlanmas bo'lishi kerak. Non-null: Primary key ustunida NULL qiymatlari bo'lishi mumkin emas. Single-column or Composite: Asosiy kalit bitta ustundan yoki bir nechta ustunlarning birikmasidan iborat bo'lishi mumkin. Example: CREATE TABLE Students ( StudentID INT PRIMARY KEY, Name VARCHAR(100), Age INT ); Bu yerda StudentID asosiy kalit bo'lib, har bir talabaning noyob ID ga ega bo'lishini ta'minlaydi. Composite Primary Key Example: CREATE TABLE Enrollments ( StudentID INT, CourseID INT, PRIMARY KEY (StudentID, CourseID) ); Bu jadvalda StudentID va CourseID birgalikda birikma asosiy kalit sifatida ishlatiladi, ya'ni har bir talaba bitta kursga faqat bir marta yozilishi mumkin. Constraints [!NOTE] Constraints jadval ustunlariga qo'llaniladigan qoidalar bo'lib, ular ma'lumotlarning to'g'ri va tartibli bo'lishini ta'minlaydi. Types of Constraints: 1. NOT NULL Ustunda NULL qiymat bo'lishiga ruxsat bermaydi. Example: CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, Name VARCHAR(100) NOT NULL ); UNIQUE Ustundagi barcha qiymatlar takrorlanmas bo'lishini ta'minlaydi. Example: CREATE TABLE Products ( ProductID INT PRIMARY KEY, SKU VARCHAR(50) UNIQUE ); PRIMARY KEY U NOT NULL va UNIQUE qoidalarini birlashtirib, har bir qatorni noyob identifikatsiyalaydi. FOREIGN KEY Jadvalni boshqa jadval bilan bog'laydi, boshqa jadvalning asosiy kalitiga ishora qiladi. Example: CREATE TABLE Orders ( OrderID INT PRIMARY KEY, CustomerID INT, FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID) ); CHECK Ustundagi qiymatlarning ma'lum bir shartga mos kelishini tekshiradi. Example: CREATE TABLE Accounts ( AccountID INT PRIMARY KEY, Balance DECIMAL(10, 2) CHECK (Balance >= 0) ); DEFAULT Agar kiritishda qiymat berilmasa, ustun uchun standart qiymatni belgilaydi. Example: CREATE TABLE Users ( UserID INT PRIMARY KEY, RegistrationDate DATE DEFAULT CURRENT_DATE ); PRACTICE Create library_system database library_system nomli ma\u2019lumotlar bazasini yarating. library_system bazasida books nomli jadval yarating va quyidagi ustunlarni qo\u2018shing: id (integer, primary key) title (varchar, maksimal 200 ta belgi) author (varchar, maksimal 100 ta belgi) published_year (integer) books jadvaliga quyidagi ma\u2019lumotlarni kiriting: ID title author published_year 1 \"1984\" \"George Orwell\" 1949 2 \"To Kill a Mockingbird\" \"Harper Lee\" 1960 books jadvalidan barcha ma\u2019lumotlarni oling. 1950-yildan keyin nashr etilgan kitoblarning faqat title va author ustunlarini oling. books jadvalini o\u2018chirib tashlang. library_system ma\u2019lumotlar bazasini o\u2018chirib tashlang (ehtiyotkorlik bilan foydalaning!). Primary Key bilan jadval yaratish students nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: student_id (integer, primary key) name (varchar, 100 ta belgi) age (integer) Composite Primary Key yaratish enrollments nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: student_id (integer) course_id (integer) enrollment_date (date) student_id va course_id ustunlarini birgalikda composite primary key sifatida belgilang NOT NULL Constraint qo\u2018shish teachers nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: teacher_id (integer, primary key) name (varchar, 100 ta belgi, null bo\u2018lishi mumkin emas) subject (varchar, 50 ta belgi) UNIQUE Constraint qo\u2018shish courses nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: course_id (integer, primary key) course_name (varchar, 100 ta belgi, har bir nom noyob bo\u2018lishi kerak) FOREIGN KEY Constraint qo\u2018shish classes nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: class_id (integer, primary key) teacher_id (integer, teachers jadvalidagi teacher_id ustuniga bog\u2018langan bo\u2018lishi kerak) CHECK Constraint qo\u2018shish grades nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: grade_id (integer, primary key) student_id (integer) grade (integer, qiymati 0 va 100 oralig\u2018ida bo\u2018lishi kerak)","title":"Basic Commands"},{"location":"psql/basic-commands/#postgresql-asoslari","text":"","title":"\ud83d\udc18 PostgreSQL ASOSLARI"},{"location":"psql/basic-commands/#2-dars-basic-commands","text":"","title":"\ud83e\udde9 2-DARS BASIC COMMANDS"},{"location":"psql/basic-commands/#database-table-column-va-row-haqida-sodda-tushuncha","text":"","title":"\u2705 DATABASE, TABLE, COLUMN va ROW haqida sodda tushuncha"},{"location":"psql/basic-commands/#database-malumotlar-bazasi","text":"\ud83d\udcd8 Database \u2014 bu katta ma\u2019lumotlar saqlanadigan joy . U kompyuter xotirasidagi katta fayl ga o\u2018xshaydi, lekin ichida ma\u2019lumotlar tartibli va boshqariladigan holda saqlanadi. Masalan: - Maktabda o\u2018quvchilar haqida ma\u2019lumotlar - Internet do\u2018konida mahsulotlar ro\u2018yxati - Ijtimoiy tarmoqda foydalanuvchilar profillari \ud83e\udde9 Ya\u2019ni database \u2014 bu ma\u2019lumotlar uchun uy .","title":"\ud83d\udcbe DATABASE (Ma\u2019lumotlar bazasi)"},{"location":"psql/basic-commands/#table-jadval","text":"\ud83d\udccb Table \u2014 bu database ichidagi bitta bo\u2018lim yoki varaq. Har bir table ma\u2019lum bir turdagi ma\u2019lumotni saqlaydi. Masalan: - Students \u2014 o\u2018quvchilar haqida ma\u2019lumot - Courses \u2014 kurslar haqida ma\u2019lumot - Teachers \u2014 o\u2018qituvchilar haqida ma\u2019lumot \ud83d\udd39 Table \u2014 bu Exceldagi jadval ga o\u2018xshaydi: unda ustunlar (columns) va qatorlar (rows) bo\u2018ladi.","title":"\ud83e\uddee TABLE (Jadval)"},{"location":"psql/basic-commands/#column-ustun","text":"\ud83d\udcd7 Column \u2014 bu jadvaldagi ma\u2019lumot turi ni bildiradi. Har bir column faqat bitta turdagi ma\u2019lumotni saqlaydi. Masalan, Students jadvali uchun: Column nomi Ma\u2019lumot turi Tavsif id Raqam (integer) O\u2018quvchining raqami name Matn (text) O\u2018quvchining ismi age Raqam (integer) O\u2018quvchining yoshi email Matn (text) O\u2018quvchining elektron pochtasi \ud83d\udd39 Column \u2014 bu jadvaldagi ustun nomi va turi , ya\u2019ni \u201cqaysi ma\u2019lumot saqlanadi\u201d degan savolga javob beradi.","title":"\ud83d\udcca COLUMN (Ustun)"},{"location":"psql/basic-commands/#row-qator","text":"\ud83d\udcd9 Row \u2014 bu jadvaldagi bitta to\u2018liq ma\u2019lumot yozuvi . Har bir row biror shaxs, buyum yoki hodisani ifodalaydi. Masalan: id name age email 1 Umid 20 umid@gmail.com Bu qator (row) \u2014 bitta o\u2018quvchi haqida to\u2018liq ma\u2019lumot. \ud83d\udd39 Har bir row \u2014 bu columnlar da belgilangan joylarga ma\u2019lumotni to\u2018ldirish natijasidir. \ud83d\udccc Agar bizda students nomli jadval bo'lsa, uning tarkibi quyidagicha bo'lishi mumkin: ID Name Surname Age Class 1 Ali Valiyev 20 A1 2 Madina Ismailova 21 A2 3 Bekzod Karimov 22 A3 Database - bunda bizning \"University\" nomli ma'lumotlar bazamiz bor deb tasavvur qilaylik. Table - students jadvali. Columns - ID , Name , Surname , Age , Class . Rows - har bir talaba haqida ma'lumotni ifodalovchi yozuvlar.","title":"\ud83e\uddcd ROW (Qator)"},{"location":"psql/basic-commands/#data-types","text":"\ud83d\udccc PostgreSQLda ma'lumot turlari ( data types ) ustunlarda saqlanadigan ma'lumotlarning turini belgilaydi va ular bilan qanday ishlash mumkinligini aniqlaydi.","title":"\u2705 DATA TYPES"},{"location":"psql/basic-commands/#number","text":"\ud83d\udccc NUMBER \u2014 bu SQL ma'lumotlar bazasida sonlarni saqlash uchun ishlatiladigan asosiy ma'lumot turi hisoblanadi. NUMBER turlari yordamida butun sonlar, o\u2018nlik sonlar va boshqa raqamli qiymatlar saqlanadi.","title":"\u2747\ufe0f NUMBER"},{"location":"psql/basic-commands/#integer","text":"\ud83d\udccc INTEGER (int, int4) \u2014 bu 4 baytli butun son turi bo\u2018lib, \u22122,147,483,648 dan +2,147,483,647 gacha bo\u2018lgan sonlarni saqlaydi. \ud83c\udfaf Oddiy ma\u2019lumot saqlash uchun example jadvali yaratish -- Example nomli jadval yaratilyapti -- Bu jadvalda faqat bitta ustun bor: num -- num ustuni INTEGER (butun son) tipida bo\u2018ladi CREATE TABLE Example ( num INTEGER ); \ud83c\udfaf Talabalar haqidagi ma\u2019lumotlarni saqlash uchun students jadvali yaratish -- students nomli jadval yaratilyapti CREATE TABLE students ( -- id ustuni yaratilmoqda -- Har bir talabaning yagona (unique) identifikatori sifatida ishlatiladi -- INTEGER tipida bo\u2018ladi va PRIMARY KEY (asosiy kalit) id INTEGER PRIMARY KEY, -- name ustuni yaratilmoqda -- Talabaning ismini saqlaydi -- Maksimal uzunligi 50 belgidan iborat bo\u2018lishi mumkin name VARCHAR(50), -- age ustuni yaratilmoqda -- Talabaning yoshini saqlaydi -- INTEGER (butun son) tipida bo\u2018ladi age INTEGER );","title":"\u2733\ufe0f INTEGER"},{"location":"psql/basic-commands/#bigint","text":"\ud83d\udccc BIGINT (int8) \u2014 bu 8 baytli butun son turi bo\u2018lib, juda katta butun sonlarni saqlash uchun ishlatiladi. \ud83c\udfaf Oddiy BIGINT turidagi ustun yaratish uchun Example jadvali. -- Example nomli jadval yaratilyapti -- Bu jadvalda faqat bitta ustun bor: big_num -- big_num ustuni BIGINT (katta butun son) tipida bo\u2018ladi CREATE TABLE example ( big_num BIGINT ); \ud83c\udfaf Bank tranzaktsiyalarini saqlash uchun jadval yaratish -- transactions nomli jadval yaratilyapti CREATE TABLE transactions ( -- transaction_id ustuni yaratilmoqda -- Har bir tranzaktsiyaga noyob raqam beriladi -- Katta qiymatlarni saqlash uchun BIGINT ishlatiladi transaction_id BIGINT PRIMARY KEY, -- amount ustuni yaratilmoqda -- Tranzaksiya summasini saqlaydi -- BIGINT ishlatilmoqda, chunki ba'zi hollarda juda katta summalar bo\u2018lishi mumkin amount BIGINT, -- description ustuni yaratilmoqda -- Tranzaksiya haqida qisqa izoh description VARCHAR(100) );","title":"\u2733\ufe0f BIGINT"},{"location":"psql/basic-commands/#smallint","text":"\ud83d\udccc SMALLINT (int2) \u2014 bu 2 baytli butun son turi bo\u2018lib, kichik diapazondagi butun sonlarni saqlash uchun ishlatiladi. \ud83c\udfaf Oddiy SMALLINT turidagi ustun yaratish uchun example jadvali: -- Example nomli jadval yaratilyapti -- Bu jadvalda faqat bitta ustun bor: small_num -- small_num ustuni SMALLINT (kichik butun son) tipida bo\u2018ladi CREATE TABLE example ( small_num SMALLINT ); \ud83c\udfaf Xodimlarning lavozim darajasini saqlash uchun. -- employees nomli jadval yaratilyapti CREATE TABLE employees ( -- id ustuni: har bir xodimning ID raqami id INTEGER PRIMARY KEY, -- name ustuni: xodimning ismi name VARCHAR(50), -- level ustuni: xodimning lavozim darajasi -- Odatda bu 1 dan 10 gacha bo\u2018lgan kichik son bo\u2018ladi level SMALLINT );","title":"\u2733\ufe0f SMALLINT"},{"location":"psql/basic-commands/#decimal-or-numeric","text":"\ud83d\udccc DECIMAL yoki NUMERIC \u2014 bu aniq o\u2018nlik kasr sonlarni saqlash uchun ishlatiladigan ma'lumot turi. Bu turda aniqlik (precision) va kasr sonlar soni (scale) aniq belgilanadi. \ud83c\udfaf example jadvali bilan amaliy misol -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- price ustuni yaratilmoqda -- Mahsulot yoki xizmat narxini saqlash uchun ishlatiladi -- DECIMAL(8, 2) tipida bo\u2018lib, maksimal qiymat 999999.99 bo\u2018lishi mumkin price DECIMAL(8, 2) ); DECIMAL ( precision , scale ) Precision: Jami raqamlar soni. Scale: Kasr qismidagi raqamlar soni.","title":"\u2733\ufe0f DECIMAL OR NUMERIC"},{"location":"psql/basic-commands/#real","text":"\ud83d\udccc REAL \u2014 bu 4 baytli haqiqiy son (floating point) turi bo\u2018lib, o\u2018nlik kasr sonlarni taxminiy aniqlikda saqlaydi. -- Example nomli jadval yaratilyapti -- value ustuni REAL tipida, bu ustun haqiqiy sonlarni saqlaydi CREATE TABLE example ( value REAL ); \ud83c\udfaf Ob-havo ma\u2019lumotlari jadvali: -- weather_data nomli jadval yaratilyapti CREATE TABLE weather_data ( -- id: har bir yozuv uchun ID id INTEGER PRIMARY KEY, -- temperature: harorat, REAL tipida temperature REAL, -- humidity: namlik foizi, REAL tipida humidity REAL );","title":"\u2733\ufe0f REAL"},{"location":"psql/basic-commands/#double-precision","text":"DOUBLE PRECISION \u2014 bu 8 baytli aniqroq suzuvchi nuqtali haqiqiy sonlarni saqlash uchun ishlatiladigan ma'lumot turi, katta va kichik onlik sonlarni aniqlik bilan saqlaydi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- value ustuni yaratilmoqda -- Bu ustun DOUBLE PRECISION tipida bo\u2018ladi -- 8 baytli haqiqiy sonlarni (floating point) saqlaydi -- Katta aniqlikka ega kasr sonlarni saqlash uchun ishlatiladi value DOUBLE PRECISION );","title":"\u2733\ufe0f DOUBLE PRECISION"},{"location":"psql/basic-commands/#text-type","text":"","title":"\u2747\ufe0f TEXT TYPE"},{"location":"psql/basic-commands/#charn","text":"CHAR(n) \u2014 bu aniq uzunlikdagi matn turi, matn uzunligi n dan qisqa bo\u2018lsa, qolgan qismlar avtomatik bo\u2018sh joy (space) bilan to\u2018ldiriladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- code ustuni yaratilmoqda -- CHAR(5) - bu ustun sabit (belgilangan) uzunlikdagi matn saqlaydi -- Har doim 5 ta belgi joy ajratiladi -- Agar kiritilgan matn 5 ta belgidan kam bo\u2018lsa, qolgan joylar bo\u2018sh joy (space) bilan to\u2018ldiriladi code CHAR(5) );","title":"\u2733\ufe0f CHAR(N)"},{"location":"psql/basic-commands/#varcharn","text":"VARCHAR(n) \u2014 bu o\u2018zgaruvchan uzunlikdagi matn turi, matn uzunligi qancha bo\u2018lsa, shuncha joy egallaydi, lekin maksimal uzunlik n dan oshmaydi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- name ustuni yaratilmoqda -- VARCHAR(50) - bu ustun o\u2018zgaruvchan uzunlikdagi matn saqlaydi -- Maksimal uzunlik 50 ta belgi bilan cheklanadi -- Kiritilgan matn qancha uzunlikda bo\u2018lsa, shuncha joy egallaydi -- CHAR bilan farqi: bo\u2018sh joy bilan to\u2018ldirilmaydi, faqat kerakli joy egallanadi name VARCHAR(50) );","title":"\u2733\ufe0f VARCHAR(N)"},{"location":"psql/basic-commands/#text","text":"TEXT - bu cheksiz uzunlikdagi matn saqlash uchun ishlatiladigan ma'lumotlar turi. Matn uzunligi chegaralanmagan, ya'ni istalgan uzunlikdagi yozuvlar saqlanishi mumkin. VARCHAR(N) dan farqli ravishda maksimal uzunlik ko\u2018rsatilmaydi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- description ustuni yaratilmoqda -- TEXT - bu ustun cheksiz uzunlikdagi matn saqlaydi -- Matn uzunligi oldindan belgilab qo\u2018yilmaydi -- Juda katta (katta hajmli) matnlar uchun qulay description TEXT );","title":"\u2733\ufe0f TEXT"},{"location":"psql/basic-commands/#date-and-time-types","text":"","title":"\u2747\ufe0f DATE AND TIME TYPES"},{"location":"psql/basic-commands/#date","text":"DATE - bu faqat sana (yil, oy, kun) ni saqlaydigan ma'lumotlar turi. DATE turi vaqtni (soat, daqiqa, soniya) o\u2018z ichiga olmaydi \u2014 faqatgina sana qismi saqlanadi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- birth_date ustuni yaratilmoqda -- DATE - bu ustun faqat sanani (yil, oy, kun) saqlaydi -- Vaqt qismi (soat, daqiqa, soniya) bu yerda mavjud emas birth_date DATE );","title":"\u2733\ufe0f DATE"},{"location":"psql/basic-commands/#time","text":"TIME \u2014 bu faqat vaqt (soat, daqiqa, soniya) ni saqlaydigan ma'lumotlar turi. Bu turda sana (yil, oy, kun) saqlanmaydi \u2014 faqat kun ichidagi vaqt ifodalanadi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- work_start ustuni yaratilmoqda -- TIME - bu ustun faqat vaqtni (soat, daqiqa, soniya) saqlaydi -- Sana (yil, oy, kun) bu yerda mavjud emas -- Masalan: '08:30:00', '17:45:30' kabi qiymatlar saqlanadi work_start TIME );","title":"\u2733\ufe0f TIME"},{"location":"psql/basic-commands/#timestamp","text":"TIMESTAMP \u2014 bu sana va vaqtni birgalikda saqlovchi ma'lumotlar turi. Yil, oy, kun va soat, daqiqa, soniya birga saqlanadi. Ko\u2018pincha yozilgan vaqtni, o\u2018zgartirilgan vaqtni avtomatik yozib borishda ishlatiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- created_at ustuni yaratilmoqda -- TIMESTAMP - bu ustun sana va vaqtni birgalikda saqlaydi -- Sana: yil, oy, kun -- Vaqt: soat, daqiqa, soniya -- Masalan: '2025-07-13 22:30:15' kabi qiymat saqlanadi created_at TIMESTAMP );","title":"\u2733\ufe0f TIMESTAMP"},{"location":"psql/basic-commands/#timestamptz","text":"TIMESTAMPTZ (Timestamp with Time Zone) \u2014 bu sana va vaqtni soat mintaqasi bilan birga saqlaydigan ma'lumotlar turi. Yil, oy, kun, soat, daqiqa, soniya va vaqt zonasi (UTC+05, UTC-03 va h.k.) birgalikda saqlanadi. Bu tur ko\u2018pincha global loyihalarda, foydalanuvchining aniq vaqtini belgilash uchun ishlatiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- event_time ustuni yaratilmoqda -- TIMESTAMPTZ - bu ustun sana, vaqt va vaqt mintaqasini birga saqlaydi -- Masalan: '2025-07-13 18:45:00+05:00' -- Bu vaqt UTC+5 mintaqasiga tegishli ekanligini bildiradi event_time TIMESTAMPTZ );","title":"\u2733\ufe0f TIMESTAMPTZ"},{"location":"psql/basic-commands/#interval","text":"INTERVAL \u2014 bu vaqt oralig\u2018ini (davrni) saqlovchi ma'lumotlar turi. Masalan: 1 kun, 3 soat, 2 oy 15 kun, 1 yil 5 oy 10 kun 4 soat 30 daqiqa kabi qiymatlar saqlanishi mumkin. Bu tur vaqtlar orasidagi farqni ifodalash yoki vaqt ustiga qo\u2018shish/ayirishda ishlatiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- duration ustuni yaratilmoqda -- INTERVAL - bu ustun vaqt oralig\u2018ini saqlaydi -- Masalan: '1 day', '3 hours', '2 months 15 days' kabi qiymatlar duration INTERVAL );","title":"\u2733\ufe0f INTERVAL"},{"location":"psql/basic-commands/#boolean-type","text":"","title":"\u2747\ufe0f BOOLEAN TYPE"},{"location":"psql/basic-commands/#boolean","text":"BOOLEAN \u2014 bu mantiqiy (true/false) qiymatlarni saqlovchi ma'lumotlar turi. Faqatgina TRUE, FALSE yoki NULL qiymatlarni qabul qiladi. Ko\u2018pincha holatni bildiruvchi ustunlarda ishlatiladi (masalan: foydalanuvchi faolmi yoki yo\u2018qmi). -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- is_active ustuni yaratilmoqda -- BOOLEAN - bu ustun TRUE yoki FALSE qiymatlarini saqlaydi -- TRUE - agar holat faol bo\u2018lsa -- FALSE - agar holat faol bo\u2018lmasa -- NULL - agar holat noma\u2019lum bo\u2018lsa is_active BOOLEAN );","title":"\u2733\ufe0f BOOLEAN"},{"location":"psql/basic-commands/#array-type","text":"","title":"\u2747\ufe0f ARRAY TYPE"},{"location":"psql/basic-commands/#array","text":"ARRAY \u2014 bu bir xil turdagi bir nechta qiymatlarni bitta ustun ichida saqlash imkonini beruvchi massiv (array) ma'lumot turi. Massivdagi barcha elementlar bir xil ma'lumot turiga ega bo\u2018lishi kerak (masalan: INTEGER[], TEXT[]). -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- scores ustuni yaratilmoqda -- INTEGER[] - bu ustun butun sonlardan iborat massivni saqlaydi -- Masalan: {90, 85, 78} kabi qiymatlar -- Har bir qiymat massiv ichida, bir xil turda bo'lishi shart scores INTEGER[] );","title":"\u2733\ufe0f ARRAY"},{"location":"psql/basic-commands/#json-and-jsonb-types","text":"","title":"\u2747\ufe0f JSON AND JSONB TYPES"},{"location":"psql/basic-commands/#json","text":"JSON \u2014 bu JSON (JavaScript Object Notation) formatidagi tuzilgan ma'lumotlarni saqlovchi ma'lumot turi. Strukturaviy (nested) ma'lumotlarni, juftlik ko\u2018rinishidagi (kalit:qiymat) yozuvlarni saqlash uchun ishlatiladi. PostgreSQL JSON ustunlarida ma'lumotlarni o\u2018qish, izlash va o\u2018zgartirish uchun maxsus funksiyalarni qo\u2018llab-quvvatlaydi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- data ustuni yaratilmoqda -- JSON - bu ustun JSON formatidagi strukturalangan ma'lumotni saqlaydi -- Masalan: {'name': 'Umid', 'age': 25} kabi -- Kalit-qiymat juftliklari ko\u2018rinishida saqlanadi data JSON );","title":"\u2733\ufe0f JSON"},{"location":"psql/basic-commands/#jsonb","text":"JSONB \u2014 bu JSON formatidagi ma'lumotlarni binary (ikkilik) formatda saqlovchi ma'lumot turi. JSON turiga o\u2018xshaydi, lekin JSONB tezroq ishlaydi, indekslash imkoniyatiga ega va tartiblanmagan (unordered) ko\u2018rinishda saqlanadi. Katta hajmdagi va murakkab tuzilgan JSON ma'lumotlar bilan samarali ishlash uchun tavsiya etiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- data ustuni yaratilmoqda -- JSONB - bu ustun JSON formatidagi ma'lumotni binary ko\u2018rinishda saqlaydi -- JSON ga nisbatan ko\u2018proq imkoniyat va tezlik taqdim etadi -- Masalan: {'product': 'laptop', 'price': 1500} kabi ma'lumotlar data JSONB );","title":"\u2733\ufe0f JSONB"},{"location":"psql/basic-commands/#uuid-type","text":"","title":"\u2747\ufe0f UUID TYPE"},{"location":"psql/basic-commands/#uuid","text":"UUID (Universally Unique Identifier) \u2014 bu butun dunyo bo\u2018yicha yagona (noyob) identifikatorlarni saqlash uchun ishlatiladigan ma'lumot turi. Ko\u2018pincha foydalanuvchi ID, mahsulot ID yoki boshqa unikal elementlarni aniqlashda ishlatiladi. UUID qiymatlari 128-bitli bo\u2018ladi va tasodifiy yoki belgilangan algoritm asosida yaratiladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- user_id ustuni yaratilmoqda -- UUID - bu ustun noyob identifikatorlarni saqlaydi -- Masalan: 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11' -- Har bir qiymat global darajada noyob bo\u2018ladi user_id UUID );","title":"\u2733\ufe0f UUID"},{"location":"psql/basic-commands/#binary-data-types","text":"","title":"\u2747\ufe0f BINARY DATA TYPES"},{"location":"psql/basic-commands/#bytea","text":"BYTEA (Byte Array) \u2014 bu binary (ikkilik) ma'lumotlarni saqlash uchun ishlatiladigan ma'lumot turi. Masalan, rasmlar, video, audio, fayllar, shifrlangan ma'lumotlar yoki boshqa raqamli kontent saqlashda ishlatiladi. Saqlangan ma'lumotlar ikkilamchi (2-lik) ko\u2018rinishda bazaga yoziladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- image ustuni yaratilmoqda -- BYTEA - bu ustun binary (ikkilik) ma'lumotlarni saqlaydi -- Masalan: rasm, fayl, video, audio va h.k. -- Ma'lumotlar 2-lik ko\u2018rinishda saqlanadi image BYTEA );","title":"\u2733\ufe0f BYTEA"},{"location":"psql/basic-commands/#serial-and-bigserial-types","text":"","title":"\u2747\ufe0f SERIAL AND BIGSERIAL TYPES"},{"location":"psql/basic-commands/#serial","text":"SERIAL \u2014 bu avtomatik ravishda o\u2018sib boruvchi butun son qiymatlarni yaratish uchun ishlatiladigan ma'lumot turi. Ko\u2018pincha asosiy kalit (primary key) sifatida ishlatiladi. Har bir yangi yozuv qo\u2018shilganda qiymat avtomatik tarzda 1 taga ortadi. SERIAL bu INTEGER ustuniga AUTO INCREMENT xususiyatini qo\u2018shadi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- id ustuni yaratilmoqda -- SERIAL - bu ustun avtomatik ravishda raqam hosil qiladi -- Har bir yangi yozuv uchun qiymat avtomatik 1 taga ortadi -- PRIMARY KEY - bu ustun asosiy kalit (noyob va NULL bo\u2018lmaydi) id SERIAL PRIMARY KEY );","title":"\u2733\ufe0f SERIAL"},{"location":"psql/basic-commands/#bigserial","text":"BIGSERIAL \u2014 bu katta hajmdagi avtomatik o\u2018suvchi butun sonlarni yaratish uchun ishlatiladigan ma'lumot turi. SERIAL turiga o\u2018xshaydi, lekin katta raqamlar (64-bitgacha) bilan ishlash imkonini beradi. Ko\u2018pincha millionlab yozuvlar yoki katta hajmli bazalar uchun asosiy kalit (primary key) sifatida qo\u2018llaniladi. -- Example nomli jadval yaratilyapti CREATE TABLE example ( -- id ustuni yaratilmoqda -- BIGSERIAL - bu ustun avtomatik tarzda katta raqamlar yaratadi -- Har bir yangi yozuv uchun qiymat avtomatik 1 taga ortadi -- PRIMARY KEY - bu ustun asosiy kalit hisoblanadi -- Katta hajmli ma'lumotlar bazalari uchun mos id BIGSERIAL PRIMARY KEY );","title":"\u2733\ufe0f BIGSERIAL"},{"location":"psql/basic-commands/#asosiy-sql-buyruqlari-create-database-create-table-drop-insert-select","text":"\\h - SQL dagi buyruqlarni chiqarish \\? - PSQL ni ishlatish uchun buyruqlar \\q - dasturdan chiqish \\l - database larni ko'rish \\! cls - terminalni tozalash \\c database_name - ma'lumotlar bazasiga ulanish \\dt - jadvalni ko'rish \\d table_name - jadvalga ulanish","title":"\u2705 ASOSIY SQL BUYRUQLARI: CREATE DATABASE, CREATE TABLE, DROP, INSERT, SELECT"},{"location":"psql/basic-commands/#create-database","text":"CREATE DATABASE : Yangi database yaratish. \\c database_name; - databasega ulanish CREATE DATABASE university;","title":"\u2747\ufe0f CREATE DATABASE"},{"location":"psql/basic-commands/#create-table","text":"CREATE TABLE : Ma'lumotlar bazasi ichida yangi table(jadval) yaratadi. CREATE TABLE table_name ( column1 datatype, column2 datatype, ... ); Example: CREATE TABLE Students ( StudentID INT PRIMARY KEY, Name VARCHAR(50), Age INT, Grade VARCHAR(10) ); StudentID Name Age Grade \\dt - yaratilgan jadvalni ko'rish \\d table_name; - jadvalga ulanish","title":"CREATE TABLE"},{"location":"psql/basic-commands/#drop","text":"DROP : Ma'lumotlar bazasini yoki jadvalni o\u2018chirib tashlaydi. Ushbu buyruqni ehtiyotkorlik bilan ishlating, chunki u barcha ma'lumotlarni o\u2018chiradi. Database ni o\u2018chirish: DROP DATABASE database_name; Table ni o'chirish DROP TABLE table_name; Example: DROP TABLE Students;","title":"DROP"},{"location":"psql/basic-commands/#insert","text":"INSERT : Jadvalni elementlar bilan to'ldirish. INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...); Example: INSERT INTO Students (StudentID, Name, Age, Grade) VALUES (1, 'John Doe', 20, 'A'); StudentID Name Age Grade 1 John Doe 20 A","title":"INSERT"},{"location":"psql/basic-commands/#select","text":"SELECT : Jadvaldan ma'lumotlarni chiqarib beradi. Maxsus ustunlarni yoki shartlarni belgilash mumkin. SELECT column1, column2, ... FROM table_name WHERE condition; Example: SELECT Name, Age FROM Students WHERE Grade = 'A';","title":"SELECT"},{"location":"psql/basic-commands/#primary-keys-and-constraints","text":"[!NOTE] Ma'lumotlar bazasida asosiy kalit (primary key) va cheklovlar (constraints) ma'lumotlarning to'g'ri va tartibli saqlanishini ta'minlash uchun ishlatiladi.","title":"PRIMARY KEYS AND CONSTRAINTS"},{"location":"psql/basic-commands/#primary-key","text":"Primary key jadvaldagi har bir qatorni yagona tarzda identifikatsiya qiladi. U shuni ta'minlaydiki, jadvaldagi ikkita qator bir xil asosiy kalit qiymatiga ega bo'lmaydi va asosiy kalit hech qachon NULL bo'lmaydi. Characteristics of a Primary Key: Uniqueness: Har bir qator uchun asosiy kalit qiymati takrorlanmas bo'lishi kerak. Non-null: Primary key ustunida NULL qiymatlari bo'lishi mumkin emas. Single-column or Composite: Asosiy kalit bitta ustundan yoki bir nechta ustunlarning birikmasidan iborat bo'lishi mumkin. Example: CREATE TABLE Students ( StudentID INT PRIMARY KEY, Name VARCHAR(100), Age INT ); Bu yerda StudentID asosiy kalit bo'lib, har bir talabaning noyob ID ga ega bo'lishini ta'minlaydi. Composite Primary Key Example: CREATE TABLE Enrollments ( StudentID INT, CourseID INT, PRIMARY KEY (StudentID, CourseID) ); Bu jadvalda StudentID va CourseID birgalikda birikma asosiy kalit sifatida ishlatiladi, ya'ni har bir talaba bitta kursga faqat bir marta yozilishi mumkin.","title":"Primary key"},{"location":"psql/basic-commands/#constraints","text":"[!NOTE] Constraints jadval ustunlariga qo'llaniladigan qoidalar bo'lib, ular ma'lumotlarning to'g'ri va tartibli bo'lishini ta'minlaydi. Types of Constraints: 1. NOT NULL Ustunda NULL qiymat bo'lishiga ruxsat bermaydi. Example: CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, Name VARCHAR(100) NOT NULL ); UNIQUE Ustundagi barcha qiymatlar takrorlanmas bo'lishini ta'minlaydi. Example: CREATE TABLE Products ( ProductID INT PRIMARY KEY, SKU VARCHAR(50) UNIQUE ); PRIMARY KEY U NOT NULL va UNIQUE qoidalarini birlashtirib, har bir qatorni noyob identifikatsiyalaydi. FOREIGN KEY Jadvalni boshqa jadval bilan bog'laydi, boshqa jadvalning asosiy kalitiga ishora qiladi. Example: CREATE TABLE Orders ( OrderID INT PRIMARY KEY, CustomerID INT, FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID) ); CHECK Ustundagi qiymatlarning ma'lum bir shartga mos kelishini tekshiradi. Example: CREATE TABLE Accounts ( AccountID INT PRIMARY KEY, Balance DECIMAL(10, 2) CHECK (Balance >= 0) ); DEFAULT Agar kiritishda qiymat berilmasa, ustun uchun standart qiymatni belgilaydi. Example: CREATE TABLE Users ( UserID INT PRIMARY KEY, RegistrationDate DATE DEFAULT CURRENT_DATE );","title":"Constraints"},{"location":"psql/basic-commands/#practice","text":"Create library_system database library_system nomli ma\u2019lumotlar bazasini yarating. library_system bazasida books nomli jadval yarating va quyidagi ustunlarni qo\u2018shing: id (integer, primary key) title (varchar, maksimal 200 ta belgi) author (varchar, maksimal 100 ta belgi) published_year (integer) books jadvaliga quyidagi ma\u2019lumotlarni kiriting: ID title author published_year 1 \"1984\" \"George Orwell\" 1949 2 \"To Kill a Mockingbird\" \"Harper Lee\" 1960 books jadvalidan barcha ma\u2019lumotlarni oling. 1950-yildan keyin nashr etilgan kitoblarning faqat title va author ustunlarini oling. books jadvalini o\u2018chirib tashlang. library_system ma\u2019lumotlar bazasini o\u2018chirib tashlang (ehtiyotkorlik bilan foydalaning!). Primary Key bilan jadval yaratish students nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: student_id (integer, primary key) name (varchar, 100 ta belgi) age (integer) Composite Primary Key yaratish enrollments nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: student_id (integer) course_id (integer) enrollment_date (date) student_id va course_id ustunlarini birgalikda composite primary key sifatida belgilang NOT NULL Constraint qo\u2018shish teachers nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: teacher_id (integer, primary key) name (varchar, 100 ta belgi, null bo\u2018lishi mumkin emas) subject (varchar, 50 ta belgi) UNIQUE Constraint qo\u2018shish courses nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: course_id (integer, primary key) course_name (varchar, 100 ta belgi, har bir nom noyob bo\u2018lishi kerak) FOREIGN KEY Constraint qo\u2018shish classes nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: class_id (integer, primary key) teacher_id (integer, teachers jadvalidagi teacher_id ustuniga bog\u2018langan bo\u2018lishi kerak) CHECK Constraint qo\u2018shish grades nomli jadval yarating. U quyidagi ustunlardan iborat bo\u2018lsin: grade_id (integer, primary key) student_id (integer) grade (integer, qiymati 0 va 100 oralig\u2018ida bo\u2018lishi kerak)","title":"PRACTICE"},{"location":"psql/data-manipulation/","text":"\ud83d\udc18 Data Manipulation Topics: Updating records with UPDATE Deleting records with DELETE Managing data integrity with constraints (foreign keys, unique) Transactions and rollback Updating records with UPDATE [!NOTE] PostgreSQLda ma'lumotlarni yangilash uchun UPDATE operatoridan foydalaniladi. Bu operator jadvaldagi mavjud malumotlarni yangilash uchun ishlatiladi. Syntax of UPDATE: UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; Key Points: SET : Qaysi ustunni yangi qiymat bilan yangilashni belgilaydi. WHERE : Qaysi malumotni yangilashni aniqlash uchun ishlatiladi. Agar WHERE shartini qo'shmasangiz, jadvaldagi barcha malumotlar yangilanadi. Conditions : Agar kerak bo'lsa, bir nechta shartlarni birlashtirish uchun AND, OR mantiqiy operatorlarini ishlatish mumkin. client_id first_name last_name date_of_birth email phone address city country postal_code registration_date last_activity_date balance status 1 Ali Karimov 1990-01-01 ali.karimov@mail.uz +99890123456 Tashkent, Block 15 Tashkent Uzbekistan 100100 2024-01-01 2024-12-01 150.50 TRUE 2 Dilnoza Tursunova 1985-05-12 dilnoza@mail.uz +99890123457 Samarkand, Block 7 Samarkand Uzbekistan 140200 2024-02-15 2024-11-20 0.00 FALSE 3 Bekzod Rasulov 1992-03-22 bekzod@mail.uz +99890123458 Bukhara, Block 9 Bukhara Uzbekistan 200300 2024-05-10 2024-10-30 250.75 TRUE Basic Update Example id = 2 bo'lgan clientni city ustunini Navoiy ga o'zgartiramiz: UPDATE clients SET city = 'Navoiy' WHERE client_id = 2; Updating Multiple Columns Agar bir vaqtning o'zida bir nechta ustunlarni yangilash kerak bo'lsa: UPDATE clients SET city = 'Navoiy', balance = 250.75 WHERE first_name = 'Ali'; Updating All Rows Agar jadvaldagi barcha qatorlarni yangilash kerak bo'lsa: UPDATE clients SET city = 'Navoiy'; Conditional Updates with AND and OR city = 'Toshkent' va status = TRUE bo'lgan clientning phone ustunini +998930850955 ga o'zgartiramiz: UPDATE clients SET phone = '+998930850955' WHERE city = 'Toshkent' AND status = TRUE; Deleting records with DELETE [!NOTE] PostgreSQLda ma'lumotlarni o'chirish uchun DELETE operatoridan foydalaniladi. Syntax of the DELETE Statement DELETE FROM table_name WHERE condition; table_name : O'chirish amalga oshiriladigan jadval nomi. condition : Qaysi satrlarni o'chirish kerakligini belgilaydigan shart. [!CAUTION] Agar WHERE sharti ko'rsatilmasa, jadvaldagi barcha yozuvlar o'chiriladi. Bunda ehtiyot bo'lish kerak! Deleting specific records based on a condition Agar jadvaldan faqat aniq bir shartga mos malumotni o'chirish kerak bo'lsa, WHERE sharti qo'llaniladi. DELETE FROM clients WHERE client_id = 2; Deleting all records Agar barcha malumotlarni o'chirish kerak bo'lsa, WHERE sharti berilmaydi. DELETE FROM clients; Managing data integrity with constraints (foreign keys, unique) Foreign Key Foreign key bir jadvaldagi ustun boshqa jadvaldagi ustunga bog'liq bo'lishini ta'minlaydi. Bu jadvallarni bir biriga bog'lash uchun ishlatiladi ishlatiladi. Customers Table customer_id name email 1 Anvar Aliyev aliyev@example.com 2 Nodira Karimova karimova@example.com Orders Table order_id customer_id order_date amount 1 1 2024-12-25 150.00 2 2 2024-12-26 200.50 -- Creating the Customers table CREATE TABLE customers ( customer_id SERIAL PRIMARY KEY, -- Primary key name VARCHAR(100) NOT NULL, email VARCHAR(100) UNIQUE NOT NULL -- Email must be unique ); -- Creating the Orders table CREATE TABLE orders ( order_id SERIAL PRIMARY KEY, -- Primary key customer_id INT NOT NULL, order_date DATE NOT NULL, amount NUMERIC(10, 2) NOT NULL, CONSTRAINT fk_customer FOREIGN KEY (customer_id) REFERENCES customers (customer_id) ON DELETE CASCADE ); PRACTICS Task 1 Sizda students nomli jadval mavjud. Jadvalda quyidagi ustunlar bor: id (integer) - talabalar id raqamlari (PRIMARY KEY) name (varchar) - talabaning ismi age (integer) - talabaning yoshi grade (varchar) - talabaning bahosi (masalan, A, B, C, D) city (varchar) - talabaning yashash shahri Data id name age grade city 1 Ali 19 B Tashkent 2 Salim 18 C Samarkand 3 Malika 20 A Bukhara 4 Shoxruh 21 D Tashkent 5 Laylo 22 C Nukus Tasks Tashkent shahrida yashovchi barcha talabalarni toping va ularning grade ustunini B ga o'zgartiring. Yoshi 20 yoki undan katta bo'lgan talabalarni toping va ularning yashash shahrini Tashkent ga o'zgartiring. grade ustuni C bo'lgan barcha talabalar uchun age ni 1 yoshga oshiring. Task 2 Sizda employees nomli jadval bor. Jadvalda quyidagi ustunlar mavjud: id (integer) - xodimning id raqami (asosiy kalit, PRIMARY KEY) name (varchar) - xodimning ismi department (varchar) - xodim ishlaydigan bo'lim (masalan, HR, IT, Sales) salary (integer) - xodimning oyligi experience (integer) - xodimning ish tajribasi (yillarda) city (varchar) - xodim yashayotgan shahar Data id name department salary experience city 1 Nodir IT 1200 3 Tashkent 2 Malika HR 900 5 Samarkand 3 Shoxruh Sales 1500 7 Bukhara 4 Laylo IT 1000 2 Nukus 5 Kamol HR 850 6 Tashkent 6 Saida Sales 1100 4 Andijan Tasks Toshkent shahridagi barcha xodimlarning oyliklarini 10% ga oshiring. Tajribasi 5 yildan oshgan xodimlarni toping va ularning bo'limini \"Senior\" qilib yangilang. Oyligi 1000 dan kam bo'lgan barcha xodimlarni toping va ularning oyligini 950 ga o'zgartiring. \"Sales\" bo'limida ishlaydigan xodimlarning shaharlarini \"Tashkent\" qilib yangilang. \"IT\" bo'limida ishlaydigan, tajribasi 3 yildan kam bo'lgan xodimlarning oyliklarini 20% ga oshiring. Task 3 Sizda products nomli jadval mavjud. Jadval quyidagi ustunlardan iborat: id (integer) - mahsulot ID (asosiy kalit, PRIMARY KEY) name (varchar) - mahsulot nomi category (varchar) - mahsulot kategoriyasi (masalan, Electronics, Clothing, Food) price (integer) - mahsulot narxi quantity (integer) - mahsulot ombordagi miqdori supplier (varchar) - yetkazib beruvchi nomi id name category price quantity supplier 1 Laptop Electronics 1200 10 TechStore 2 T-Shirt Clothing 25 50 FashionHub 3 Phone Electronics 800 5 TechStore 4 Bread Food 2 100 FoodMart 5 TV Electronics 500 2 HomeAppliance 6 Jacket Clothing 60 20 FashionHub 7 Milk Food 1 200 FoodMart 8 Tablet Electronics 300 0 TechStore 9 Headphones Electronics 50 15 AudioWorld 10 Sneakers Clothing 80 0 FashionHub Tasks quantity 0 bo'lgan barcha mahsulotlarni o'chirib tashlang. Food kategoriyasidagi quantity 50 dan kam bo'lgan mahsulotlarni o'chiring. TechStore yetkazib beruvchidan bo'lgan va price 1000 dan yuqori mahsulotlarni o'chirib tashlang. Electronics kategoriyasidagi price 100 dan kam bo'lgan barcha mahsulotlarni o'chirib tashlang. Clothing kategoriyasidagi price 30 dan kam yoki teng bo'lgan mahsulotlarni o'chiring. Task 4 Sizda students nomli jadval mavjud. Jadval quyidagi ustunlardan iborat: id (integer) - talaba ID (asosiy kalit, PRIMARY KEY) name (varchar) - talabaning ismi age (integer) - talabaning yoshi gender (varchar) - talabaning jinsi (Male, Female) grade (integer) - talabaning umumiy bahosi (0 dan 100 gacha) city (varchar) - talaba yashaydigan shahar scholarship (varchar) - talabaning stipendiyasi bor yoki yo'qligi (Yes, No) id name age gender grade city scholarship 1 Ali 19 Male 85 Tashkent Yes 2 Laylo 20 Female 90 Samarkand Yes 3 Jasur 18 Male 40 Bukhara No 4 Malika 22 Female 75 Tashkent Yes 5 Timur 21 Male 50 Andijan No 6 Zarina 20 Female 30 Tashkent No 7 Shoxruh 19 Male 65 Nukus Yes 8 Nargiza 23 Female 70 Bukhara No 9 Davron 20 Male 55 Tashkent No 10 Sabina 19 Female 35 Andijan No Tasks grade 50 dan past bo'lgan barcha talabalarni o'chiring. city \"Tashkent\" bo'lgan va stipendiyasi yo'q ( scholarship = 'No' ) bo'lgan barcha talabalarni o'chiring. age 20 dan katta va grade 60 dan yuqori bo'lgan barcha talabalarni o'chirib tashlang. scholarship \"Yes\" bo'lgan va city \"Samarkand\" bo'lgan talabalarni o'chiring. gender \"Male\" bo'lgan va grade 70 dan past bo'lgan barcha talabalarni o'chirib tashlang. Barcha talabalarning ma'lumotlarini o'chiring, agar ular \"Andijan\" shahridan bo'lsa.","title":"Data Manipulation"},{"location":"psql/data-manipulation/#data-manipulation","text":"Topics: Updating records with UPDATE Deleting records with DELETE Managing data integrity with constraints (foreign keys, unique) Transactions and rollback","title":"\ud83d\udc18 Data Manipulation"},{"location":"psql/data-manipulation/#updating-records-with-update","text":"[!NOTE] PostgreSQLda ma'lumotlarni yangilash uchun UPDATE operatoridan foydalaniladi. Bu operator jadvaldagi mavjud malumotlarni yangilash uchun ishlatiladi.","title":"Updating records with UPDATE"},{"location":"psql/data-manipulation/#syntax-of-update","text":"UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; Key Points: SET : Qaysi ustunni yangi qiymat bilan yangilashni belgilaydi. WHERE : Qaysi malumotni yangilashni aniqlash uchun ishlatiladi. Agar WHERE shartini qo'shmasangiz, jadvaldagi barcha malumotlar yangilanadi. Conditions : Agar kerak bo'lsa, bir nechta shartlarni birlashtirish uchun AND, OR mantiqiy operatorlarini ishlatish mumkin. client_id first_name last_name date_of_birth email phone address city country postal_code registration_date last_activity_date balance status 1 Ali Karimov 1990-01-01 ali.karimov@mail.uz +99890123456 Tashkent, Block 15 Tashkent Uzbekistan 100100 2024-01-01 2024-12-01 150.50 TRUE 2 Dilnoza Tursunova 1985-05-12 dilnoza@mail.uz +99890123457 Samarkand, Block 7 Samarkand Uzbekistan 140200 2024-02-15 2024-11-20 0.00 FALSE 3 Bekzod Rasulov 1992-03-22 bekzod@mail.uz +99890123458 Bukhara, Block 9 Bukhara Uzbekistan 200300 2024-05-10 2024-10-30 250.75 TRUE Basic Update Example id = 2 bo'lgan clientni city ustunini Navoiy ga o'zgartiramiz: UPDATE clients SET city = 'Navoiy' WHERE client_id = 2; Updating Multiple Columns Agar bir vaqtning o'zida bir nechta ustunlarni yangilash kerak bo'lsa: UPDATE clients SET city = 'Navoiy', balance = 250.75 WHERE first_name = 'Ali'; Updating All Rows Agar jadvaldagi barcha qatorlarni yangilash kerak bo'lsa: UPDATE clients SET city = 'Navoiy'; Conditional Updates with AND and OR city = 'Toshkent' va status = TRUE bo'lgan clientning phone ustunini +998930850955 ga o'zgartiramiz: UPDATE clients SET phone = '+998930850955' WHERE city = 'Toshkent' AND status = TRUE;","title":"Syntax of UPDATE:"},{"location":"psql/data-manipulation/#deleting-records-with-delete","text":"[!NOTE] PostgreSQLda ma'lumotlarni o'chirish uchun DELETE operatoridan foydalaniladi.","title":"Deleting records with DELETE"},{"location":"psql/data-manipulation/#syntax-of-the-delete-statement","text":"DELETE FROM table_name WHERE condition; table_name : O'chirish amalga oshiriladigan jadval nomi. condition : Qaysi satrlarni o'chirish kerakligini belgilaydigan shart. [!CAUTION] Agar WHERE sharti ko'rsatilmasa, jadvaldagi barcha yozuvlar o'chiriladi. Bunda ehtiyot bo'lish kerak! Deleting specific records based on a condition Agar jadvaldan faqat aniq bir shartga mos malumotni o'chirish kerak bo'lsa, WHERE sharti qo'llaniladi. DELETE FROM clients WHERE client_id = 2; Deleting all records Agar barcha malumotlarni o'chirish kerak bo'lsa, WHERE sharti berilmaydi. DELETE FROM clients;","title":"Syntax of the DELETE Statement"},{"location":"psql/data-manipulation/#managing-data-integrity-with-constraints-foreign-keys-unique","text":"","title":"Managing data integrity with constraints (foreign keys, unique)"},{"location":"psql/data-manipulation/#foreign-key","text":"Foreign key bir jadvaldagi ustun boshqa jadvaldagi ustunga bog'liq bo'lishini ta'minlaydi. Bu jadvallarni bir biriga bog'lash uchun ishlatiladi ishlatiladi.","title":"Foreign Key"},{"location":"psql/data-manipulation/#customers-table","text":"customer_id name email 1 Anvar Aliyev aliyev@example.com 2 Nodira Karimova karimova@example.com","title":"Customers Table"},{"location":"psql/data-manipulation/#orders-table","text":"order_id customer_id order_date amount 1 1 2024-12-25 150.00 2 2 2024-12-26 200.50 -- Creating the Customers table CREATE TABLE customers ( customer_id SERIAL PRIMARY KEY, -- Primary key name VARCHAR(100) NOT NULL, email VARCHAR(100) UNIQUE NOT NULL -- Email must be unique ); -- Creating the Orders table CREATE TABLE orders ( order_id SERIAL PRIMARY KEY, -- Primary key customer_id INT NOT NULL, order_date DATE NOT NULL, amount NUMERIC(10, 2) NOT NULL, CONSTRAINT fk_customer FOREIGN KEY (customer_id) REFERENCES customers (customer_id) ON DELETE CASCADE );","title":"Orders Table"},{"location":"psql/data-manipulation/#practics","text":"","title":"PRACTICS"},{"location":"psql/data-manipulation/#task-1","text":"Sizda students nomli jadval mavjud. Jadvalda quyidagi ustunlar bor: id (integer) - talabalar id raqamlari (PRIMARY KEY) name (varchar) - talabaning ismi age (integer) - talabaning yoshi grade (varchar) - talabaning bahosi (masalan, A, B, C, D) city (varchar) - talabaning yashash shahri","title":"Task 1"},{"location":"psql/data-manipulation/#data","text":"id name age grade city 1 Ali 19 B Tashkent 2 Salim 18 C Samarkand 3 Malika 20 A Bukhara 4 Shoxruh 21 D Tashkent 5 Laylo 22 C Nukus","title":"Data"},{"location":"psql/data-manipulation/#tasks","text":"Tashkent shahrida yashovchi barcha talabalarni toping va ularning grade ustunini B ga o'zgartiring. Yoshi 20 yoki undan katta bo'lgan talabalarni toping va ularning yashash shahrini Tashkent ga o'zgartiring. grade ustuni C bo'lgan barcha talabalar uchun age ni 1 yoshga oshiring.","title":"Tasks"},{"location":"psql/data-manipulation/#task-2","text":"Sizda employees nomli jadval bor. Jadvalda quyidagi ustunlar mavjud: id (integer) - xodimning id raqami (asosiy kalit, PRIMARY KEY) name (varchar) - xodimning ismi department (varchar) - xodim ishlaydigan bo'lim (masalan, HR, IT, Sales) salary (integer) - xodimning oyligi experience (integer) - xodimning ish tajribasi (yillarda) city (varchar) - xodim yashayotgan shahar","title":"Task 2"},{"location":"psql/data-manipulation/#data_1","text":"id name department salary experience city 1 Nodir IT 1200 3 Tashkent 2 Malika HR 900 5 Samarkand 3 Shoxruh Sales 1500 7 Bukhara 4 Laylo IT 1000 2 Nukus 5 Kamol HR 850 6 Tashkent 6 Saida Sales 1100 4 Andijan","title":"Data"},{"location":"psql/data-manipulation/#tasks_1","text":"Toshkent shahridagi barcha xodimlarning oyliklarini 10% ga oshiring. Tajribasi 5 yildan oshgan xodimlarni toping va ularning bo'limini \"Senior\" qilib yangilang. Oyligi 1000 dan kam bo'lgan barcha xodimlarni toping va ularning oyligini 950 ga o'zgartiring. \"Sales\" bo'limida ishlaydigan xodimlarning shaharlarini \"Tashkent\" qilib yangilang. \"IT\" bo'limida ishlaydigan, tajribasi 3 yildan kam bo'lgan xodimlarning oyliklarini 20% ga oshiring.","title":"Tasks"},{"location":"psql/data-manipulation/#task-3","text":"Sizda products nomli jadval mavjud. Jadval quyidagi ustunlardan iborat: id (integer) - mahsulot ID (asosiy kalit, PRIMARY KEY) name (varchar) - mahsulot nomi category (varchar) - mahsulot kategoriyasi (masalan, Electronics, Clothing, Food) price (integer) - mahsulot narxi quantity (integer) - mahsulot ombordagi miqdori supplier (varchar) - yetkazib beruvchi nomi id name category price quantity supplier 1 Laptop Electronics 1200 10 TechStore 2 T-Shirt Clothing 25 50 FashionHub 3 Phone Electronics 800 5 TechStore 4 Bread Food 2 100 FoodMart 5 TV Electronics 500 2 HomeAppliance 6 Jacket Clothing 60 20 FashionHub 7 Milk Food 1 200 FoodMart 8 Tablet Electronics 300 0 TechStore 9 Headphones Electronics 50 15 AudioWorld 10 Sneakers Clothing 80 0 FashionHub","title":"Task 3"},{"location":"psql/data-manipulation/#tasks_2","text":"quantity 0 bo'lgan barcha mahsulotlarni o'chirib tashlang. Food kategoriyasidagi quantity 50 dan kam bo'lgan mahsulotlarni o'chiring. TechStore yetkazib beruvchidan bo'lgan va price 1000 dan yuqori mahsulotlarni o'chirib tashlang. Electronics kategoriyasidagi price 100 dan kam bo'lgan barcha mahsulotlarni o'chirib tashlang. Clothing kategoriyasidagi price 30 dan kam yoki teng bo'lgan mahsulotlarni o'chiring.","title":"Tasks"},{"location":"psql/data-manipulation/#task-4","text":"Sizda students nomli jadval mavjud. Jadval quyidagi ustunlardan iborat: id (integer) - talaba ID (asosiy kalit, PRIMARY KEY) name (varchar) - talabaning ismi age (integer) - talabaning yoshi gender (varchar) - talabaning jinsi (Male, Female) grade (integer) - talabaning umumiy bahosi (0 dan 100 gacha) city (varchar) - talaba yashaydigan shahar scholarship (varchar) - talabaning stipendiyasi bor yoki yo'qligi (Yes, No) id name age gender grade city scholarship 1 Ali 19 Male 85 Tashkent Yes 2 Laylo 20 Female 90 Samarkand Yes 3 Jasur 18 Male 40 Bukhara No 4 Malika 22 Female 75 Tashkent Yes 5 Timur 21 Male 50 Andijan No 6 Zarina 20 Female 30 Tashkent No 7 Shoxruh 19 Male 65 Nukus Yes 8 Nargiza 23 Female 70 Bukhara No 9 Davron 20 Male 55 Tashkent No 10 Sabina 19 Female 35 Andijan No","title":"Task 4"},{"location":"psql/data-manipulation/#tasks_3","text":"grade 50 dan past bo'lgan barcha talabalarni o'chiring. city \"Tashkent\" bo'lgan va stipendiyasi yo'q ( scholarship = 'No' ) bo'lgan barcha talabalarni o'chiring. age 20 dan katta va grade 60 dan yuqori bo'lgan barcha talabalarni o'chirib tashlang. scholarship \"Yes\" bo'lgan va city \"Samarkand\" bo'lgan talabalarni o'chiring. gender \"Male\" bo'lgan va grade 70 dan past bo'lgan barcha talabalarni o'chirib tashlang. Barcha talabalarning ma'lumotlarini o'chiring, agar ular \"Andijan\" shahridan bo'lsa.","title":"Tasks"},{"location":"psql/data-retrieval-end-filtering/","text":"\ud83d\udc18 Data Retrieval and Filtering Topics: SELECT statement with WHERE clause Operators and conditions( = , < , > , AND , OR , NOT ) Sorting data with ORDER BY Limiting results with LIMIT SELECT STATEMENT WITH WHERE CLAUSE [!NOTE] SELECT operatori va WHERE sharti yordamida database dan aniq shartlarga mos keladigan ma'lumotlarni tanlash mumkin. SELECT STATEMENT SELECT SQLning eng asosiy operatorlaridan biri bo'lib, database dan ma'lumotlarni olish uchun ishlatiladi. Basic syntax: SELECT column1, column2, ... FROM table_name; column1, column2, ...: Qaysi ustunlarni tanlash kerakligini ko'rsatadi. Agar barcha ustunlarni tanlash kerak bo'lsa, * ishlatiladi. table_name: Ma'lumot olingan jadvalning nomi. WHERE CLAUSE WHERE ma'lum bir shartlarga asoslanib, qatorlarni filtrlaydi. Faqat WHERE shartiga mos keladigan qatorlar qaytariladi. Basic Examples: Malum bir shartga mos keladigan qatorlarni olish Foydalanuvchilarning faqat 30 yoshdagilarini olish: SELECT name, age FROM users WHERE age = 30; Shartlar kombinatsiyasi AND va OR 30 yoshdan katta va faqat \"Toshkent\" shahrida yashaydigan foydalanuvchilarni olish: SELECT name, city, age FROM users WHERE age > 30 AND city = 'Toshkent'; Ma'lum bir oraliqda bo'lgan ma'lumotlarni olish Yoshi 25 dan 40 gacha bo'lgan foydalanuvchilarni olish: SELECT name, age FROM users WHERE age BETWEEN 25 AND 40; Ma'lumotlarni o'xshashlik bilan qidirish LIKE \"Ali\" bilan boshlanadigan ismlarni qidirish: SELECT name FROM users WHERE name LIKE 'Ali%'; NULL qiymatlarni qidirish Telefon raqami kiritilmagan foydalanuvchilarni olish: SELECT name, phone FROM users WHERE phone IS NULL; Additional Concepts = : Checks equality > or < : Checks greater than or less than. != or <> : Checks inequality. IN : Checks if a value exists within a set of specified values. Example: Using IN Find users living in \"Tashkent\" , \"Samarkand\" , or \"Bukhara\" : SELECT name, city FROM users WHERE city IN ('Tashkent', 'Samarkand', 'Bukhara'); OPERATORS AND CONDITIONS = , < , > , AND , OR , NOT [!NOTE] SQL operatorlari va shartlari yordamida ma'lumotlarni filtrlash , solishtirish va boshqarish mumkin. Equality Operators = : Checks if values are equal. Example: SELECT name, age FROM users WHERE age = 25; Explanation : Returns users whose age is exactly 25. != or <> : Checks if values are not equal. Example: SELECT name, age FROM users WHERE age != 25; Explanation : Returns users whose age is not 25. Comparison Operators > : Finds values greater than the specified value. Example: SELECT name, age FROM users WHERE age > 30; < : Finds values less than the specified value Example: SELECT name, age FROM users WHERE age < 18; Explanation : Returns users younger than 18. >= : Finds values greater than or equal to the specified value. Example: SELECT name, age FROM users WHERE age >= 21; <= : Finds values less than or equal to the specified value. Example: SELECT name, age FROM users WHERE age <= 60; Logical Operators Mantiqiy operatorlar yordamida bir nechta shartlarni birlashtirish mumkin. AND Bir nechta shartlarning barchasi bajarilishini talab qiladi. Example: SELECT name, age, city FROM users WHERE age > 25 AND city = 'Tashkent'; Combining Conditions AND , OR , va NOT operatorlari birgalikda ishlatilishi mumkin. Shartlarni o'qish oson bo'lishi uchun qavslar ishlatiladi. Example: SELECT name, age, city FROM users WHERE (age > 30 AND city = 'Tashkent') OR NOT age = 25; Explanation: 30 yoshdan katta va \"Toshkent\" shahrida yashovchilar yoki 25 yoshda bo'lmagan foydalanuvchilarni qaytaradi. Additional Operators BETWEEN : Ma'lum bir oraliqdagi qiymatlarni tanlash. Example: SELECT name, age FROM users WHERE age BETWEEN 20 AND 30; Explanation: 20 dan 30 yoshgacha bo'lgan foydalanuvchilarni qaytaradi. IN : Bir nechta qiymatlar ro'yxatiga mos kelishini tekshiradi. SELECT name, city FROM users WHERE city IN ('Tashkent', 'Samarkand', 'Bukhara'); Explanation: Foydalanuvchilar \"Toshkent\", \"Samarqand\" yoki \"Buxoro\" shahrida yashashi kerak. LIKE : Qismiy moslikni tekshiradi (for string). % : Belgilar ketma-ketligini ifodalaydi. _ : Bitta belgini bildiradi. SELECT name FROM users WHERE name LIKE 'A%'; Explanation: Ismi \"A\" harfi bilan boshlanadigan foydalanuvchilarni qaytaradi. SORTING DATA WITH ORDER BY [!NOTE] ORDER BY operatori ma'lumotlarni saralashda ishlatiladi. Bu operator ma'lumotlarni ascending (o'sish tartibida) yoki descending (kamayish tartibida) tartiblash imkoniyatini beradi. GENERAL SYNTAX SELECT column1, column2, ... FROM table_name ORDER BY column_name [ASC | DESC]; ASC : Ma'lumotlarni o'sish tartibida saralaydi (standart qiymat). DESC : Ma'lumotlarni kamayish tartibida saralaydi. EXAMPLES WITH EXPLANATION Simple Sorting Aytaylik, students jadvalimiz bor va unda quyidagi ma'lumotlar saqlanadi: id name score 1 Ali 85 2 Umid 92 3 Bekzod 74 4 Shirin 88 O'sish tartibida saralash Quyidagi SQL so'rovi ma'lumotlarni score ustuniga qarab o'sish tartibida saralaydi: SELECT * FROM students ORDER BY score ASC; Result : id name score 3 Bekzod 74 1 Ali 85 4 Shirin 88 2 Umid 92 Kamayish tartibida saralash Quyidagi so'rov ma'lumotlarni score ustuniga qarab kamayish tartibida saralaydi: SELECT * FROM students ORDER BY score DESC; Result : id name score 2 Umid 92 4 Shirin 88 1 Ali 85 3 Bekzod 74 Sorting by Multiple Columns Agar bir nechta ustunlar bo'yicha saralash kerak bo'lsa, ular ketma-ket yoziladi. Example: name ustuni bo'yicha alfavit tartibida, agar ism bir xil bo'lsa, score kamayish tartibida saralanadi: SELECT * FROM students ORDER BY name ASC, score DESC; id name score 1 Ali 85 3 Bekzod 74 4 Shirin 88 2 Umid 92 Limiting Results with Sorting Agar faqat eng yuqori 3 ta natijani olish kerak bo'lsa: Example: SELECT * FROM students ORDER BY score DESC LIMIT 3; id name score 2 Umid 92 4 Shirin 88 1 Ali 85 Handling NULL Values Agar jadvalda NULL qiymatlar bo'lsa, PostgreSQL ularni saralashda oxirida yoki boshida joylashtiradi. Buni boshqarish uchun NULLS FIRST yoki NULLS LAST ishlatiladi. Example: id name score 1 Ali 85 2 Umid 92 3 Bekzod NULL 4 Shirin 88 Saralashda NULL qiymatlarni boshiga qo'yish: SELECT * FROM students ORDER BY score ASC NULLS FIRST; id name score 3 Bekzod NULL 1 Ali 85 4 Shirin 88 2 Umid 92 LIMITING RESULTS WITH LIMIT [!NOTE] LIMIT operatori ma\u02bclumotlarni qaytarishda ma\u02bclum bir son bilan cheklash uchun ishlatiladi. Bu, ayniqsa, ko\u2018p sonli natijalar bilan ishlaganda muhimdir, chunki LIMIT operatori faqat kerakli miqdordagi yozuvlarni qaytarishga imkon beradi. LIMIT Syntax SELECT column1, column2, ... FROM table_name LIMIT number_of_rows; number_of_rows : Natijalar orasidan nechta yozuvni qaytarish kerakligini belgilaydi. Fetching the First 5 Rows Tasavvur qilaylik, bizda students jadvali bor, va u quyidagi ustunlarni o\u2018z ichiga oladi: id , name , va score . Example: SELECT id, name, score FROM students LIMIT 5; Bu so\u2018rov students jadvalidan birinchi 5 ta row ni qaytaradi. Using LIMIT with Sorting Birinchi eng yuqori baholangan 3 nafar talabani ko\u2018rish uchun: SELECT id, name, score FROM students ORDER BY score DESC LIMIT 3; ORDER BY score DESC : Yozuvlarni eng yuqori bahodan pastga qarab tartiblaydi. LIMIT 3 : Faqat 3 ta natijani qaytaradi. Combining LIMIT and OFFSET OFFSET operatori natijalardagi ma\u02bclum bir sonli yozuvlarni o\u2018tkazib yuborishga imkon beradi. Masalan, 6- row dan boshlab keyingi 5 ta row ni olish uchun: SELECT id, name, score FROM students ORDER BY score DESC LIMIT 5 OFFSET 5; LIMIT 5 : Faqat 5 ta row ni qaytaradi. OFFSET 5 : Birinchi 5 ta row ni o\u2018tkazib yuboradi. Using LIMIT with WHERE Faqat bahosi 80 dan katta bo\u2018lgan talabalarning birinchi 3 tasini olish: SELECT id, name, score FROM students WHERE score > 80 ORDER BY score DESC LIMIT 3; LIMIT with Aggregate Functions Birinchi 10 ta talabaning o\u2018rtacha bahosini hisoblash: SELECT AVG(score) AS average_score FROM ( SELECT score FROM students ORDER BY score DESC LIMIT 10 ) AS top_students; Bu so\u2018rov eng yuqori baholangan 10 talabaning o\u2018rtacha bahosini qaytaradi. PRACTICS Here are some tasks based on the SELECT statement with the WHERE clause, along with a sample database structure: SAMPLE TABLE: employees id name department salary hire_data 1 Alice HR 500 2021-01-15 2 Bob IT 7000 2020-03-20 3 Charlie IT 6500 2019-07-01 4 Diana Marketing 6000 2022-05-12 5 Edward HR 5500 2020-09-30 TASKS Basic Filtering IT bo\u2018limida ishlaydigan xodimlarni toping. Expected Output: Rows with Bob and Charlie . Filtering with Numbers Maoshi 6000 dan katta bo\u2018lgan xodimlarni toping. Expected Output: Rows with Bob and Charlie . Filtering with Dates 2020-yilning 1-yanvaridan keyin ishga qabul qilingan xodimlarni toping. Expected Output: Rows with Alice , Diana , and Edward . Combining Conditions HR bo\u2018limida ishlaydigan va maoshi 6000 dan kam bo\u2018lgan xodimlarni toping. Expected Output: Rows with Alice and Edward . Using OR in Conditions HR yoki Marketing bo\u2018limida ishlaydigan xodimlarni toping. Expected Output: Rows with Alice , Diana , and Edward . Negating Conditions IT bo\u2018limida ishlamaydigan xodimlarni toping. Expected Output: Rows with Alice , Diana , and Edward . Using Wildcards LIKE Ismi 'A' harfi bilan boshlanadigan xodimlarni toping. Expected Output: Row with Alice . Using IN Clause IT yoki HR bo\u2018limida ishlaydigan xodimlarni toping. Expected Output : Rows with Alice , Bob , Charlie , and Edward . Using BETWEEN Clause Maoshi 5000 va 6000 orasida bo\u2018lgan xodimlarni toping. Expected Output: Rows with Alice , Diana , and Edward . Case Sensitivity in Filtering Ismi aniq 'diana' (kichik harflar bilan) bo\u2018lgan xodimlarni toping. (Agar ma\u2019lumotlar bazasi katta-kichik harfga sezgir bo\u2018lsa.) Expected Output: No rows (if names are stored case-sensitive).","title":"Data Retrieval and Filtering"},{"location":"psql/data-retrieval-end-filtering/#data-retrieval-and-filtering","text":"Topics: SELECT statement with WHERE clause Operators and conditions( = , < , > , AND , OR , NOT ) Sorting data with ORDER BY Limiting results with LIMIT","title":"\ud83d\udc18 Data Retrieval and Filtering"},{"location":"psql/data-retrieval-end-filtering/#select-statement-with-where-clause","text":"[!NOTE] SELECT operatori va WHERE sharti yordamida database dan aniq shartlarga mos keladigan ma'lumotlarni tanlash mumkin.","title":"SELECT STATEMENT WITH WHERE CLAUSE"},{"location":"psql/data-retrieval-end-filtering/#select-statement","text":"SELECT SQLning eng asosiy operatorlaridan biri bo'lib, database dan ma'lumotlarni olish uchun ishlatiladi. Basic syntax: SELECT column1, column2, ... FROM table_name; column1, column2, ...: Qaysi ustunlarni tanlash kerakligini ko'rsatadi. Agar barcha ustunlarni tanlash kerak bo'lsa, * ishlatiladi. table_name: Ma'lumot olingan jadvalning nomi.","title":"SELECT STATEMENT"},{"location":"psql/data-retrieval-end-filtering/#where-clause","text":"WHERE ma'lum bir shartlarga asoslanib, qatorlarni filtrlaydi. Faqat WHERE shartiga mos keladigan qatorlar qaytariladi. Basic Examples: Malum bir shartga mos keladigan qatorlarni olish Foydalanuvchilarning faqat 30 yoshdagilarini olish: SELECT name, age FROM users WHERE age = 30; Shartlar kombinatsiyasi AND va OR 30 yoshdan katta va faqat \"Toshkent\" shahrida yashaydigan foydalanuvchilarni olish: SELECT name, city, age FROM users WHERE age > 30 AND city = 'Toshkent'; Ma'lum bir oraliqda bo'lgan ma'lumotlarni olish Yoshi 25 dan 40 gacha bo'lgan foydalanuvchilarni olish: SELECT name, age FROM users WHERE age BETWEEN 25 AND 40; Ma'lumotlarni o'xshashlik bilan qidirish LIKE \"Ali\" bilan boshlanadigan ismlarni qidirish: SELECT name FROM users WHERE name LIKE 'Ali%'; NULL qiymatlarni qidirish Telefon raqami kiritilmagan foydalanuvchilarni olish: SELECT name, phone FROM users WHERE phone IS NULL; Additional Concepts = : Checks equality > or < : Checks greater than or less than. != or <> : Checks inequality. IN : Checks if a value exists within a set of specified values. Example: Using IN Find users living in \"Tashkent\" , \"Samarkand\" , or \"Bukhara\" : SELECT name, city FROM users WHERE city IN ('Tashkent', 'Samarkand', 'Bukhara');","title":"WHERE CLAUSE"},{"location":"psql/data-retrieval-end-filtering/#operators-and-conditions-and-or-not","text":"[!NOTE] SQL operatorlari va shartlari yordamida ma'lumotlarni filtrlash , solishtirish va boshqarish mumkin. Equality Operators = : Checks if values are equal. Example: SELECT name, age FROM users WHERE age = 25; Explanation : Returns users whose age is exactly 25. != or <> : Checks if values are not equal. Example: SELECT name, age FROM users WHERE age != 25; Explanation : Returns users whose age is not 25. Comparison Operators > : Finds values greater than the specified value. Example: SELECT name, age FROM users WHERE age > 30; < : Finds values less than the specified value Example: SELECT name, age FROM users WHERE age < 18; Explanation : Returns users younger than 18. >= : Finds values greater than or equal to the specified value. Example: SELECT name, age FROM users WHERE age >= 21; <= : Finds values less than or equal to the specified value. Example: SELECT name, age FROM users WHERE age <= 60; Logical Operators Mantiqiy operatorlar yordamida bir nechta shartlarni birlashtirish mumkin. AND Bir nechta shartlarning barchasi bajarilishini talab qiladi. Example: SELECT name, age, city FROM users WHERE age > 25 AND city = 'Tashkent'; Combining Conditions AND , OR , va NOT operatorlari birgalikda ishlatilishi mumkin. Shartlarni o'qish oson bo'lishi uchun qavslar ishlatiladi. Example: SELECT name, age, city FROM users WHERE (age > 30 AND city = 'Tashkent') OR NOT age = 25; Explanation: 30 yoshdan katta va \"Toshkent\" shahrida yashovchilar yoki 25 yoshda bo'lmagan foydalanuvchilarni qaytaradi. Additional Operators BETWEEN : Ma'lum bir oraliqdagi qiymatlarni tanlash. Example: SELECT name, age FROM users WHERE age BETWEEN 20 AND 30; Explanation: 20 dan 30 yoshgacha bo'lgan foydalanuvchilarni qaytaradi. IN : Bir nechta qiymatlar ro'yxatiga mos kelishini tekshiradi. SELECT name, city FROM users WHERE city IN ('Tashkent', 'Samarkand', 'Bukhara'); Explanation: Foydalanuvchilar \"Toshkent\", \"Samarqand\" yoki \"Buxoro\" shahrida yashashi kerak. LIKE : Qismiy moslikni tekshiradi (for string). % : Belgilar ketma-ketligini ifodalaydi. _ : Bitta belgini bildiradi. SELECT name FROM users WHERE name LIKE 'A%'; Explanation: Ismi \"A\" harfi bilan boshlanadigan foydalanuvchilarni qaytaradi.","title":"OPERATORS AND CONDITIONS =, &lt;, &gt;, AND, OR, NOT"},{"location":"psql/data-retrieval-end-filtering/#sorting-data-with-order-by","text":"[!NOTE] ORDER BY operatori ma'lumotlarni saralashda ishlatiladi. Bu operator ma'lumotlarni ascending (o'sish tartibida) yoki descending (kamayish tartibida) tartiblash imkoniyatini beradi.","title":"SORTING DATA WITH ORDER BY"},{"location":"psql/data-retrieval-end-filtering/#general-syntax","text":"SELECT column1, column2, ... FROM table_name ORDER BY column_name [ASC | DESC]; ASC : Ma'lumotlarni o'sish tartibida saralaydi (standart qiymat). DESC : Ma'lumotlarni kamayish tartibida saralaydi.","title":"GENERAL SYNTAX"},{"location":"psql/data-retrieval-end-filtering/#examples-with-explanation","text":"Simple Sorting Aytaylik, students jadvalimiz bor va unda quyidagi ma'lumotlar saqlanadi: id name score 1 Ali 85 2 Umid 92 3 Bekzod 74 4 Shirin 88 O'sish tartibida saralash Quyidagi SQL so'rovi ma'lumotlarni score ustuniga qarab o'sish tartibida saralaydi: SELECT * FROM students ORDER BY score ASC; Result : id name score 3 Bekzod 74 1 Ali 85 4 Shirin 88 2 Umid 92 Kamayish tartibida saralash Quyidagi so'rov ma'lumotlarni score ustuniga qarab kamayish tartibida saralaydi: SELECT * FROM students ORDER BY score DESC; Result : id name score 2 Umid 92 4 Shirin 88 1 Ali 85 3 Bekzod 74 Sorting by Multiple Columns Agar bir nechta ustunlar bo'yicha saralash kerak bo'lsa, ular ketma-ket yoziladi. Example: name ustuni bo'yicha alfavit tartibida, agar ism bir xil bo'lsa, score kamayish tartibida saralanadi: SELECT * FROM students ORDER BY name ASC, score DESC; id name score 1 Ali 85 3 Bekzod 74 4 Shirin 88 2 Umid 92 Limiting Results with Sorting Agar faqat eng yuqori 3 ta natijani olish kerak bo'lsa: Example: SELECT * FROM students ORDER BY score DESC LIMIT 3; id name score 2 Umid 92 4 Shirin 88 1 Ali 85 Handling NULL Values Agar jadvalda NULL qiymatlar bo'lsa, PostgreSQL ularni saralashda oxirida yoki boshida joylashtiradi. Buni boshqarish uchun NULLS FIRST yoki NULLS LAST ishlatiladi. Example: id name score 1 Ali 85 2 Umid 92 3 Bekzod NULL 4 Shirin 88 Saralashda NULL qiymatlarni boshiga qo'yish: SELECT * FROM students ORDER BY score ASC NULLS FIRST; id name score 3 Bekzod NULL 1 Ali 85 4 Shirin 88 2 Umid 92","title":"EXAMPLES WITH EXPLANATION"},{"location":"psql/data-retrieval-end-filtering/#limiting-results-with-limit","text":"[!NOTE] LIMIT operatori ma\u02bclumotlarni qaytarishda ma\u02bclum bir son bilan cheklash uchun ishlatiladi. Bu, ayniqsa, ko\u2018p sonli natijalar bilan ishlaganda muhimdir, chunki LIMIT operatori faqat kerakli miqdordagi yozuvlarni qaytarishga imkon beradi. LIMIT Syntax SELECT column1, column2, ... FROM table_name LIMIT number_of_rows; number_of_rows : Natijalar orasidan nechta yozuvni qaytarish kerakligini belgilaydi. Fetching the First 5 Rows Tasavvur qilaylik, bizda students jadvali bor, va u quyidagi ustunlarni o\u2018z ichiga oladi: id , name , va score . Example: SELECT id, name, score FROM students LIMIT 5; Bu so\u2018rov students jadvalidan birinchi 5 ta row ni qaytaradi. Using LIMIT with Sorting Birinchi eng yuqori baholangan 3 nafar talabani ko\u2018rish uchun: SELECT id, name, score FROM students ORDER BY score DESC LIMIT 3; ORDER BY score DESC : Yozuvlarni eng yuqori bahodan pastga qarab tartiblaydi. LIMIT 3 : Faqat 3 ta natijani qaytaradi. Combining LIMIT and OFFSET OFFSET operatori natijalardagi ma\u02bclum bir sonli yozuvlarni o\u2018tkazib yuborishga imkon beradi. Masalan, 6- row dan boshlab keyingi 5 ta row ni olish uchun: SELECT id, name, score FROM students ORDER BY score DESC LIMIT 5 OFFSET 5; LIMIT 5 : Faqat 5 ta row ni qaytaradi. OFFSET 5 : Birinchi 5 ta row ni o\u2018tkazib yuboradi. Using LIMIT with WHERE Faqat bahosi 80 dan katta bo\u2018lgan talabalarning birinchi 3 tasini olish: SELECT id, name, score FROM students WHERE score > 80 ORDER BY score DESC LIMIT 3; LIMIT with Aggregate Functions Birinchi 10 ta talabaning o\u2018rtacha bahosini hisoblash: SELECT AVG(score) AS average_score FROM ( SELECT score FROM students ORDER BY score DESC LIMIT 10 ) AS top_students; Bu so\u2018rov eng yuqori baholangan 10 talabaning o\u2018rtacha bahosini qaytaradi.","title":"LIMITING RESULTS WITH LIMIT"},{"location":"psql/data-retrieval-end-filtering/#practics","text":"Here are some tasks based on the SELECT statement with the WHERE clause, along with a sample database structure:","title":"PRACTICS"},{"location":"psql/data-retrieval-end-filtering/#sample-table-employees","text":"id name department salary hire_data 1 Alice HR 500 2021-01-15 2 Bob IT 7000 2020-03-20 3 Charlie IT 6500 2019-07-01 4 Diana Marketing 6000 2022-05-12 5 Edward HR 5500 2020-09-30","title":"SAMPLE TABLE: employees"},{"location":"psql/data-retrieval-end-filtering/#tasks","text":"Basic Filtering IT bo\u2018limida ishlaydigan xodimlarni toping. Expected Output: Rows with Bob and Charlie . Filtering with Numbers Maoshi 6000 dan katta bo\u2018lgan xodimlarni toping. Expected Output: Rows with Bob and Charlie . Filtering with Dates 2020-yilning 1-yanvaridan keyin ishga qabul qilingan xodimlarni toping. Expected Output: Rows with Alice , Diana , and Edward . Combining Conditions HR bo\u2018limida ishlaydigan va maoshi 6000 dan kam bo\u2018lgan xodimlarni toping. Expected Output: Rows with Alice and Edward . Using OR in Conditions HR yoki Marketing bo\u2018limida ishlaydigan xodimlarni toping. Expected Output: Rows with Alice , Diana , and Edward . Negating Conditions IT bo\u2018limida ishlamaydigan xodimlarni toping. Expected Output: Rows with Alice , Diana , and Edward . Using Wildcards LIKE Ismi 'A' harfi bilan boshlanadigan xodimlarni toping. Expected Output: Row with Alice . Using IN Clause IT yoki HR bo\u2018limida ishlaydigan xodimlarni toping. Expected Output : Rows with Alice , Bob , Charlie , and Edward . Using BETWEEN Clause Maoshi 5000 va 6000 orasida bo\u2018lgan xodimlarni toping. Expected Output: Rows with Alice , Diana , and Edward . Case Sensitivity in Filtering Ismi aniq 'diana' (kichik harflar bilan) bo\u2018lgan xodimlarni toping. (Agar ma\u2019lumotlar bazasi katta-kichik harfga sezgir bo\u2018lsa.) Expected Output: No rows (if names are stored case-sensitive).","title":"TASKS"},{"location":"psql/function-and-aggregation/","text":"\ud83d\udc18 Advanced Data Retrieval with Functions and Aggregation Topics: Using PostgreSQL functions COUNT , SUM , AVG , MIN , MAX Grouping data with GROUP BY Filtering grouped data with HAVING [!NOTE] PostgreSQL da murakkab so\u02bbrovlar va ma\u02bclumotlarni samarali boshqarish aggregation functions hamda advanced functions ni ishlatishni talab qiladi. USING PostgreSQL FUNCTIONS COUNT , SUM , AVG , MIN , MAX Aggregate Functions Agregatsiya funksiyalari bir necha qator ustida hisob-kitob olib boradi va bitta natija qaytaradi. COUNT() : Counts rows. SUM() : Calculates the total sum. AVG() : Calculates the average. MAX() and MIN() : Find the highest and lowest values. employee_id first_name last_name department salary 1 Ali Valiyev IT 3000 2 Sara Ahmedova HR 2500 3 Olim Nazarov IT 4000 4 Kamola Ismatova Finance 3500 5 Zafar Bekmurodov Marketing 2000 6 Anvar Karimov IT 4500 7 Lola Tursunova HR 2700 SELECT department, COUNT(*) AS employee_count, AVG(salary) AS avg_salary FROM employees GROUP BY department ORDER BY avg_salary DESC; Bu so\u02bbrov bo\u2018limlar bo\u2018yicha xodimlarni guruhlab , ularning sonini va o\u2018rtacha ish haqini hisoblaydi. Filtering Aggregated Data Agregatsiyalangan ma\u02bclumotlarni filtrlash uchun HAVING operatoridan foydalaniladi. Example: SELECT department, SUM(salary) AS total_salary FROM employees GROUP BY department HAVING SUM(salary) > 500000; Bu so\u02bbrov umumiy ish haqi 500,000 dan yuqori bo\u02bblgan bo\u2018limlarni chiqaradi. Window Functions Window functions operate on a set of rows related to the current row but do not reduce the result Example: SELECT employee_id, department, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank FROM employees; Bu so\u02bbrov har bir bo\u2018limdagi ishchilarni ish haqi bo\u02bbyicha tartiblaydi. Using Common Table Expressions CTEs CTE murakkab so\u02bbrovlarni soddalashtiradi va tushunishni osonlashtiradi. Example: WITH department_salaries AS ( SELECT department, SUM(salary) AS total_salary FROM employees GROUP BY department ) SELECT department FROM department_salaries WHERE total_salary > 500000; Bu misolda umumiy ish haqlari hisoblanib, saralangan bo\u2018limlar chiqariladi. Advanced SQL Functions PostgreSQL da ma\u02bclumotlarni boshqarish uchun juda ko\u02bbp qurilgan funksiyalar mavjud. String Functions: CONCAT() , SUBSTRING() , LOWER() , UPPER() Example: SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees; Date/Time Functions: NOW() , AGE() , DATE_PART() Example: SELECT employee_id, AGE(NOW(), hire_date) AS years_of_service FROM employees; JSON Functions: JSONB_EXTRACT_PATH_TEXT() , JSON_AGG() Example: SELECT JSON_AGG(department) AS departments FROM employees; Recursive Queries Rekursiv so\u02bbrovlar hierarchical yoki tree-structured ma\u02bclumotlar bilan ishlash imkonini beradi. Example: WITH RECURSIVE employee_hierarchy AS ( SELECT employee_id, manager_id, 1 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.employee_id, e.manager_id, eh.level + 1 FROM employees e JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id ) SELECT * FROM employee_hierarchy; Bu so\u02bbrov hierarchy of employees va ularning darajasini shakllantiradi. Combining Data with JOIN and Aggregates Aggregate Functions bir nechta jadvallar bilan ishlashda ham foydali. Example: SELECT d.department_name, COUNT(e.employee_id) AS total_employees FROM departments d LEFT JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_name; Bu har bir bo\u2018limdagi ishchilar sonini, ishchi bo\u2018lmagan bo\u2018limlarni ham qo\u2018shib, chiqaradi. GROUPING DATA WITH GROUP BY [!NOTE] GROUP BY operatori PostgreSQL da ma\u2019lumotlarni guruhlash uchun ishlatiladi. Bu operator ko\u2018pincha Aggregate Functions ( COUNT() , SUM() , AVG() , MAX() , MIN() ) bilan birgalikda qo\u2018llaniladi Syntax: SELECT column_name, aggregate_function(column_name) FROM table_name GROUP BY column_name; SIMPLE EXAMPLE: GROUPING EMPLOYEES BY DEPARTMENT Table: employees id name department salary 1 Alice HR 5000 2 Bob IT 7000 3 Charlie IT 6000 4 Diana HR 5500 5 Eve Sales 8000 Goal: Har bir bo\u2018limdagi ishchilar sonini aniqlash. Query: SELECT department, COUNT(*) AS employee_count FROM employees GROUP BY department; Result: department employee_count HR 2 IT 2 Sales 1 USING AGGREGATE FUNCTIONS Har bir bo\u2018limning o\u2018rtacha maoshi SELECT department, AVG(salary) AS average_salary FROM employees GROUP BY department; Result: department average_salary HR 5250 IT 6500 Sales 8000 Har bir bo\u2018limdagi eng katta maosh SELECT department, MAX(salary) AS max_salary FROM employees GROUP BY department; department average_salary HR 5500 IT 7000 Sales 8000 GROUPING BY MULTIPLE COLUMNS id region product revenue 1 North Laptop 15000 2 North Phone 20000 3 South Laptop 12000 4 South Phone 25000 5 East Laptop 10000 Goal: Har bir mintaqa va mahsulot bo\u2018yicha umumiy daromadni hisoblash. SELECT region, product, SUM(revenue) AS total_revenue FROM sales GROUP BY region, product; region product total_revenue North Laptop 15000 North Phone 20000 South Laptop 12000 South Phone 25000 East Laptop 10000 USING HAVING WITH GROUP BY Har bir bo\u2018limdagi ishchilar soni 1 dan katta bo\u2018lgan holatlar HAVING agregat funksiyalar natijasiga cheklov qo\u2018yish uchun ishlatiladi. SELECT department, COUNT(*) AS employee_count FROM employees GROUP BY department HAVING COUNT(*) > 1; Result: department employee_count HR 2 IT 2 FILTERING GROUPED DATA WITH HAVING [!NOTE] SQLda HAVING clause GROUP BY orqali guruhlangan ma\u02bclumotlarni filtrlash uchun ishlatiladi. WHERE clausedan farqli o\u2018laroq, HAVING faqat guruhlash va agregatsiya (masalan, COUNT() , SUM() , AVG() , MAX() , MIN() )dan keyin qo\u2018llaniladi. Syntax: SELECT column1, column2, AGGREGATE_FUNCTION(column3) FROM table_name WHERE condition GROUP BY column1, column2 HAVING aggregate_condition; Key Points: WHERE - guruhlashdan oldin qatorlarni filtrlash uchun ishlatiladi. GROUP BY - qatorlarni belgilangan ustunlarga asoslangan holda guruhlash uchun ishlatiladi. HAVING - guruhlangan ma\u02bclumotlarni agregatsiya funksiyalariga asoslangan holda filtrlash uchun ishlatiladi. Example 1: Filtering Sales Data Table: Sales Salesperson Region Sales Alice East 500 Bob East 700 Alice West 300 Bob West 400 Alice East 200 Bob East 600 Query: Umumiy sotuv miqdori 1000 dan oshgan hududlarni ko\u2018rsating. SELECT Region, SUM(Sales) AS Total_Sales FROM Sales GROUP BY Region HAVING SUM(Sales) > 1000; Result: Region Total_Sales East 2000 Example 2: Counting Employees in Departments Table: Employees EmployeeID Department Salary 1 IT 800 2 HR 500 3 IT 900 4 Sales 600 5 IT 700 6 Sales 500 Query: 2 dan ortiq xodimga ega bo\u2018lgan bo\u2018limlarni ko\u2018rsating. SELECT Department, COUNT(EmployeeID) AS Employee_Count FROM Employees GROUP BY Department HAVING COUNT(EmployeeID) > 2; Result: Department Employee_Count IT 3 Example 3: Average Salary by Department Query: O\u2018rtacha maosh 600 dan oshgan bo\u2018limlarni ko\u2018rsating. SELECT Department, AVG(Salary) AS Average_Salary FROM Employees GROUP BY Department HAVING AVG(Salary) > 600; Result: Department Average_Salary IT 800 Tasks COUNT Function: Task: students jadvalida nechta talaba borligini hisoblang. students jadvalidagi har bir guruh uchun nechta talaba borligini hisoblang ( group_id ustuni bo'yicha). SUM Function: Task: sales jadvalida barcha buyurtmalarning umumiy qiymatini hisoblang. Har bir mijoz uchun ( customer_id ) buyurtmalarning umumiy qiymatini toping. AVG Function: Task: products jadvalidagi mahsulotlarning o'rtacha narxini hisoblang. Har bir toifaga ( category_id ) ko'ra mahsulotlarning o'rtacha narxini toping. MIN and MAX Functions: Task: employees jadvalida eng kam va eng yuqori oylik miqdorini toping. Har bir bo'limda ( department_id ) eng kam va eng yuqori oylikni aniqlang.","title":"Function and Aggregation"},{"location":"psql/function-and-aggregation/#advanced-data-retrieval-with-functions-and-aggregation","text":"Topics: Using PostgreSQL functions COUNT , SUM , AVG , MIN , MAX Grouping data with GROUP BY Filtering grouped data with HAVING [!NOTE] PostgreSQL da murakkab so\u02bbrovlar va ma\u02bclumotlarni samarali boshqarish aggregation functions hamda advanced functions ni ishlatishni talab qiladi.","title":"\ud83d\udc18 Advanced Data Retrieval with Functions and Aggregation"},{"location":"psql/function-and-aggregation/#using-postgresql-functions-count-sum-avg-min-max","text":"Aggregate Functions Agregatsiya funksiyalari bir necha qator ustida hisob-kitob olib boradi va bitta natija qaytaradi. COUNT() : Counts rows. SUM() : Calculates the total sum. AVG() : Calculates the average. MAX() and MIN() : Find the highest and lowest values. employee_id first_name last_name department salary 1 Ali Valiyev IT 3000 2 Sara Ahmedova HR 2500 3 Olim Nazarov IT 4000 4 Kamola Ismatova Finance 3500 5 Zafar Bekmurodov Marketing 2000 6 Anvar Karimov IT 4500 7 Lola Tursunova HR 2700 SELECT department, COUNT(*) AS employee_count, AVG(salary) AS avg_salary FROM employees GROUP BY department ORDER BY avg_salary DESC; Bu so\u02bbrov bo\u2018limlar bo\u2018yicha xodimlarni guruhlab , ularning sonini va o\u2018rtacha ish haqini hisoblaydi. Filtering Aggregated Data Agregatsiyalangan ma\u02bclumotlarni filtrlash uchun HAVING operatoridan foydalaniladi. Example: SELECT department, SUM(salary) AS total_salary FROM employees GROUP BY department HAVING SUM(salary) > 500000; Bu so\u02bbrov umumiy ish haqi 500,000 dan yuqori bo\u02bblgan bo\u2018limlarni chiqaradi. Window Functions Window functions operate on a set of rows related to the current row but do not reduce the result Example: SELECT employee_id, department, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank FROM employees; Bu so\u02bbrov har bir bo\u2018limdagi ishchilarni ish haqi bo\u02bbyicha tartiblaydi. Using Common Table Expressions CTEs CTE murakkab so\u02bbrovlarni soddalashtiradi va tushunishni osonlashtiradi. Example: WITH department_salaries AS ( SELECT department, SUM(salary) AS total_salary FROM employees GROUP BY department ) SELECT department FROM department_salaries WHERE total_salary > 500000; Bu misolda umumiy ish haqlari hisoblanib, saralangan bo\u2018limlar chiqariladi. Advanced SQL Functions PostgreSQL da ma\u02bclumotlarni boshqarish uchun juda ko\u02bbp qurilgan funksiyalar mavjud. String Functions: CONCAT() , SUBSTRING() , LOWER() , UPPER() Example: SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees; Date/Time Functions: NOW() , AGE() , DATE_PART() Example: SELECT employee_id, AGE(NOW(), hire_date) AS years_of_service FROM employees; JSON Functions: JSONB_EXTRACT_PATH_TEXT() , JSON_AGG() Example: SELECT JSON_AGG(department) AS departments FROM employees; Recursive Queries Rekursiv so\u02bbrovlar hierarchical yoki tree-structured ma\u02bclumotlar bilan ishlash imkonini beradi. Example: WITH RECURSIVE employee_hierarchy AS ( SELECT employee_id, manager_id, 1 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.employee_id, e.manager_id, eh.level + 1 FROM employees e JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id ) SELECT * FROM employee_hierarchy; Bu so\u02bbrov hierarchy of employees va ularning darajasini shakllantiradi. Combining Data with JOIN and Aggregates Aggregate Functions bir nechta jadvallar bilan ishlashda ham foydali. Example: SELECT d.department_name, COUNT(e.employee_id) AS total_employees FROM departments d LEFT JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_name; Bu har bir bo\u2018limdagi ishchilar sonini, ishchi bo\u2018lmagan bo\u2018limlarni ham qo\u2018shib, chiqaradi.","title":"USING PostgreSQL FUNCTIONS COUNT, SUM, AVG, MIN, MAX"},{"location":"psql/function-and-aggregation/#grouping-data-with-group-by","text":"[!NOTE] GROUP BY operatori PostgreSQL da ma\u2019lumotlarni guruhlash uchun ishlatiladi. Bu operator ko\u2018pincha Aggregate Functions ( COUNT() , SUM() , AVG() , MAX() , MIN() ) bilan birgalikda qo\u2018llaniladi Syntax: SELECT column_name, aggregate_function(column_name) FROM table_name GROUP BY column_name;","title":"GROUPING DATA WITH GROUP BY"},{"location":"psql/function-and-aggregation/#simple-example-grouping-employees-by-department","text":"Table: employees id name department salary 1 Alice HR 5000 2 Bob IT 7000 3 Charlie IT 6000 4 Diana HR 5500 5 Eve Sales 8000 Goal: Har bir bo\u2018limdagi ishchilar sonini aniqlash. Query: SELECT department, COUNT(*) AS employee_count FROM employees GROUP BY department; Result: department employee_count HR 2 IT 2 Sales 1","title":"SIMPLE EXAMPLE: GROUPING EMPLOYEES BY DEPARTMENT"},{"location":"psql/function-and-aggregation/#using-aggregate-functions","text":"Har bir bo\u2018limning o\u2018rtacha maoshi SELECT department, AVG(salary) AS average_salary FROM employees GROUP BY department; Result: department average_salary HR 5250 IT 6500 Sales 8000 Har bir bo\u2018limdagi eng katta maosh SELECT department, MAX(salary) AS max_salary FROM employees GROUP BY department; department average_salary HR 5500 IT 7000 Sales 8000","title":"USING AGGREGATE FUNCTIONS"},{"location":"psql/function-and-aggregation/#grouping-by-multiple-columns","text":"id region product revenue 1 North Laptop 15000 2 North Phone 20000 3 South Laptop 12000 4 South Phone 25000 5 East Laptop 10000 Goal: Har bir mintaqa va mahsulot bo\u2018yicha umumiy daromadni hisoblash. SELECT region, product, SUM(revenue) AS total_revenue FROM sales GROUP BY region, product; region product total_revenue North Laptop 15000 North Phone 20000 South Laptop 12000 South Phone 25000 East Laptop 10000","title":"GROUPING BY MULTIPLE COLUMNS"},{"location":"psql/function-and-aggregation/#using-having-with-group-by","text":"Har bir bo\u2018limdagi ishchilar soni 1 dan katta bo\u2018lgan holatlar HAVING agregat funksiyalar natijasiga cheklov qo\u2018yish uchun ishlatiladi. SELECT department, COUNT(*) AS employee_count FROM employees GROUP BY department HAVING COUNT(*) > 1; Result: department employee_count HR 2 IT 2","title":"USING HAVING WITH GROUP BY"},{"location":"psql/function-and-aggregation/#filtering-grouped-data-with-having","text":"[!NOTE] SQLda HAVING clause GROUP BY orqali guruhlangan ma\u02bclumotlarni filtrlash uchun ishlatiladi. WHERE clausedan farqli o\u2018laroq, HAVING faqat guruhlash va agregatsiya (masalan, COUNT() , SUM() , AVG() , MAX() , MIN() )dan keyin qo\u2018llaniladi. Syntax: SELECT column1, column2, AGGREGATE_FUNCTION(column3) FROM table_name WHERE condition GROUP BY column1, column2 HAVING aggregate_condition; Key Points: WHERE - guruhlashdan oldin qatorlarni filtrlash uchun ishlatiladi. GROUP BY - qatorlarni belgilangan ustunlarga asoslangan holda guruhlash uchun ishlatiladi. HAVING - guruhlangan ma\u02bclumotlarni agregatsiya funksiyalariga asoslangan holda filtrlash uchun ishlatiladi. Example 1: Filtering Sales Data Table: Sales Salesperson Region Sales Alice East 500 Bob East 700 Alice West 300 Bob West 400 Alice East 200 Bob East 600 Query: Umumiy sotuv miqdori 1000 dan oshgan hududlarni ko\u2018rsating. SELECT Region, SUM(Sales) AS Total_Sales FROM Sales GROUP BY Region HAVING SUM(Sales) > 1000; Result: Region Total_Sales East 2000 Example 2: Counting Employees in Departments Table: Employees EmployeeID Department Salary 1 IT 800 2 HR 500 3 IT 900 4 Sales 600 5 IT 700 6 Sales 500 Query: 2 dan ortiq xodimga ega bo\u2018lgan bo\u2018limlarni ko\u2018rsating. SELECT Department, COUNT(EmployeeID) AS Employee_Count FROM Employees GROUP BY Department HAVING COUNT(EmployeeID) > 2; Result: Department Employee_Count IT 3 Example 3: Average Salary by Department Query: O\u2018rtacha maosh 600 dan oshgan bo\u2018limlarni ko\u2018rsating. SELECT Department, AVG(Salary) AS Average_Salary FROM Employees GROUP BY Department HAVING AVG(Salary) > 600; Result: Department Average_Salary IT 800","title":"FILTERING GROUPED DATA WITH HAVING"},{"location":"psql/function-and-aggregation/#tasks","text":"COUNT Function: Task: students jadvalida nechta talaba borligini hisoblang. students jadvalidagi har bir guruh uchun nechta talaba borligini hisoblang ( group_id ustuni bo'yicha). SUM Function: Task: sales jadvalida barcha buyurtmalarning umumiy qiymatini hisoblang. Har bir mijoz uchun ( customer_id ) buyurtmalarning umumiy qiymatini toping. AVG Function: Task: products jadvalidagi mahsulotlarning o'rtacha narxini hisoblang. Har bir toifaga ( category_id ) ko'ra mahsulotlarning o'rtacha narxini toping. MIN and MAX Functions: Task: employees jadvalida eng kam va eng yuqori oylik miqdorini toping. Har bir bo'limda ( department_id ) eng kam va eng yuqori oylikni aniqlang.","title":"Tasks"},{"location":"psql/introduction/","text":"\ud83d\udc18 Ma'lumotlar bazasiga kirish Ma'lumotlar bazasi (Database) nima? Ma'lumotlar bazasi \u2014 bu ma'lumotlarni tartibli va tizimli tarzda saqlash, ularni tez va oson qidirish, o\u2018zgartirish hamda boshqarish uchun mo\u2018ljallangan tizimdir. Zamonaviy dasturlarda ma'lumotlar bazasini boshqarish uchun maxsus dasturlar \u2014 Database Management Systems ( DBMS ) ishlatiladi. Ma'lumotlar bazasi turlari Eslatma: Ma'lumotlar bazalari tuzilishi va ma'lumotlarni qanday usulda saqlashiga ko\u2018ra bir necha ko\u2018rinishda bo\u2018ladi. 1. Relatsion ma'lumotlar bazasi (Relational Database, RDBMS) Tavsifi: Ma'lumotlar qat\u02bciy strukturaga ega bo\u2018lgan jadvallar (rows va columns) ko\u2018rinishida saqlanadi. Jadvallar o\u2018zaro aloqador bo\u2018lishi mumkin (asosiy kalitlar orqali). Misollar: PostgreSQL , MySQL , Oracle , SQL Server Qo\u2018llanilishi: Internet saytlar, bank tizimlari, korxona axborot tizimlari. Jadval yaratish misoli (SQL): CREATE TABLE users ( user_id INT PRIMARY KEY, -- Foydalanuvchi uchun unikal identifikator username VARCHAR(50), -- Foydalanuvchi nomi email VARCHAR(100), -- Email manzili created_at TIMESTAMP -- Ro\u2018yxatdan o\u2018tgan sana ); 2. NoSQL ma'lumotlar bazasi Tavsifi: NoSQL (Not Only SQL) bazalarida ma'lumotlar qat\u02bciy jadval ko\u2018rinishida emas, balki moslashuvchan va katta hajmdagi ma'lumotlarni saqlash uchun turli formatlarda saqlanadi. Turlari: document, key-value, column-family, graph. Misollar: MongoDB (document), Redis (key-value), Cassandra (column-family), Neo4j (graph) Qo\u2018llanilishi: Katta hajmdagi ma'lumotlar, tez o\u2018zgaruvchan ma'lumotlar, real-time ilovalar. 3. Hujjatli ma'lumotlar bazasi (Document-Based Database) Tavsifi: Ma'lumotlar JSON yoki BSON kabi hujjatlar ko\u2018rinishida saqlanadi. Har bir hujjat mustaqil ma'lumot birligi bo\u2018lib, ichki strukturasi murakkab bo\u2018lishi mumkin. Misollar: MongoDB , CouchDB Qo\u2018llanilishi: Foydalanuvchi profillari, kontent boshqarish tizimlari. MongoDB hujjat misoli: { \"user_id\": 1, // Foydalanuvchi identifikatori \"username\": \"john_doe\", // Foydalanuvchi nomi \"email\": \"john@example.com\", // Email manzili \"created_at\": \"2025-06-29T21:00:00Z\" // Ro\u2018yxatdan o\u2018tgan vaqt } MongoDB'ga hujjat qo\u2018shish: db.users.insertOne({ user_id: 1, // Foydalanuvchi identifikatori username: \"john_doe\", // Foydalanuvchi nomi email: \"john@example.com\", // Email manzili created_at: new Date() // Qo\u2018shilgan vaqt }); 4. Grafik ma'lumotlar bazasi (Graph Database) Tavsifi: Grafik bazalarida ma'lumotlar tugunlar (node) va ularning o\u2018zaro bog\u2018lanishi (edge) orqali saqlanadi. Murakkab aloqalar va tarmoqlar uchun juda qulay. Misollar: Neo4j , ArangoDB Qo\u2018llanilishi: Ijtimoiy tarmoqlar, tavsiya tizimlari, firibgarlikni aniqlash. Neo4j uchun Cypher so\u2018rovi: CREATE (user:User {userId: 1, name: \"Alice\"}) // Foydalanuvchi tuguni yaratish CREATE (product:Product {productId: 100, name: \"Book\"}) // Mahsulot tuguni yaratish CREATE (user)-[:PURCHASED]->(product) // Foydalanuvchi va mahsulot o\u2018rtasida \"sotib olgan\" bog\u2018lanishini yaratish Qisqa taqqoslash jadvali Ma'lumotlar bazasi turi Tuzilishi Misollar Qo\u2018llanilishi Relatsion Jadval (SQL) MySQL, PostgreSQL Korxona, tranzaksiyalar Hujjatli JSON/BSON MongoDB, CouchDB Kontent, foydalanuvchilar Kalit-qiymatli Key-Value Redis, DynamoDB Kesh, sessiyalar Ustunli Column-family Cassandra, HBase Big data, tahlil Grafik Node/Edge Neo4j, ArangoDB Tarmoqlar, tavsiyalar Asosiy atamalar Jadval (Table): Relatsion bazalarda ma'lumotlarni saqlash uchun asosiy strukturaviy birlik. Hujjat (Document): Hujjatli bazalarda mustaqil ma'lumot birligi (ko\u2018pincha JSON ko\u2018rinishida). Tugun/Bog\u2018lanish (Node/Edge): Grafik bazalarda ob'ekt va ular o\u2018rtasidagi munosabat. Asosiy kalit (Primary Key): Har bir yozuv uchun unikal identifikator. Tashqi kalit (Foreign Key): Jadval o\u2018rtasidagi bog\u2018liqlikni ifodalovchi maydon. Maslahat: Dastur yoki loyiha uchun ma'lumotlar bazasi tanlashda, sizda qanday ma'lumotlar va ular ustida qanday amallar bajarilishini inobatga oling.","title":"Introduction"},{"location":"psql/introduction/#malumotlar-bazasiga-kirish","text":"","title":"\ud83d\udc18 Ma'lumotlar bazasiga kirish"},{"location":"psql/introduction/#malumotlar-bazasi-database-nima","text":"Ma'lumotlar bazasi \u2014 bu ma'lumotlarni tartibli va tizimli tarzda saqlash, ularni tez va oson qidirish, o\u2018zgartirish hamda boshqarish uchun mo\u2018ljallangan tizimdir. Zamonaviy dasturlarda ma'lumotlar bazasini boshqarish uchun maxsus dasturlar \u2014 Database Management Systems ( DBMS ) ishlatiladi.","title":"Ma'lumotlar bazasi (Database) nima?"},{"location":"psql/introduction/#malumotlar-bazasi-turlari","text":"Eslatma: Ma'lumotlar bazalari tuzilishi va ma'lumotlarni qanday usulda saqlashiga ko\u2018ra bir necha ko\u2018rinishda bo\u2018ladi.","title":"Ma'lumotlar bazasi turlari"},{"location":"psql/introduction/#1-relatsion-malumotlar-bazasi-relational-database-rdbms","text":"Tavsifi: Ma'lumotlar qat\u02bciy strukturaga ega bo\u2018lgan jadvallar (rows va columns) ko\u2018rinishida saqlanadi. Jadvallar o\u2018zaro aloqador bo\u2018lishi mumkin (asosiy kalitlar orqali). Misollar: PostgreSQL , MySQL , Oracle , SQL Server Qo\u2018llanilishi: Internet saytlar, bank tizimlari, korxona axborot tizimlari. Jadval yaratish misoli (SQL): CREATE TABLE users ( user_id INT PRIMARY KEY, -- Foydalanuvchi uchun unikal identifikator username VARCHAR(50), -- Foydalanuvchi nomi email VARCHAR(100), -- Email manzili created_at TIMESTAMP -- Ro\u2018yxatdan o\u2018tgan sana );","title":"1. Relatsion ma'lumotlar bazasi (Relational Database, RDBMS)"},{"location":"psql/introduction/#2-nosql-malumotlar-bazasi","text":"Tavsifi: NoSQL (Not Only SQL) bazalarida ma'lumotlar qat\u02bciy jadval ko\u2018rinishida emas, balki moslashuvchan va katta hajmdagi ma'lumotlarni saqlash uchun turli formatlarda saqlanadi. Turlari: document, key-value, column-family, graph. Misollar: MongoDB (document), Redis (key-value), Cassandra (column-family), Neo4j (graph) Qo\u2018llanilishi: Katta hajmdagi ma'lumotlar, tez o\u2018zgaruvchan ma'lumotlar, real-time ilovalar.","title":"2. NoSQL ma'lumotlar bazasi"},{"location":"psql/introduction/#3-hujjatli-malumotlar-bazasi-document-based-database","text":"Tavsifi: Ma'lumotlar JSON yoki BSON kabi hujjatlar ko\u2018rinishida saqlanadi. Har bir hujjat mustaqil ma'lumot birligi bo\u2018lib, ichki strukturasi murakkab bo\u2018lishi mumkin. Misollar: MongoDB , CouchDB Qo\u2018llanilishi: Foydalanuvchi profillari, kontent boshqarish tizimlari. MongoDB hujjat misoli: { \"user_id\": 1, // Foydalanuvchi identifikatori \"username\": \"john_doe\", // Foydalanuvchi nomi \"email\": \"john@example.com\", // Email manzili \"created_at\": \"2025-06-29T21:00:00Z\" // Ro\u2018yxatdan o\u2018tgan vaqt } MongoDB'ga hujjat qo\u2018shish: db.users.insertOne({ user_id: 1, // Foydalanuvchi identifikatori username: \"john_doe\", // Foydalanuvchi nomi email: \"john@example.com\", // Email manzili created_at: new Date() // Qo\u2018shilgan vaqt });","title":"3. Hujjatli ma'lumotlar bazasi (Document-Based Database)"},{"location":"psql/introduction/#4-grafik-malumotlar-bazasi-graph-database","text":"Tavsifi: Grafik bazalarida ma'lumotlar tugunlar (node) va ularning o\u2018zaro bog\u2018lanishi (edge) orqali saqlanadi. Murakkab aloqalar va tarmoqlar uchun juda qulay. Misollar: Neo4j , ArangoDB Qo\u2018llanilishi: Ijtimoiy tarmoqlar, tavsiya tizimlari, firibgarlikni aniqlash. Neo4j uchun Cypher so\u2018rovi: CREATE (user:User {userId: 1, name: \"Alice\"}) // Foydalanuvchi tuguni yaratish CREATE (product:Product {productId: 100, name: \"Book\"}) // Mahsulot tuguni yaratish CREATE (user)-[:PURCHASED]->(product) // Foydalanuvchi va mahsulot o\u2018rtasida \"sotib olgan\" bog\u2018lanishini yaratish","title":"4. Grafik ma'lumotlar bazasi (Graph Database)"},{"location":"psql/introduction/#qisqa-taqqoslash-jadvali","text":"Ma'lumotlar bazasi turi Tuzilishi Misollar Qo\u2018llanilishi Relatsion Jadval (SQL) MySQL, PostgreSQL Korxona, tranzaksiyalar Hujjatli JSON/BSON MongoDB, CouchDB Kontent, foydalanuvchilar Kalit-qiymatli Key-Value Redis, DynamoDB Kesh, sessiyalar Ustunli Column-family Cassandra, HBase Big data, tahlil Grafik Node/Edge Neo4j, ArangoDB Tarmoqlar, tavsiyalar","title":"Qisqa taqqoslash jadvali"},{"location":"psql/introduction/#asosiy-atamalar","text":"Jadval (Table): Relatsion bazalarda ma'lumotlarni saqlash uchun asosiy strukturaviy birlik. Hujjat (Document): Hujjatli bazalarda mustaqil ma'lumot birligi (ko\u2018pincha JSON ko\u2018rinishida). Tugun/Bog\u2018lanish (Node/Edge): Grafik bazalarda ob'ekt va ular o\u2018rtasidagi munosabat. Asosiy kalit (Primary Key): Har bir yozuv uchun unikal identifikator. Tashqi kalit (Foreign Key): Jadval o\u2018rtasidagi bog\u2018liqlikni ifodalovchi maydon. Maslahat: Dastur yoki loyiha uchun ma'lumotlar bazasi tanlashda, sizda qanday ma'lumotlar va ular ustida qanday amallar bajarilishini inobatga oling.","title":"Asosiy atamalar"},{"location":"psql/joins-and-advanced-queries/","text":"\ud83d\udc18 Joins and Advanced Queries Topics: Types of joins: INNER JOIN , LEFT JOIN , RIGHT JOIN , FULL JOIN Combining tables with joins Subqueries and nested queries Types of joins: INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN [!NOTE] JOIN operatori SQLda ikki yoki undan ortiq jadvallarni bog'lash va ular orasidagi ma'lumotlarni birlashtirish uchun ishlatiladi. JOIN yordamida ma'lumotlar o'rtasidagi bog'lanishlarni tahlil qilib, kerakli ma'lumotlarni olish mumkin. students table student_id name group_id 1 Ali 101 2 Umid 102 3 Hasan NULL 4 Kamola 103 groups table group_id group_name 101 Matematika 102 Fizika 103 Informatika 104 Biologiya INNER JOIN Faqat ikkala jadvalda mos keladigan ma'lumotlarni qaytaradi. SELECT students.student_id, students.name, groups.group_name FROM students INNER JOIN groups ON students.group_id = groups.group_id; LEFT JOIN Chap jadvaldagi barcha ma'lumotlarni qaytaradi va o'ng jadvaldan mos kelmaydigan joylarga NULL qo'shadi. SELECT students.student_id, students.name, groups.group_name FROM students LEFT JOIN groups ON students.group_id = groups.group_id; RIGHT JOIN O'ng jadvaldagi barcha ma'lumotlarni qaytaradi va chap jadvaldan mos kelmaydigan joylarga NULL qo'shadi. SELECT students.student_id, students.name, groups.group_name FROM students RIGHT JOIN groups ON students.group_id = groups.group_id; FULL JOIN Ikkala jadvaldagi barcha ma'lumotlarni qaytaradi. Mos kelmagan joylarga NULL qo'shiladi. SELECT students.student_id, students.name, groups.group_name FROM students FULL JOIN groups ON students.group_id = groups.group_id; Combining tables with joins [!NOTE] JOIN operatori yordamida ikki yoki undan ortiq jadvalni o'zaro bog'langan ustunlar (keys) orqali birlashtirish mumkin. Bu ma'lumotlar orasidagi mantiqiy bog'lanishni ko'rish imkonini beradi. INNER JOIN Bu JOIN faqat ikki jadvalda ham mos keladigan (bog'langan) ma'lumotlarni olib keladi. SELECT students.name, groups.group_name FROM students INNER JOIN groups ON students.group_id = groups.group_id; LEFT JOIN LEFT JOIN asosiy jadval (chapdagi jadval)dagi barcha malumotlarni oladi va o'ng jadvaldagi mos keladigan malumotlarni birlashtiradi. Agar mos kelmasa, NULL qiymatni qaytaradi. SELECT students.name, groups.group_name FROM students LEFT JOIN groups ON students.group_id = groups.group_id; RIGHT JOIN RIGHT JOIN o'ng jadvaldagi barcha malumotlarni oladi va chap jadvaldagi mos keladigan malumotlarni birlashtiradi. Agar mos kelmasa, NULL qiymatni qaytaradi. SELECT students.name, groups.group_name FROM students RIGHT JOIN groups ON students.group_id = groups.group_id; FULL OUTER JOIN FULL OUTER JOIN ikki jadvaldagi barcha malumotlarni oladi, mos kelmasa, NULL bilan to'ldiradi. SELECT students.name, groups.group_name FROM students FULL OUTER JOIN groups ON students.group_id = groups.group_id; Subqueries and nested queries [!NOTE] SQLda subqueries (ichki so'rovlar) yoki nested queries (ichama-ich so'rovlar) boshqa bir so'rov ichida yoziladigan so'rovlar hisoblanadi. Subquery asosiy so'rov uchun kerakli ma'lumotni olishga yordam beradi. Subqueries SQL buyruqlarining SELECT , FROM , yoki WHERE qismida ishlatilishi mumkin. Key Characteristics of Subqueries Subquery har doim qavslar ( ) ichida yozilishi kerak. Subquery bitta qiymat , bitta qator yoki butun jadval ni qaytarishi mumkin. U quyidagi joylarda ishlatiladi: SELECT : hisoblangan qiymatlarni olish uchun. WHERE : filterlash shartlarini belgilash uchun. FROM : vaqtinchalik jadval sifatida ishlatish uchun. Subqueries turlari: Uncorrelated Subqueries: Correlated Subqueries: PRACTICS employees table employee_id name department_id salary join_date 1 Ali 1 1200.50 2020-05-15 2 Vali 2 1500.00 2019-06-01 3 Sodiq NULL 1100.75 2021-08-20 4 Nozima 3 1300.00 2020-03-12 5 Shavkat 1 1250.00 2018-11-23 6 Madina 4 1400.30 2022-02-10 7 Jasur 2 1600.45 2019-12-01 8 Karima 5 1350.00 2023-07-01 9 Sarvar NULL 1000.00 2021-01-15 10 Malika 3 1450.00 2022-10-25 departments table department_id department_name manager 1 HR Akbar 2 IT Dilshod 3 Marketing Ravshan 4 Finance Aziza 5 Operations Nigora 6 Logistics Kamol Xodimlarning bo\u2018lim nomlarini ko\u2018rsating. Faqat bo\u2018limi mavjud xodimlar chiqsin. Xodimlar ro\u2018yxatini ularning bo\u2018lim nomi bilan ko\u2018rsating. Bo\u2018limi yo\u2018q xodimlar uchun \"NULL\" chiqsin. Har bir bo\u2018limga tegishli xodimlarni yoki bo\u2018limda hech kim ishlamasa ham bo\u2018lim nomini ko\u2018rsating. Har bir xodim va har bir bo\u2018lim haqida umumiy ma\u2019lumotni ko\u2018rsating. Bog\u2018lanmagan ma\u2019lumotlar ham chiqsin. Har bir xodim va har bir bo\u2018lim haqida umumiy ma\u2019lumotni ko\u2018rsating. Bog\u2018lanmagan ma\u2019lumotlar ham chiqsin. Har bir bo\u2018limda nechta xodim ishlashini ko\u2018rsating.","title":"Joins and Advanced Queries"},{"location":"psql/joins-and-advanced-queries/#joins-and-advanced-queries","text":"Topics: Types of joins: INNER JOIN , LEFT JOIN , RIGHT JOIN , FULL JOIN Combining tables with joins Subqueries and nested queries","title":"\ud83d\udc18 Joins and Advanced Queries"},{"location":"psql/joins-and-advanced-queries/#types-of-joins-inner-join-left-join-right-join-full-join","text":"[!NOTE] JOIN operatori SQLda ikki yoki undan ortiq jadvallarni bog'lash va ular orasidagi ma'lumotlarni birlashtirish uchun ishlatiladi. JOIN yordamida ma'lumotlar o'rtasidagi bog'lanishlarni tahlil qilib, kerakli ma'lumotlarni olish mumkin. students table student_id name group_id 1 Ali 101 2 Umid 102 3 Hasan NULL 4 Kamola 103 groups table group_id group_name 101 Matematika 102 Fizika 103 Informatika 104 Biologiya","title":"Types of joins: INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN"},{"location":"psql/joins-and-advanced-queries/#inner-join","text":"Faqat ikkala jadvalda mos keladigan ma'lumotlarni qaytaradi. SELECT students.student_id, students.name, groups.group_name FROM students INNER JOIN groups ON students.group_id = groups.group_id;","title":"INNER JOIN"},{"location":"psql/joins-and-advanced-queries/#left-join","text":"Chap jadvaldagi barcha ma'lumotlarni qaytaradi va o'ng jadvaldan mos kelmaydigan joylarga NULL qo'shadi. SELECT students.student_id, students.name, groups.group_name FROM students LEFT JOIN groups ON students.group_id = groups.group_id;","title":"LEFT JOIN"},{"location":"psql/joins-and-advanced-queries/#right-join","text":"O'ng jadvaldagi barcha ma'lumotlarni qaytaradi va chap jadvaldan mos kelmaydigan joylarga NULL qo'shadi. SELECT students.student_id, students.name, groups.group_name FROM students RIGHT JOIN groups ON students.group_id = groups.group_id;","title":"RIGHT JOIN"},{"location":"psql/joins-and-advanced-queries/#full-join","text":"Ikkala jadvaldagi barcha ma'lumotlarni qaytaradi. Mos kelmagan joylarga NULL qo'shiladi. SELECT students.student_id, students.name, groups.group_name FROM students FULL JOIN groups ON students.group_id = groups.group_id;","title":"FULL JOIN"},{"location":"psql/joins-and-advanced-queries/#combining-tables-with-joins","text":"[!NOTE] JOIN operatori yordamida ikki yoki undan ortiq jadvalni o'zaro bog'langan ustunlar (keys) orqali birlashtirish mumkin. Bu ma'lumotlar orasidagi mantiqiy bog'lanishni ko'rish imkonini beradi.","title":"Combining tables with joins"},{"location":"psql/joins-and-advanced-queries/#inner-join_1","text":"Bu JOIN faqat ikki jadvalda ham mos keladigan (bog'langan) ma'lumotlarni olib keladi. SELECT students.name, groups.group_name FROM students INNER JOIN groups ON students.group_id = groups.group_id;","title":"INNER JOIN"},{"location":"psql/joins-and-advanced-queries/#left-join_1","text":"LEFT JOIN asosiy jadval (chapdagi jadval)dagi barcha malumotlarni oladi va o'ng jadvaldagi mos keladigan malumotlarni birlashtiradi. Agar mos kelmasa, NULL qiymatni qaytaradi. SELECT students.name, groups.group_name FROM students LEFT JOIN groups ON students.group_id = groups.group_id;","title":"LEFT JOIN"},{"location":"psql/joins-and-advanced-queries/#right-join_1","text":"RIGHT JOIN o'ng jadvaldagi barcha malumotlarni oladi va chap jadvaldagi mos keladigan malumotlarni birlashtiradi. Agar mos kelmasa, NULL qiymatni qaytaradi. SELECT students.name, groups.group_name FROM students RIGHT JOIN groups ON students.group_id = groups.group_id;","title":"RIGHT JOIN"},{"location":"psql/joins-and-advanced-queries/#full-outer-join","text":"FULL OUTER JOIN ikki jadvaldagi barcha malumotlarni oladi, mos kelmasa, NULL bilan to'ldiradi. SELECT students.name, groups.group_name FROM students FULL OUTER JOIN groups ON students.group_id = groups.group_id;","title":"FULL OUTER JOIN"},{"location":"psql/joins-and-advanced-queries/#subqueries-and-nested-queries","text":"[!NOTE] SQLda subqueries (ichki so'rovlar) yoki nested queries (ichama-ich so'rovlar) boshqa bir so'rov ichida yoziladigan so'rovlar hisoblanadi. Subquery asosiy so'rov uchun kerakli ma'lumotni olishga yordam beradi. Subqueries SQL buyruqlarining SELECT , FROM , yoki WHERE qismida ishlatilishi mumkin.","title":"Subqueries and nested queries"},{"location":"psql/joins-and-advanced-queries/#key-characteristics-of-subqueries","text":"Subquery har doim qavslar ( ) ichida yozilishi kerak. Subquery bitta qiymat , bitta qator yoki butun jadval ni qaytarishi mumkin. U quyidagi joylarda ishlatiladi: SELECT : hisoblangan qiymatlarni olish uchun. WHERE : filterlash shartlarini belgilash uchun. FROM : vaqtinchalik jadval sifatida ishlatish uchun. Subqueries turlari: Uncorrelated Subqueries: Correlated Subqueries:","title":"Key Characteristics of Subqueries"},{"location":"psql/joins-and-advanced-queries/#practics","text":"employees table employee_id name department_id salary join_date 1 Ali 1 1200.50 2020-05-15 2 Vali 2 1500.00 2019-06-01 3 Sodiq NULL 1100.75 2021-08-20 4 Nozima 3 1300.00 2020-03-12 5 Shavkat 1 1250.00 2018-11-23 6 Madina 4 1400.30 2022-02-10 7 Jasur 2 1600.45 2019-12-01 8 Karima 5 1350.00 2023-07-01 9 Sarvar NULL 1000.00 2021-01-15 10 Malika 3 1450.00 2022-10-25 departments table department_id department_name manager 1 HR Akbar 2 IT Dilshod 3 Marketing Ravshan 4 Finance Aziza 5 Operations Nigora 6 Logistics Kamol Xodimlarning bo\u2018lim nomlarini ko\u2018rsating. Faqat bo\u2018limi mavjud xodimlar chiqsin. Xodimlar ro\u2018yxatini ularning bo\u2018lim nomi bilan ko\u2018rsating. Bo\u2018limi yo\u2018q xodimlar uchun \"NULL\" chiqsin. Har bir bo\u2018limga tegishli xodimlarni yoki bo\u2018limda hech kim ishlamasa ham bo\u2018lim nomini ko\u2018rsating. Har bir xodim va har bir bo\u2018lim haqida umumiy ma\u2019lumotni ko\u2018rsating. Bog\u2018lanmagan ma\u2019lumotlar ham chiqsin. Har bir xodim va har bir bo\u2018lim haqida umumiy ma\u2019lumotni ko\u2018rsating. Bog\u2018lanmagan ma\u2019lumotlar ham chiqsin. Har bir bo\u2018limda nechta xodim ishlashini ko\u2018rsating.","title":"PRACTICS"},{"location":"psql/postgresql/","text":"\ud83d\udc18 PostgreSQL Topics Relational databases va PostgreSQL haqida tushuncha PostgreSQL ning xususiyatlari va foydalanish holatlari PostgreSQL ni o'rnatish ( Windows , macOS va Linux uchun ko'rsatmalar) pgAdmin bilan ishlashni o'rganish Terminal da PostgreSQL bilan ishlash uchun asosiy buyruqlar [!NOTE] Relational databases \u2013 bu turli ma'lumotlarni saqlash va ularga tezkor tarzda kirish imkonini beruvchi tizimlar bo'lib, ular ma'lumotlar orasidagi o'zaro bog'lanishni qo'llab-quvvatlaydi. Bu bog'lanishlar odatda jadval shaklida tashkil etiladi va bu jadvallarda ma'lumotlar qator va ustunlar ko'rinishida saqlanadi. Relational databases ning asosiy xususiyatlari: Data stored in tables: Ma'lumotlar qator va ustunlardan iborat jadvallarda saqlanadi. Har bir jadval alohida ma'lumot turini ifodalaydi. Primary Keys: Har bir qatorni noyob ravishda identifikatsiyalovchi ustun mavjud. Foreign Keys: Jadvaldagi ma'lumotlarni boshqa jadvallar bilan bog'lash imkonini beradi. SQL (Structured Query Language): Relational databases bilan ishlashda ishlatiladigan standart so'rov tili. About PostgreSQL PostgreSQL \u2013 bu open-source va powerful relational database management system (RDBMS). U ko'p turdagi ma'lumot turlarini qo'llab-quvvatlaydi va murakkab so'rovlar , katta hajmdagi ma'lumotlarni boshqarish imkoniyatini beradi. PostgreSQL ning asosiy afzalliklari: Open-source: PostgreSQL bepul va uni o'zgartirish yoki moslashtirish mumkin. Data Integrity: Yozilgan ma'lumotlarning to'g'ri va bir xil bo'lishini kafolatlaydi. Support for SQL and JSON: PostgreSQL relational (SQL) va JSON bilan ishlash imkoniyatini beradi, ya'ni bu ikkala usulda ma'lumot saqlash mumkin. Extensibility: PostgreSQL ni qo'shimcha modullar yordamida kengaytirish oson. Install PostgreSQL Download PostgreSQL PostgreSQL rasmiy saytiga kirib olamiz. Download tugmasini bosamiz. Bu yerdan o'zimizga kerak bo'lgan OS ( Operating System ) ni tanlab olamiz. Bu yerdan Download the installer ni bosamiz. Bu yerdan esa PostgreSQLni versiyasini tanlashimiz mumkin. PRACTICS PostgreSQLni o'rnatish, terminal va pgAdmin yordamida ulanish.","title":"PostgreSQL"},{"location":"psql/postgresql/#postgresql","text":"Topics Relational databases va PostgreSQL haqida tushuncha PostgreSQL ning xususiyatlari va foydalanish holatlari PostgreSQL ni o'rnatish ( Windows , macOS va Linux uchun ko'rsatmalar) pgAdmin bilan ishlashni o'rganish Terminal da PostgreSQL bilan ishlash uchun asosiy buyruqlar [!NOTE] Relational databases \u2013 bu turli ma'lumotlarni saqlash va ularga tezkor tarzda kirish imkonini beruvchi tizimlar bo'lib, ular ma'lumotlar orasidagi o'zaro bog'lanishni qo'llab-quvvatlaydi. Bu bog'lanishlar odatda jadval shaklida tashkil etiladi va bu jadvallarda ma'lumotlar qator va ustunlar ko'rinishida saqlanadi. Relational databases ning asosiy xususiyatlari: Data stored in tables: Ma'lumotlar qator va ustunlardan iborat jadvallarda saqlanadi. Har bir jadval alohida ma'lumot turini ifodalaydi. Primary Keys: Har bir qatorni noyob ravishda identifikatsiyalovchi ustun mavjud. Foreign Keys: Jadvaldagi ma'lumotlarni boshqa jadvallar bilan bog'lash imkonini beradi. SQL (Structured Query Language): Relational databases bilan ishlashda ishlatiladigan standart so'rov tili.","title":"\ud83d\udc18 PostgreSQL"},{"location":"psql/postgresql/#about-postgresql","text":"PostgreSQL \u2013 bu open-source va powerful relational database management system (RDBMS). U ko'p turdagi ma'lumot turlarini qo'llab-quvvatlaydi va murakkab so'rovlar , katta hajmdagi ma'lumotlarni boshqarish imkoniyatini beradi. PostgreSQL ning asosiy afzalliklari: Open-source: PostgreSQL bepul va uni o'zgartirish yoki moslashtirish mumkin. Data Integrity: Yozilgan ma'lumotlarning to'g'ri va bir xil bo'lishini kafolatlaydi. Support for SQL and JSON: PostgreSQL relational (SQL) va JSON bilan ishlash imkoniyatini beradi, ya'ni bu ikkala usulda ma'lumot saqlash mumkin. Extensibility: PostgreSQL ni qo'shimcha modullar yordamida kengaytirish oson.","title":"About PostgreSQL"},{"location":"psql/postgresql/#install-postgresql","text":"Download PostgreSQL PostgreSQL rasmiy saytiga kirib olamiz. Download tugmasini bosamiz. Bu yerdan o'zimizga kerak bo'lgan OS ( Operating System ) ni tanlab olamiz. Bu yerdan Download the installer ni bosamiz. Bu yerdan esa PostgreSQLni versiyasini tanlashimiz mumkin.","title":"Install PostgreSQL"},{"location":"psql/postgresql/#practics","text":"PostgreSQLni o'rnatish, terminal va pgAdmin yordamida ulanish.","title":"PRACTICS"},{"location":"psql/psql-connect-in-python/","text":"Connect PostgreSQL to Python Connecting to the PostgreSQL Server import psycopg2 try: # PostgreSQL serveriga ulanish connection = psycopg2.connect( database=\"testdb\", # Yaratilgan ma'lumotlar bazasi nomi user=\"postgres\", # PostgreSQL foydalanuvchi nomi password=\"12345\", # PostgreSQL foydalanuvchi paroli host=\"localhost\", # Server manzili (localhost bu kompyuteringiz) port=\"5432\" # PostgreSQL port raqami (standart: 5432) ) print(\"PostgreSQL ga muvaffaqiyatli ulandik!\") except Exception as error: # Agar ulanishda xatolik yuz bersa, xabar chiqariladi print(\"Ulanishda xato yuz berdi:\", error) finally: if connection: # Har qanday holatda ulanish yopiladi connection.close() print(\"Ulanish yopildi.\") psycopg2.connect : Ushbu funksiya PostgreSQL serveriga ulanishni amalga oshiradi. U database , user , password , host , va port ma'lumotlarini qabul qiladi. try-except : Agar ulanishda xatolik yuz bersa, foydalanuvchi xato haqida xabar oladi. finally : Har doim bajariladi. Bu yerda ulanish (connection) yopiladi. Creating a PostgreSQL Table import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # SQL buyruqlarini bajarish uchun kursor yaratish # Jadval yaratish SQL so'rovi create_table_query = \"\"\" CREATE TABLE users ( id SERIAL PRIMARY KEY, # Avtomatik o'suvchi `id` ustuni (asosiy kalit) name VARCHAR(100), # 100 belgigacha bo'lgan matnli `name` ustuni age INT # Butun sonlarni qabul qiluvchi `age` ustuni ); \"\"\" cursor.execute(create_table_query) # SQL so'rovini bajarish connection.commit() # Jadvalni yaratishni tasdiqlash print(\"Jadval muvaffaqiyatli yaratildi.\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() # Kursorni yopish connection.close() # Ulanishni yopish print(\"Ulanish yopildi.\") cursor = connection.cursor() : cursor obyekti orqali SQL buyruqlari bajariladi. CREATE TABLE : SQL buyrug'i orqali users jadvali yaratiladi. id SERIAL PRIMARY KEY : id ustuni asosiy kalit bo'lib, avtomatik raqamlanadi. name VARCHAR(100) : name ustuni matn saqlaydi (100 ta belgigacha). age INT : age ustuni butun son saqlaydi. cursor.execute : SQL buyrug'ini bajaradi. connection.commit() : O'zgarishlarni tasdiqlaydi (ma'lumotlar bazasiga saqlaydi). Inserting Data import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # Ma'lumot qo'shish insert_query = \"\"\" INSERT INTO users (name, age) VALUES ('Ali', 25), ('Vali', 30); \"\"\" cursor.execute(insert_query) # SQL so'rovini bajarish connection.commit() # Kiritilgan ma'lumotlarni saqlash print(\"Ma'lumotlar muvaffaqiyatli qo'shildi.\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() connection.close() print(\"Ulanish yopildi.\") INSERT INTO : Jadvalga yangi ma'lumotlarni qo'shish. users (name, age) : Bu yerda users jadvaliga name va age qiymatlari kiritilmoqda. ('Ali', 25), ('Vali', 30) : Har bir qator uchun nom va yosh kiritilmoqda. cursor.execute : Kursor SQL so'rovini bajaradi. connection.commit() : Kiritilgan ma'lumotlarni tasdiqlaydi. Reading Data import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # Ma'lumotlarni o'qish select_query = \"SELECT * FROM users;\" cursor.execute(select_query) # SQL so'rovini bajarish records = cursor.fetchall() # Barcha natijalarni olish print(\"Ma'lumotlar:\") for row in records: # Har bir qatorni chop etish print(f\"ID: {row[0]}, Name: {row[1]}, Age: {row[2]}\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() connection.close() print(\"Ulanish yopildi.\") SELECT * FROM users; : users jadvalidan barcha ustunlarni o'qish. cursor.fetchall() : Barcha qatorlarni ro'yxat sifatida qaytaradi. for row in records : Har bir qatorni row orqali ko'rib chiqadi. row[0], row[1], row[2] : Jadvalning id , name , va age ustunlari qiymatlarini aks ettiradi. Updating Data import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # Ma'lumotni yangilash update_query = \"UPDATE users SET age = 26 WHERE name = 'Ali';\" cursor.execute(update_query) # SQL buyrug'ini bajarish connection.commit() # O'zgarishlarni saqlash print(\"Ma'lumot muvaffaqiyatli yangilandi.\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() connection.close() print(\"Ulanish yopildi.\") UPDATE users : users jadvalidagi ma'lumotlarni yangilash. SET age = 26 : age ustunini 26 ga o'zgartirish. WHERE name = 'Ali' : Faqat name ustunidagi Ali bo'lgan qatorni yangilash. connection.commit() : Yangilanishni tasdiqlash. Deleting Data import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # Ma'lumotlarni o'chirish delete_query = \"DELETE FROM users WHERE name = 'Ali';\" cursor.execute(delete_query) # SQL buyrug'ini bajarish connection.commit() # O'zgarishlarni tasdiqlash print(\"Ma'lumot muvaffaqiyatli o'chirildi.\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() connection.close() print(\"Ulanish yopildi.\") DELETE FROM users : users jadvalidan ma'lumotlarni o'chirish. WHERE name = 'Ali' : Faqat name ustunida Ali bo'lgan qatorni o'chiradi. connection.commit() : O'chirishni tasdiqlaydi.","title":"PostgreSQL connect in Python"},{"location":"psql/psql-connect-in-python/#connect-postgresql-to-python","text":"","title":"Connect PostgreSQL to Python"},{"location":"psql/psql-connect-in-python/#connecting-to-the-postgresql-server","text":"import psycopg2 try: # PostgreSQL serveriga ulanish connection = psycopg2.connect( database=\"testdb\", # Yaratilgan ma'lumotlar bazasi nomi user=\"postgres\", # PostgreSQL foydalanuvchi nomi password=\"12345\", # PostgreSQL foydalanuvchi paroli host=\"localhost\", # Server manzili (localhost bu kompyuteringiz) port=\"5432\" # PostgreSQL port raqami (standart: 5432) ) print(\"PostgreSQL ga muvaffaqiyatli ulandik!\") except Exception as error: # Agar ulanishda xatolik yuz bersa, xabar chiqariladi print(\"Ulanishda xato yuz berdi:\", error) finally: if connection: # Har qanday holatda ulanish yopiladi connection.close() print(\"Ulanish yopildi.\") psycopg2.connect : Ushbu funksiya PostgreSQL serveriga ulanishni amalga oshiradi. U database , user , password , host , va port ma'lumotlarini qabul qiladi. try-except : Agar ulanishda xatolik yuz bersa, foydalanuvchi xato haqida xabar oladi. finally : Har doim bajariladi. Bu yerda ulanish (connection) yopiladi.","title":"Connecting to the PostgreSQL Server"},{"location":"psql/psql-connect-in-python/#creating-a-postgresql-table","text":"import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # SQL buyruqlarini bajarish uchun kursor yaratish # Jadval yaratish SQL so'rovi create_table_query = \"\"\" CREATE TABLE users ( id SERIAL PRIMARY KEY, # Avtomatik o'suvchi `id` ustuni (asosiy kalit) name VARCHAR(100), # 100 belgigacha bo'lgan matnli `name` ustuni age INT # Butun sonlarni qabul qiluvchi `age` ustuni ); \"\"\" cursor.execute(create_table_query) # SQL so'rovini bajarish connection.commit() # Jadvalni yaratishni tasdiqlash print(\"Jadval muvaffaqiyatli yaratildi.\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() # Kursorni yopish connection.close() # Ulanishni yopish print(\"Ulanish yopildi.\") cursor = connection.cursor() : cursor obyekti orqali SQL buyruqlari bajariladi. CREATE TABLE : SQL buyrug'i orqali users jadvali yaratiladi. id SERIAL PRIMARY KEY : id ustuni asosiy kalit bo'lib, avtomatik raqamlanadi. name VARCHAR(100) : name ustuni matn saqlaydi (100 ta belgigacha). age INT : age ustuni butun son saqlaydi. cursor.execute : SQL buyrug'ini bajaradi. connection.commit() : O'zgarishlarni tasdiqlaydi (ma'lumotlar bazasiga saqlaydi).","title":"Creating a PostgreSQL Table"},{"location":"psql/psql-connect-in-python/#inserting-data","text":"import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # Ma'lumot qo'shish insert_query = \"\"\" INSERT INTO users (name, age) VALUES ('Ali', 25), ('Vali', 30); \"\"\" cursor.execute(insert_query) # SQL so'rovini bajarish connection.commit() # Kiritilgan ma'lumotlarni saqlash print(\"Ma'lumotlar muvaffaqiyatli qo'shildi.\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() connection.close() print(\"Ulanish yopildi.\") INSERT INTO : Jadvalga yangi ma'lumotlarni qo'shish. users (name, age) : Bu yerda users jadvaliga name va age qiymatlari kiritilmoqda. ('Ali', 25), ('Vali', 30) : Har bir qator uchun nom va yosh kiritilmoqda. cursor.execute : Kursor SQL so'rovini bajaradi. connection.commit() : Kiritilgan ma'lumotlarni tasdiqlaydi.","title":"Inserting Data"},{"location":"psql/psql-connect-in-python/#reading-data","text":"import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # Ma'lumotlarni o'qish select_query = \"SELECT * FROM users;\" cursor.execute(select_query) # SQL so'rovini bajarish records = cursor.fetchall() # Barcha natijalarni olish print(\"Ma'lumotlar:\") for row in records: # Har bir qatorni chop etish print(f\"ID: {row[0]}, Name: {row[1]}, Age: {row[2]}\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() connection.close() print(\"Ulanish yopildi.\") SELECT * FROM users; : users jadvalidan barcha ustunlarni o'qish. cursor.fetchall() : Barcha qatorlarni ro'yxat sifatida qaytaradi. for row in records : Har bir qatorni row orqali ko'rib chiqadi. row[0], row[1], row[2] : Jadvalning id , name , va age ustunlari qiymatlarini aks ettiradi.","title":"Reading Data"},{"location":"psql/psql-connect-in-python/#updating-data","text":"import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # Ma'lumotni yangilash update_query = \"UPDATE users SET age = 26 WHERE name = 'Ali';\" cursor.execute(update_query) # SQL buyrug'ini bajarish connection.commit() # O'zgarishlarni saqlash print(\"Ma'lumot muvaffaqiyatli yangilandi.\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() connection.close() print(\"Ulanish yopildi.\") UPDATE users : users jadvalidagi ma'lumotlarni yangilash. SET age = 26 : age ustunini 26 ga o'zgartirish. WHERE name = 'Ali' : Faqat name ustunidagi Ali bo'lgan qatorni yangilash. connection.commit() : Yangilanishni tasdiqlash.","title":"Updating Data"},{"location":"psql/psql-connect-in-python/#deleting-data","text":"import psycopg2 try: connection = psycopg2.connect( database=\"testdb\", user=\"postgres\", password=\"12345\", host=\"localhost\", port=\"5432\" ) cursor = connection.cursor() # Ma'lumotlarni o'chirish delete_query = \"DELETE FROM users WHERE name = 'Ali';\" cursor.execute(delete_query) # SQL buyrug'ini bajarish connection.commit() # O'zgarishlarni tasdiqlash print(\"Ma'lumot muvaffaqiyatli o'chirildi.\") except Exception as error: print(\"Xato yuz berdi:\", error) finally: if connection: cursor.close() connection.close() print(\"Ulanish yopildi.\") DELETE FROM users : users jadvalidan ma'lumotlarni o'chirish. WHERE name = 'Ali' : Faqat name ustunida Ali bo'lgan qatorni o'chiradi. connection.commit() : O'chirishni tasdiqlaydi.","title":"Deleting Data"},{"location":"python/","text":"Table Of Content What is Python","title":"Table Of Content"},{"location":"python/#table-of-content","text":"What is Python","title":"Table Of Content"},{"location":"python/conditional-statements/","text":"\ud83e\udde9 8-DARS IF...ELIF...ELSE.. TARMOQLANISH \ud83d\udccc Shu vaqtgacha yozgan dasturlarimizga e'tibor bersangiz, dasturimiz yuqoridan pastga qarab qatorma-qator bajarilib keldi. Bu chiziqli dastur deyiladi. Ammo ba'zida shartga qarab kodning bir qismidan boshqa qismiga o'tish zarur bo'ladi. Bunday holat \"tarmoqlanish\" deb ataladi. \ud83d\udccc Python dasturlash tilida shart operatorlari ( conditional statements ) dasturda turli vaziyatlarga qarab turli amallarni bajarishga imkon beradi. \u2705 IF \ud83d\udccc Python dasturlash tilida if operatori shartni tekshirish uchun ishlatiladi. Ya'ni, agar biror shart True bo\u2018lsa, unga tegishli kodlar bajariladi. Agar shart False bo\u2018lsa, kod bajarilmaydi. # Bankdagi hisobdagi pul miqdori account_balance = 1500 # Agar balans 1000 dan katta bo\u2018lsa, foydalanuvchi pul yechishi mumkin if account_balance > 1000: print(\"You can withdraw money\") # Foydalanuvchiga ruxsat beriladi # Foydalanuvchining savatidagi umumiy mahsulot narxi total_price = 250 # Agar narx 200 dan katta bo\u2018lsa, bepul yetkazib berish taklif qilinadi if total_price > 200: print(\"You qualify for free shipping\") # Bepul yetkazib berish haqida xabar # Foydalanuvchi kiritgan parol password = \"mysecurepass\" # Agar parol uzunligi 8 belgidan ko\u2018p bo\u2018lsa, kuchli parol deb baholanadi if len(password) > 8: print(\"Your password is strong\") # Kuchli parol haqida xabar \u2705 ELSE \ud83d\udccc Python dasturlash tilida else operatori if dan keyin yoziladi. Agar if dagi False bo;lsa, else ichidagi kodlar bajariladi. # Foydalanuvchi shakarmi tanladi (ha yoki yo'q) wants_sugar = True # Agar foydalanuvchi shakar istasa if wants_sugar: print(\"Adding sugar to your coffee\") # Qahvaga shakar qo\u2018shiladi else: print(\"Preparing your coffee without sugar\") # Shakarsiz qahva tayyorlanadi # Telefon quvvati foizda battery_percentage = 15 # Agar quvvat 20 dan kam bo\u2018lsa, ogohlantirish chiqariladi if battery_percentage < 20: print(\"Battery is low. Please charge your phone.\") # Quvvat kamligi haqida ogohlantirish else: print(\"Battery level is sufficient.\") # Quvvat yetarli # Talabaning olgan bahosi exam_score = 72 # Agar baho 60 yoki undan yuqori bo\u2018lsa, imtihondan o\u2018tgan hisoblanadi if exam_score >= 60: print(\"You passed the exam!\") # O\u2018tdi degan xabar else: print(\"You failed the exam.\") # Yiqildi degan xabar \u2705 LIST BILAN ISHLASH \ud83c\udfaf Onlayn do\u2018konda foydalanuvchi savatida kamida 1 mahsulot borligini va maxsus mahsulot bor-yo\u2018qligini tekshirish: # Xaridor savatidagi mahsulotlar ro'yxati shopping_cart = [\"bread\", \"sugar\", \"apple\"] # Agar savatda kamida bitta mahsulot bo\u2018lsa if shopping_cart: print(\"The cart has items\") # Savatda mahsulot borligi haqida xabar else: print(\"The cart is empty\") # Savat bo\u2018shligi haqida xabar # Agar savatda 'sugar' bo\u2018lsa if \"sugar\" in shopping_cart: print(\"Sugar is in the cart\") # Shakar mavjudligi haqida xabar else: print(\"Sugar is not in the cart\") # Shakar yo\u2018qligi haqida xabar # Agar savatda 5 ta yoki undan ko\u2018p mahsulot bo\u2018lsa, bepul yetkazib berish if len(shopping_cart) >= 5: print(\"Free delivery available\") # Bepul yetkazib berish else: print(\"Delivery charges apply\") # Pullik yetkazib berish \u2705 TUPLE BILAN ISHLASH \ud83c\udfaf Foydalanuvchining geolokatsiyasi asosida joylashuvni aniqlash # Foydalanuvchining geografik joylashuvi (kenglik, uzunlik) user_location = (41.2995, 69.2401) # Toshkent koordinatalari # Agar joylashuv ma'lum bo\u2018lsa (ya'ni tuple bo\u2018sh bo\u2018lmasa) if user_location: print(\"Location detected\") # Joylashuv aniqlandi else: print(\"Location not available\") # Joylashuv topilmadi # Foydalanuvchi O'zbekiston hududida joylashganmi \u2013 kenglik bo\u2018yicha tekshiramiz if 41.0 <= user_location[0] <= 42.0: print(\"User is located in Uzbekistan\") # Foydalanuvchi O\u2018zbekistonda else: print(\"User is outside of Uzbekistan\") # Foydalanuvchi boshqa mamlakatda \u2705 SET BILAN ISHLASH \ud83c\udfaf Saytga kirgan foydalanuvchilar ID raqamlari setda saqlanadi, va admin ularni tekshiradi. # Bugun saytga kirgan foydalanuvchilarning ID raqamlari (takrorlanmaydi) active_user_ids = {101, 202, 303, 404} # Agar kamida bitta foydalanuvchi saytga kirgan bo\u2018lsa if active_user_ids: print(\"Bugun saytga foydalanuvchilar kirgan\") # Foydalanuvchilar bor # Aks holda, hech kim kirmagan bo\u2018ladi else: print(\"Hali hech kim saytga kirmagan\") # Set bo\u2018sh # Agar 202-ID foydalanuvchi kirgan bo\u2018lsa if 202 in active_user_ids: print(\"202-ID foydalanuvchi tizimga kirgan\") # Shu ID topildi else: print(\"202-ID foydalanuvchi hali kirmagan\") # Shu ID yo\u2018q # Bugun kirgan foydalanuvchilar soni 100 dan oshgan bo\u2018lsa if len(active_user_ids) > 100: print(\"Yuqori aktivlik\") # Juda ko\u2018p foydalanuvchi else: print(\"Oddiy kun\") # Odatdagi foydalanuvchi soni \u2705 DICTIONARY BILAN ISHLASH: \ud83c\udfaf Foydalanuvchi registratsiya qilganda u haqidagi ma\u2019lumotlar dictionaryda saqlanadi. # Dictionary: foydalanuvchining asosiy profili user_profile = { \"name\": \"Umid\", \"email\": \"umid@example.com\", \"age\": 23 } # Agar foydalanuvchiga oid ma'lumotlar mavjud bo\u2018lsa if user_profile: print(\"User profile data is available\") # Ma'lumotlar bor else: print(\"No user data found\") # Ma'lumotlar yo\u2018q # Agar email kaliti mavjud bo\u2018lsa if \"email\" in user_profile: print(\"Email is provided\") # Email mavjud else: print(\"Email is missing\") # Email kiritilmagan # Agar foydalanuvchi yoshi 18 yoki undan katta bo\u2018lsa if user_profile.get(\"age\", 0) >= 18: print(\"User is an adult\") # Voyaga yetgan else: print(\"User is a minor\") # Voyaga yetmagan # Profil to\u2018liq deb hisoblanadi, agar kamida 3 ta kalit bo\u2018lsa if len(user_profile) >= 3: print(\"Profile is complete\") # To\u2018liq profil else: print(\"Profile is incomplete\") # To\u2018liq bo\u2018lmagan profil \u2705 ELIF elif \u2014 bu else if degan so\u2018zning qisqargan ko\u2018rinishi. U bir nechta shartlarni ketma-ket tekshirish uchun ishlatiladi. Agar if sharti False bo'lsa, elif sharti tekshiriladi. \ud83c\udfaf Smart uydagi HVAC tizimi xonadagi haroratga qarab qaror qabul qiladi. # Current room temperature in Celsius room_temperature = 28 # Xona harorati, Celsiy bo\u2018yicha # Agar xona juda sovuq bo\u2018lsa (18\u00b0C dan past) if room_temperature < 18: print(\"Heating system should be turned ON\") # Isitish tizimi yoqiladi # Agar xona juda issiq bo\u2018lsa (26\u00b0C dan yuqori) elif room_temperature > 26: print(\"Cooling system should be turned ON\") # Sovutish tizimi yoqiladi # Aks holda, harorat me'yorda else: print(\"Temperature is optimal, no action needed\") # Hech qanday tizim yoqilmaydi \ud83c\udfaf Onlayn do\u2018konda har bir buyurtmaning holatini aniqlash uchun ishlatiladi. # Order status (current stage of delivery process) order_status = \"shipped\" # \"yuborilgan\" degani # Agar buyurtma qabul qilingan bo\u2018lsa if order_status == \"received\": print(\"Your order has been received and will be prepared soon.\") # Buyurtma qabul qilindi # Agar tayyorlanayotgan bo\u2018lsa elif order_status == \"preparing\": print(\"Your order is currently being prepared.\") # Tayyorlanmoqda # Agar yuborilgan bo\u2018lsa elif order_status == \"shipped\": print(\"Your order has been shipped.\") # Yo\u2018lga chiqdi # Agar yetkazilgan bo\u2018lsa elif order_status == \"delivered\": print(\"Your order has been delivered.\") # Yetkazildi # Nomalum holatlar uchun else: print(\"Unknown order status.\") # Noma'lum status \u2705 BIR NECHTA SHARTLARNI BIRGA ISHLATISH \ud83c\udfaf Login tizimi \u2013 foydalanuvchini tekshirish. Foydalanuvchi login va parolni to\u2018g\u2018ri kiritganmi, tekshiramiz. # Foydalanuvchi kiritgan login va parol entered_username = \"umid\" entered_password = \"python123\" # To\u2018g\u2018ri login va parol kiritilgan bo\u2018lsa if entered_username == \"umid\" and entered_password == \"python123\": print(\"Welcome, Umid!\") # Xush kelibsiz! # Login to\u2018g\u2018ri, lekin parol noto\u2018g\u2018ri bo\u2018lsa elif entered_username == \"umid\" and entered_password != \"python123\": print(\"Incorrect password\") # Parol xato # Parol to\u2018g\u2018ri, lekin login noto\u2018g\u2018ri bo\u2018lsa elif entered_username != \"umid\" and entered_password == \"python123\": print(\"Incorrect username\") # Login xato # Ikkalasi ham noto\u2018g\u2018ri bo\u2018lsa else: print(\"Incorrect username and password\") # Ikkalasi ham xato \ud83c\udfaf Ob-havo ilovasi \u2013 kiyim tavsiyasi. Foydalanuvchiga havo haroratiga qarab tavsiya beriladi. # Ob-havo holati: havo harorati va yomg\u2018ir yog\u2018yaptimi yo\u2018qmi temperature = 32 # Havo harorati (\u00b0C) is_raining = False # Yomg\u2018ir yog\u2018ayotgan bo\u2018lsa True, aks holda False # Juda sovuq bo\u2018lsa (0\u00b0C yoki undan past) if temperature <= 0: print(\"It is very cold. Wear warm clothes.\") # Qalin kiyim tavsiya qilinadi # Salqin bo\u2018lsa (1\u00b0C dan 15\u00b0C gacha) elif temperature <= 15: print(\"It's cool outside. A light jacket is recommended.\") # Yengil kurtka kiying # Juda issiq yoki yomg\u2018irli bo\u2018lsa elif temperature >= 30 or is_raining: print(\"Hot or rainy weather \u2013 wear light clothes and carry an umbrella.\") # Soyabon va yengil kiyim # Ob-havo normal bo\u2018lsa else: print(\"The weather is normal. Regular clothes are fine.\") # Oddiy kiyim yetarli \ud83c\udfaf Internet tezligiga qarab videoning sifat darajasi belgilanadi. # Foydalanuvchi internetga ulanmagan bo\u2018lsa, bu True/False qiymatni bildiradi is_connected = True # Internet tezligi (Mbit/s) internet_speed = 2.5 # Agar internetga ulanmagan bo\u2018lsa if not is_connected: print(\"Not connected to the internet\") # Internet yo\u2018q # Juda past tezlikda elif internet_speed < 1: print(\"Video quality: 144p (very low)\") # Juda past sifat # O\u2018rtacha past tezlikda elif internet_speed < 3: print(\"Video quality: 360p (low)\") # Past sifat # O\u2018rta tezlikda elif internet_speed < 6: print(\"Video quality: 720p (medium)\") # O\u2018rtacha sifat # Yuqori tezlikda else: print(\"Video quality: 1080p (high)\") # Yuqori sifat \u2705 NESTED CONDITIONS \ud83d\udccc Shart operatorlarini bir-birining ichiga joylashtirish orqali murakkabroq mantiqiy holatlar yaratish mumkin. \ud83c\udfaf Foydalanuvchi login kiritadi, agar mavjud bo\u2018lsa, yoshi tekshiriladi. Faqat voyaga yetganlarga ruxsat. # Foydalanuvchi nomi (sistemaga kirishga urinayotgan) username = \"umid\" # Foydalanuvchilar ro'yxati (username: age) users = { \"umid\": 21, \"ali\": 17 } # Avvalo foydalanuvchi ro'yxatda bormi \u2013 tekshiramiz if username in users: age = users[username] # Username bo\u2018yicha yoshni olamiz # Agar foydalanuvchi 18 yoki undan katta bo\u2018lsa \u2013 ruxsat beriladi if age >= 18: print(f\"{username.title()} is allowed to access the system.\") # Ruxsat berildi # Agar foydalanuvchi voyaga yetmagan bo\u2018lsa \u2013 ruxsat berilmaydi else: print(f\"{username.title()} is underage. Access denied.\") # Ruxsat yo\u2018q else: print(\"User not found in the system.\") # Bunday foydalanuvchi yo\u2018q \ud83c\udfaf Foydalanuvchi balansiga qarab faqat ruxsat etilgan tranzaksiyani bajarish mumkin. # User's current balance balance = 500_000 # 500 ming so\u2018m # Transaction type: \"withdraw\" (yechish) yoki \"deposit\" (kiritish) transaction_type = \"withdraw\" # Transaction amount (so\u2018mda) amount = 300_000 # Agar foydalanuvchi pul yechmoqchi bo\u2018lsa if transaction_type == \"withdraw\": # Mablag' yetarlimi? Yechishga ruxsat beriladi if balance >= amount: print(f\"{amount} so'm has been successfully withdrawn.\") # Pul yechildi else: print(\"Insufficient balance.\") # Pul yetarli emas # Agar foydalanuvchi balansga pul kiritmoqchi bo\u2018lsa elif transaction_type == \"deposit\": print(f\"{amount} so'm has been added to your balance.\") # Pul kiritildi # Aks holda, tranzaksiya turi noto\u2018g\u2018ri else: print(\"Invalid transaction type.\") # Noma'lum amal \ud83c\udfaf Agar foydalanuvchi o\u2018qituvchi bo\u2018lsa, yangi kurs yarata oladi. Talaba bo\u2018lsa, faqat yozilishi mumkin. # Foydalanuvchining ma'lumotlari (ismi, roli, holati) user = { \"name\": \"Umid\", \"role\": \"student\", # \"student\" yoki \"teacher\" \"active\": True # Foydalanuvchi faolligi } # Agar foydalanuvchi faollashtirilgan bo\u2018lsa if user[\"active\"]: # Agar foydalanuvchi o\u2018qituvchi bo\u2018lsa if user[\"role\"] == \"teacher\": print(\"You can create a new course.\") # Yangi kurs yaratish huquqi bor # Agar foydalanuvchi talaba bo\u2018lsa elif user[\"role\"] == \"student\": print(\"You can enroll in a course.\") # Kursga yozilish huquqi bor # Boshqa noma'lum rollar uchun else: print(\"Your role is not recognized.\") # Rol noto\u2018g\u2018ri yoki mavjud emas # Agar foydalanuvchi faollashtirilmagan bo\u2018lsa else: print(\"User is not active.\") # Foydalanuvchi faol emas \u2705 MULTIPLE LEVELS OF NESTED CONDITIONAL STATEMENTS \ud83c\udfaf Ma'lumotlar bazasida foydalanuvchi ro\u2018yxatdan o\u2018tganmi, email tasdiqlanganmi va yoshi to\u2018liqmi \u2014 shu tartibda tekshiriladi: # Foydalanuvchining ro\u2018yxatdan o\u2018tganligi, email holati va yoshi user = { \"username\": \"umid\", \"registered\": True, # Foydalanuvchi ro'yxatdan o'tganmi? \"email_verified\": True, # Email tasdiqlanganmi? \"age\": 19 # Foydalanuvchi yoshi } # 1. Avval foydalanuvchi ro\u2018yxatdan o\u2018tganligini tekshiramiz if user[\"registered\"]: # 2. Email tasdiqlanganligini tekshiramiz if user[\"email_verified\"]: # 3. Yoshi 18 yoki undan katta bo\u2018lsa \u2013 to\u2018liq ruxsat beriladi if user[\"age\"] >= 18: print(\"Full access granted to the system.\") # To\u2018liq ruxsat else: print(\"Access denied. You must be at least 18 years old.\") # Yoshi yetmaydi else: print(\"Email not verified. Please verify your email first.\") # Email tasdiqlanmagan else: print(\"You are not registered. Please sign up first.\") # Ro\u2018yxatdan o\u2018tmagan \ud83c\udfaf Avtomobil ijarasi faqat quyidagi shartlar bajarilganda mumkin: Foydalanuvchi ro\u2018yxatdan o\u2018tgan Haydovchilik guvohnomasi mavjud Yoshi 21 dan katta # User data: registration, license availability, and age user = { \"registered\": True, # Foydalanuvchi ro\u2018yxatdan o\u2018tganmi? \"has_license\": True, # Haydovchilik guvohnomasi bormi? \"age\": 25 # Foydalanuvchining yoshi } # 1. Foydalanuvchi ro\u2018yxatdan o\u2018tgan bo\u2018lishi kerak if user[\"registered\"]: # 2. Haydovchilik guvohnomasi mavjud bo\u2018lishi kerak if user[\"has_license\"]: # 3. Yoshi 21 dan katta yoki teng bo\u2018lishi kerak if user[\"age\"] >= 21: print(\"Car rental approved.\") # Ijaraga ruxsat berildi else: print(\"You must be at least 21 years old to rent a car.\") # Yoshi yetmaydi else: print(\"You must have a valid driver\u2019s license.\") # Guvohnoma yo\u2018q else: print(\"Please register before renting a car.\") # Ro\u2018yxatdan o\u2018tmagan \u2705 AMALIYOT \u2705 1-topshiriq: Foydalanuvchidan yoshini so\u2018rang. Agar 18 dan kichik bo\u2018lsa \"Voyaga yetmagan\" , 18 yoki undan katta bo\u2018lsa \"Voyaga yetgan\" deb chiqaring. \u2705 2-topshiriq: Quyidagi o\u2018zgaruvchi berilgan: score = 87 Agar score 90 va undan yuqori bo\u2018lsa \"A\" , 80-89 oralig\u2018ida bo\u2018lsa \"B\" , 70-79 oralig\u2018ida bo\u2018lsa \"C\" , boshqacha bo\u2018lsa \"D\" baho chiqaring. \u2705 3-topshiriq: Quyidagi o\u2018zgaruvchi berilgan: is_raining = True Agar is_raining True bo\u2018lsa \"Soyabon oling\" , aks holda \"Yomg\u2018ir yo\u2018q\" deb chiqaring. \u2705 4-topshiriq: Quyidagi ro\u2018yxat berilgan: fruits = [\"olma\", \"banan\", \"gilos\"] Agar ro\u2018yxatda \"banan\" bo\u2018lsa \"Banan bor\" , bo\u2018lmasa \"Banan yo\u2018q\" deb chiqaring. \u2705 5-topshiriq: Ro\u2018yxatda kamida 5 ta element bo\u2018lsa \"Ro\u2018yxat to\u2018la\" , aks holda \"Ro\u2018yxat qisqa\" deb chiqaring: nums = [1, 4, 7, 10] \u2705 6-topshiriq: Tuple berilgan: location = (41.2, 69.1) Agar location bo\u2018sh bo\u2018lmasa \"Joylashuv aniqlangan\" , bo\u2018sh bo\u2018lsa \"Joylashuv yo\u2018q\" deb chiqaring. \u2705 7-topshiriq: Set berilgan: active_ids = {1, 2, 3} Agar 2-ID setda mavjud bo\u2018lsa \"2-ID mavjud\" , bo\u2018lmasa \"2-ID yo\u2018q\" deb chiqaring. \u2705 8-topshiriq: Quyidagi dictionary berilgan: profile = {\"name\": \"Alim\", \"age\": 15} Agar age 18 yoki undan katta bo\u2018lsa \"Voyaga yetgan\" , aks holda \"Voyaga yetmagan\" deb chiqaring. \u2705 9-topshiriq: Quyidagi o\u2018zgaruvchilar berilgan: is_logged_in = True is_admin = False Agar foydalanuvchi tizimga kirgan va admin bo\u2018lsa \"Admin panelga xush kelibsiz\" , faqat tizimga kirgan bo\u2018lsa \"Foydalanuvchi paneli\" , har ikkisi ham False bo\u2018lsa \"Kirish talab qilinadi\" . \u2705 10-topshiriq: Quyidagi kodni if...elif...else bilan yozing: temp o\u2018zgaruvchisi bo\u2018yicha: - 0 dan past \"Muzlab qolgan\" - 0-15 oralig\u2018ida \"Salqin\" - 16-30 oralig\u2018ida \"Me'yoriy\" - 30 dan yuqori \"Issiq\" temp = 23 \u2705 11-topshiriq: Ro\u2018yxatda \"python\" va \"sql\" bo\u2018lsa \"Ikkalasi ham bor\" , faqat bittasi bo\u2018lsa \"Bittasi bor\" , ikkalasi ham bo\u2018lmasa \"Ikkalasi ham yo\u2018q\" deb chiqaring: skills = [\"html\", \"python\", \"css\"] \u2705 12-topshiriq: Foydalanuvchi parol kiritadi. Agar parol uzunligi 10 dan katta bo\u2018lsa \"Kuchli parol\" , 6-10 oralig\u2018ida bo\u2018lsa \"O\u2018rtacha parol\" , 6 dan kam bo\u2018lsa \"Juda qisqa\" . \u2705 13-topshiriq: Quyidagi dictionary berilgan: user = {\"username\": \"nargiza\", \"active\": True, \"role\": \"student\"} Agar user active va roli \"teacher\" bo\u2018lsa \"Yangi kurs yarata oladi\" , active va roli \"student\" bo\u2018lsa \"Faqat kursga yozila oladi\" , aks holda \"Ruxsat yo\u2018q\" . \u2705 14-topshiriq: Quyidagi o\u2018zgaruvchilar berilgan: speed = 7.2 is_connected = True Agar is_connected False bo\u2018lsa \"Internet yo\u2018q\" , else if speed < 1 bo\u2018lsa \"Eng past sifat\" , speed < 5 bo\u2018lsa \"O\u2018rtacha sifat\" , else \"Yuqori sifat\" . \u2705 15-topshiriq: Quyidagi dictionarylar orqali avtomobil ijarasi uchun quyidagilarni tekshiring: - \"registered\": True - \"has_license\": True - \"age\": 19 Agar hammasi to\u2018g\u2018ri bo\u2018lsa \"Ijaraga ruxsat\" , aks holda qaysi shart bajarilmaganini chiqaring.","title":"Conditional Statements"},{"location":"python/conditional-statements/#8-dars-ifelifelse","text":"","title":"\ud83e\udde9 8-DARS IF...ELIF...ELSE.."},{"location":"python/conditional-statements/#tarmoqlanish","text":"\ud83d\udccc Shu vaqtgacha yozgan dasturlarimizga e'tibor bersangiz, dasturimiz yuqoridan pastga qarab qatorma-qator bajarilib keldi. Bu chiziqli dastur deyiladi. Ammo ba'zida shartga qarab kodning bir qismidan boshqa qismiga o'tish zarur bo'ladi. Bunday holat \"tarmoqlanish\" deb ataladi. \ud83d\udccc Python dasturlash tilida shart operatorlari ( conditional statements ) dasturda turli vaziyatlarga qarab turli amallarni bajarishga imkon beradi.","title":"TARMOQLANISH"},{"location":"python/conditional-statements/#if","text":"\ud83d\udccc Python dasturlash tilida if operatori shartni tekshirish uchun ishlatiladi. Ya'ni, agar biror shart True bo\u2018lsa, unga tegishli kodlar bajariladi. Agar shart False bo\u2018lsa, kod bajarilmaydi. # Bankdagi hisobdagi pul miqdori account_balance = 1500 # Agar balans 1000 dan katta bo\u2018lsa, foydalanuvchi pul yechishi mumkin if account_balance > 1000: print(\"You can withdraw money\") # Foydalanuvchiga ruxsat beriladi # Foydalanuvchining savatidagi umumiy mahsulot narxi total_price = 250 # Agar narx 200 dan katta bo\u2018lsa, bepul yetkazib berish taklif qilinadi if total_price > 200: print(\"You qualify for free shipping\") # Bepul yetkazib berish haqida xabar # Foydalanuvchi kiritgan parol password = \"mysecurepass\" # Agar parol uzunligi 8 belgidan ko\u2018p bo\u2018lsa, kuchli parol deb baholanadi if len(password) > 8: print(\"Your password is strong\") # Kuchli parol haqida xabar","title":"\u2705 IF"},{"location":"python/conditional-statements/#else","text":"\ud83d\udccc Python dasturlash tilida else operatori if dan keyin yoziladi. Agar if dagi False bo;lsa, else ichidagi kodlar bajariladi. # Foydalanuvchi shakarmi tanladi (ha yoki yo'q) wants_sugar = True # Agar foydalanuvchi shakar istasa if wants_sugar: print(\"Adding sugar to your coffee\") # Qahvaga shakar qo\u2018shiladi else: print(\"Preparing your coffee without sugar\") # Shakarsiz qahva tayyorlanadi # Telefon quvvati foizda battery_percentage = 15 # Agar quvvat 20 dan kam bo\u2018lsa, ogohlantirish chiqariladi if battery_percentage < 20: print(\"Battery is low. Please charge your phone.\") # Quvvat kamligi haqida ogohlantirish else: print(\"Battery level is sufficient.\") # Quvvat yetarli # Talabaning olgan bahosi exam_score = 72 # Agar baho 60 yoki undan yuqori bo\u2018lsa, imtihondan o\u2018tgan hisoblanadi if exam_score >= 60: print(\"You passed the exam!\") # O\u2018tdi degan xabar else: print(\"You failed the exam.\") # Yiqildi degan xabar","title":"\u2705 ELSE"},{"location":"python/conditional-statements/#list-bilan-ishlash","text":"\ud83c\udfaf Onlayn do\u2018konda foydalanuvchi savatida kamida 1 mahsulot borligini va maxsus mahsulot bor-yo\u2018qligini tekshirish: # Xaridor savatidagi mahsulotlar ro'yxati shopping_cart = [\"bread\", \"sugar\", \"apple\"] # Agar savatda kamida bitta mahsulot bo\u2018lsa if shopping_cart: print(\"The cart has items\") # Savatda mahsulot borligi haqida xabar else: print(\"The cart is empty\") # Savat bo\u2018shligi haqida xabar # Agar savatda 'sugar' bo\u2018lsa if \"sugar\" in shopping_cart: print(\"Sugar is in the cart\") # Shakar mavjudligi haqida xabar else: print(\"Sugar is not in the cart\") # Shakar yo\u2018qligi haqida xabar # Agar savatda 5 ta yoki undan ko\u2018p mahsulot bo\u2018lsa, bepul yetkazib berish if len(shopping_cart) >= 5: print(\"Free delivery available\") # Bepul yetkazib berish else: print(\"Delivery charges apply\") # Pullik yetkazib berish","title":"\u2705 LIST BILAN ISHLASH"},{"location":"python/conditional-statements/#tuple-bilan-ishlash","text":"\ud83c\udfaf Foydalanuvchining geolokatsiyasi asosida joylashuvni aniqlash # Foydalanuvchining geografik joylashuvi (kenglik, uzunlik) user_location = (41.2995, 69.2401) # Toshkent koordinatalari # Agar joylashuv ma'lum bo\u2018lsa (ya'ni tuple bo\u2018sh bo\u2018lmasa) if user_location: print(\"Location detected\") # Joylashuv aniqlandi else: print(\"Location not available\") # Joylashuv topilmadi # Foydalanuvchi O'zbekiston hududida joylashganmi \u2013 kenglik bo\u2018yicha tekshiramiz if 41.0 <= user_location[0] <= 42.0: print(\"User is located in Uzbekistan\") # Foydalanuvchi O\u2018zbekistonda else: print(\"User is outside of Uzbekistan\") # Foydalanuvchi boshqa mamlakatda","title":"\u2705 TUPLE BILAN ISHLASH"},{"location":"python/conditional-statements/#set-bilan-ishlash","text":"\ud83c\udfaf Saytga kirgan foydalanuvchilar ID raqamlari setda saqlanadi, va admin ularni tekshiradi. # Bugun saytga kirgan foydalanuvchilarning ID raqamlari (takrorlanmaydi) active_user_ids = {101, 202, 303, 404} # Agar kamida bitta foydalanuvchi saytga kirgan bo\u2018lsa if active_user_ids: print(\"Bugun saytga foydalanuvchilar kirgan\") # Foydalanuvchilar bor # Aks holda, hech kim kirmagan bo\u2018ladi else: print(\"Hali hech kim saytga kirmagan\") # Set bo\u2018sh # Agar 202-ID foydalanuvchi kirgan bo\u2018lsa if 202 in active_user_ids: print(\"202-ID foydalanuvchi tizimga kirgan\") # Shu ID topildi else: print(\"202-ID foydalanuvchi hali kirmagan\") # Shu ID yo\u2018q # Bugun kirgan foydalanuvchilar soni 100 dan oshgan bo\u2018lsa if len(active_user_ids) > 100: print(\"Yuqori aktivlik\") # Juda ko\u2018p foydalanuvchi else: print(\"Oddiy kun\") # Odatdagi foydalanuvchi soni","title":"\u2705 SET BILAN ISHLASH"},{"location":"python/conditional-statements/#dictionary-bilan-ishlash","text":"\ud83c\udfaf Foydalanuvchi registratsiya qilganda u haqidagi ma\u2019lumotlar dictionaryda saqlanadi. # Dictionary: foydalanuvchining asosiy profili user_profile = { \"name\": \"Umid\", \"email\": \"umid@example.com\", \"age\": 23 } # Agar foydalanuvchiga oid ma'lumotlar mavjud bo\u2018lsa if user_profile: print(\"User profile data is available\") # Ma'lumotlar bor else: print(\"No user data found\") # Ma'lumotlar yo\u2018q # Agar email kaliti mavjud bo\u2018lsa if \"email\" in user_profile: print(\"Email is provided\") # Email mavjud else: print(\"Email is missing\") # Email kiritilmagan # Agar foydalanuvchi yoshi 18 yoki undan katta bo\u2018lsa if user_profile.get(\"age\", 0) >= 18: print(\"User is an adult\") # Voyaga yetgan else: print(\"User is a minor\") # Voyaga yetmagan # Profil to\u2018liq deb hisoblanadi, agar kamida 3 ta kalit bo\u2018lsa if len(user_profile) >= 3: print(\"Profile is complete\") # To\u2018liq profil else: print(\"Profile is incomplete\") # To\u2018liq bo\u2018lmagan profil","title":"\u2705 DICTIONARY BILAN ISHLASH:"},{"location":"python/conditional-statements/#elif","text":"elif \u2014 bu else if degan so\u2018zning qisqargan ko\u2018rinishi. U bir nechta shartlarni ketma-ket tekshirish uchun ishlatiladi. Agar if sharti False bo'lsa, elif sharti tekshiriladi. \ud83c\udfaf Smart uydagi HVAC tizimi xonadagi haroratga qarab qaror qabul qiladi. # Current room temperature in Celsius room_temperature = 28 # Xona harorati, Celsiy bo\u2018yicha # Agar xona juda sovuq bo\u2018lsa (18\u00b0C dan past) if room_temperature < 18: print(\"Heating system should be turned ON\") # Isitish tizimi yoqiladi # Agar xona juda issiq bo\u2018lsa (26\u00b0C dan yuqori) elif room_temperature > 26: print(\"Cooling system should be turned ON\") # Sovutish tizimi yoqiladi # Aks holda, harorat me'yorda else: print(\"Temperature is optimal, no action needed\") # Hech qanday tizim yoqilmaydi \ud83c\udfaf Onlayn do\u2018konda har bir buyurtmaning holatini aniqlash uchun ishlatiladi. # Order status (current stage of delivery process) order_status = \"shipped\" # \"yuborilgan\" degani # Agar buyurtma qabul qilingan bo\u2018lsa if order_status == \"received\": print(\"Your order has been received and will be prepared soon.\") # Buyurtma qabul qilindi # Agar tayyorlanayotgan bo\u2018lsa elif order_status == \"preparing\": print(\"Your order is currently being prepared.\") # Tayyorlanmoqda # Agar yuborilgan bo\u2018lsa elif order_status == \"shipped\": print(\"Your order has been shipped.\") # Yo\u2018lga chiqdi # Agar yetkazilgan bo\u2018lsa elif order_status == \"delivered\": print(\"Your order has been delivered.\") # Yetkazildi # Nomalum holatlar uchun else: print(\"Unknown order status.\") # Noma'lum status","title":"\u2705 ELIF"},{"location":"python/conditional-statements/#bir-nechta-shartlarni-birga-ishlatish","text":"\ud83c\udfaf Login tizimi \u2013 foydalanuvchini tekshirish. Foydalanuvchi login va parolni to\u2018g\u2018ri kiritganmi, tekshiramiz. # Foydalanuvchi kiritgan login va parol entered_username = \"umid\" entered_password = \"python123\" # To\u2018g\u2018ri login va parol kiritilgan bo\u2018lsa if entered_username == \"umid\" and entered_password == \"python123\": print(\"Welcome, Umid!\") # Xush kelibsiz! # Login to\u2018g\u2018ri, lekin parol noto\u2018g\u2018ri bo\u2018lsa elif entered_username == \"umid\" and entered_password != \"python123\": print(\"Incorrect password\") # Parol xato # Parol to\u2018g\u2018ri, lekin login noto\u2018g\u2018ri bo\u2018lsa elif entered_username != \"umid\" and entered_password == \"python123\": print(\"Incorrect username\") # Login xato # Ikkalasi ham noto\u2018g\u2018ri bo\u2018lsa else: print(\"Incorrect username and password\") # Ikkalasi ham xato \ud83c\udfaf Ob-havo ilovasi \u2013 kiyim tavsiyasi. Foydalanuvchiga havo haroratiga qarab tavsiya beriladi. # Ob-havo holati: havo harorati va yomg\u2018ir yog\u2018yaptimi yo\u2018qmi temperature = 32 # Havo harorati (\u00b0C) is_raining = False # Yomg\u2018ir yog\u2018ayotgan bo\u2018lsa True, aks holda False # Juda sovuq bo\u2018lsa (0\u00b0C yoki undan past) if temperature <= 0: print(\"It is very cold. Wear warm clothes.\") # Qalin kiyim tavsiya qilinadi # Salqin bo\u2018lsa (1\u00b0C dan 15\u00b0C gacha) elif temperature <= 15: print(\"It's cool outside. A light jacket is recommended.\") # Yengil kurtka kiying # Juda issiq yoki yomg\u2018irli bo\u2018lsa elif temperature >= 30 or is_raining: print(\"Hot or rainy weather \u2013 wear light clothes and carry an umbrella.\") # Soyabon va yengil kiyim # Ob-havo normal bo\u2018lsa else: print(\"The weather is normal. Regular clothes are fine.\") # Oddiy kiyim yetarli \ud83c\udfaf Internet tezligiga qarab videoning sifat darajasi belgilanadi. # Foydalanuvchi internetga ulanmagan bo\u2018lsa, bu True/False qiymatni bildiradi is_connected = True # Internet tezligi (Mbit/s) internet_speed = 2.5 # Agar internetga ulanmagan bo\u2018lsa if not is_connected: print(\"Not connected to the internet\") # Internet yo\u2018q # Juda past tezlikda elif internet_speed < 1: print(\"Video quality: 144p (very low)\") # Juda past sifat # O\u2018rtacha past tezlikda elif internet_speed < 3: print(\"Video quality: 360p (low)\") # Past sifat # O\u2018rta tezlikda elif internet_speed < 6: print(\"Video quality: 720p (medium)\") # O\u2018rtacha sifat # Yuqori tezlikda else: print(\"Video quality: 1080p (high)\") # Yuqori sifat","title":"\u2705 BIR NECHTA SHARTLARNI BIRGA ISHLATISH"},{"location":"python/conditional-statements/#nested-conditions","text":"\ud83d\udccc Shart operatorlarini bir-birining ichiga joylashtirish orqali murakkabroq mantiqiy holatlar yaratish mumkin. \ud83c\udfaf Foydalanuvchi login kiritadi, agar mavjud bo\u2018lsa, yoshi tekshiriladi. Faqat voyaga yetganlarga ruxsat. # Foydalanuvchi nomi (sistemaga kirishga urinayotgan) username = \"umid\" # Foydalanuvchilar ro'yxati (username: age) users = { \"umid\": 21, \"ali\": 17 } # Avvalo foydalanuvchi ro'yxatda bormi \u2013 tekshiramiz if username in users: age = users[username] # Username bo\u2018yicha yoshni olamiz # Agar foydalanuvchi 18 yoki undan katta bo\u2018lsa \u2013 ruxsat beriladi if age >= 18: print(f\"{username.title()} is allowed to access the system.\") # Ruxsat berildi # Agar foydalanuvchi voyaga yetmagan bo\u2018lsa \u2013 ruxsat berilmaydi else: print(f\"{username.title()} is underage. Access denied.\") # Ruxsat yo\u2018q else: print(\"User not found in the system.\") # Bunday foydalanuvchi yo\u2018q \ud83c\udfaf Foydalanuvchi balansiga qarab faqat ruxsat etilgan tranzaksiyani bajarish mumkin. # User's current balance balance = 500_000 # 500 ming so\u2018m # Transaction type: \"withdraw\" (yechish) yoki \"deposit\" (kiritish) transaction_type = \"withdraw\" # Transaction amount (so\u2018mda) amount = 300_000 # Agar foydalanuvchi pul yechmoqchi bo\u2018lsa if transaction_type == \"withdraw\": # Mablag' yetarlimi? Yechishga ruxsat beriladi if balance >= amount: print(f\"{amount} so'm has been successfully withdrawn.\") # Pul yechildi else: print(\"Insufficient balance.\") # Pul yetarli emas # Agar foydalanuvchi balansga pul kiritmoqchi bo\u2018lsa elif transaction_type == \"deposit\": print(f\"{amount} so'm has been added to your balance.\") # Pul kiritildi # Aks holda, tranzaksiya turi noto\u2018g\u2018ri else: print(\"Invalid transaction type.\") # Noma'lum amal \ud83c\udfaf Agar foydalanuvchi o\u2018qituvchi bo\u2018lsa, yangi kurs yarata oladi. Talaba bo\u2018lsa, faqat yozilishi mumkin. # Foydalanuvchining ma'lumotlari (ismi, roli, holati) user = { \"name\": \"Umid\", \"role\": \"student\", # \"student\" yoki \"teacher\" \"active\": True # Foydalanuvchi faolligi } # Agar foydalanuvchi faollashtirilgan bo\u2018lsa if user[\"active\"]: # Agar foydalanuvchi o\u2018qituvchi bo\u2018lsa if user[\"role\"] == \"teacher\": print(\"You can create a new course.\") # Yangi kurs yaratish huquqi bor # Agar foydalanuvchi talaba bo\u2018lsa elif user[\"role\"] == \"student\": print(\"You can enroll in a course.\") # Kursga yozilish huquqi bor # Boshqa noma'lum rollar uchun else: print(\"Your role is not recognized.\") # Rol noto\u2018g\u2018ri yoki mavjud emas # Agar foydalanuvchi faollashtirilmagan bo\u2018lsa else: print(\"User is not active.\") # Foydalanuvchi faol emas","title":"\u2705 NESTED CONDITIONS"},{"location":"python/conditional-statements/#multiple-levels-of-nested-conditional-statements","text":"\ud83c\udfaf Ma'lumotlar bazasida foydalanuvchi ro\u2018yxatdan o\u2018tganmi, email tasdiqlanganmi va yoshi to\u2018liqmi \u2014 shu tartibda tekshiriladi: # Foydalanuvchining ro\u2018yxatdan o\u2018tganligi, email holati va yoshi user = { \"username\": \"umid\", \"registered\": True, # Foydalanuvchi ro'yxatdan o'tganmi? \"email_verified\": True, # Email tasdiqlanganmi? \"age\": 19 # Foydalanuvchi yoshi } # 1. Avval foydalanuvchi ro\u2018yxatdan o\u2018tganligini tekshiramiz if user[\"registered\"]: # 2. Email tasdiqlanganligini tekshiramiz if user[\"email_verified\"]: # 3. Yoshi 18 yoki undan katta bo\u2018lsa \u2013 to\u2018liq ruxsat beriladi if user[\"age\"] >= 18: print(\"Full access granted to the system.\") # To\u2018liq ruxsat else: print(\"Access denied. You must be at least 18 years old.\") # Yoshi yetmaydi else: print(\"Email not verified. Please verify your email first.\") # Email tasdiqlanmagan else: print(\"You are not registered. Please sign up first.\") # Ro\u2018yxatdan o\u2018tmagan \ud83c\udfaf Avtomobil ijarasi faqat quyidagi shartlar bajarilganda mumkin: Foydalanuvchi ro\u2018yxatdan o\u2018tgan Haydovchilik guvohnomasi mavjud Yoshi 21 dan katta # User data: registration, license availability, and age user = { \"registered\": True, # Foydalanuvchi ro\u2018yxatdan o\u2018tganmi? \"has_license\": True, # Haydovchilik guvohnomasi bormi? \"age\": 25 # Foydalanuvchining yoshi } # 1. Foydalanuvchi ro\u2018yxatdan o\u2018tgan bo\u2018lishi kerak if user[\"registered\"]: # 2. Haydovchilik guvohnomasi mavjud bo\u2018lishi kerak if user[\"has_license\"]: # 3. Yoshi 21 dan katta yoki teng bo\u2018lishi kerak if user[\"age\"] >= 21: print(\"Car rental approved.\") # Ijaraga ruxsat berildi else: print(\"You must be at least 21 years old to rent a car.\") # Yoshi yetmaydi else: print(\"You must have a valid driver\u2019s license.\") # Guvohnoma yo\u2018q else: print(\"Please register before renting a car.\") # Ro\u2018yxatdan o\u2018tmagan","title":"\u2705 MULTIPLE LEVELS OF NESTED CONDITIONAL STATEMENTS"},{"location":"python/conditional-statements/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/conditional-statements/#1-topshiriq","text":"Foydalanuvchidan yoshini so\u2018rang. Agar 18 dan kichik bo\u2018lsa \"Voyaga yetmagan\" , 18 yoki undan katta bo\u2018lsa \"Voyaga yetgan\" deb chiqaring.","title":"\u2705 1-topshiriq:"},{"location":"python/conditional-statements/#2-topshiriq","text":"Quyidagi o\u2018zgaruvchi berilgan: score = 87 Agar score 90 va undan yuqori bo\u2018lsa \"A\" , 80-89 oralig\u2018ida bo\u2018lsa \"B\" , 70-79 oralig\u2018ida bo\u2018lsa \"C\" , boshqacha bo\u2018lsa \"D\" baho chiqaring.","title":"\u2705 2-topshiriq:"},{"location":"python/conditional-statements/#3-topshiriq","text":"Quyidagi o\u2018zgaruvchi berilgan: is_raining = True Agar is_raining True bo\u2018lsa \"Soyabon oling\" , aks holda \"Yomg\u2018ir yo\u2018q\" deb chiqaring.","title":"\u2705 3-topshiriq:"},{"location":"python/conditional-statements/#4-topshiriq","text":"Quyidagi ro\u2018yxat berilgan: fruits = [\"olma\", \"banan\", \"gilos\"] Agar ro\u2018yxatda \"banan\" bo\u2018lsa \"Banan bor\" , bo\u2018lmasa \"Banan yo\u2018q\" deb chiqaring.","title":"\u2705 4-topshiriq:"},{"location":"python/conditional-statements/#5-topshiriq","text":"Ro\u2018yxatda kamida 5 ta element bo\u2018lsa \"Ro\u2018yxat to\u2018la\" , aks holda \"Ro\u2018yxat qisqa\" deb chiqaring: nums = [1, 4, 7, 10]","title":"\u2705 5-topshiriq:"},{"location":"python/conditional-statements/#6-topshiriq","text":"Tuple berilgan: location = (41.2, 69.1) Agar location bo\u2018sh bo\u2018lmasa \"Joylashuv aniqlangan\" , bo\u2018sh bo\u2018lsa \"Joylashuv yo\u2018q\" deb chiqaring.","title":"\u2705 6-topshiriq:"},{"location":"python/conditional-statements/#7-topshiriq","text":"Set berilgan: active_ids = {1, 2, 3} Agar 2-ID setda mavjud bo\u2018lsa \"2-ID mavjud\" , bo\u2018lmasa \"2-ID yo\u2018q\" deb chiqaring.","title":"\u2705 7-topshiriq:"},{"location":"python/conditional-statements/#8-topshiriq","text":"Quyidagi dictionary berilgan: profile = {\"name\": \"Alim\", \"age\": 15} Agar age 18 yoki undan katta bo\u2018lsa \"Voyaga yetgan\" , aks holda \"Voyaga yetmagan\" deb chiqaring.","title":"\u2705 8-topshiriq:"},{"location":"python/conditional-statements/#9-topshiriq","text":"Quyidagi o\u2018zgaruvchilar berilgan: is_logged_in = True is_admin = False Agar foydalanuvchi tizimga kirgan va admin bo\u2018lsa \"Admin panelga xush kelibsiz\" , faqat tizimga kirgan bo\u2018lsa \"Foydalanuvchi paneli\" , har ikkisi ham False bo\u2018lsa \"Kirish talab qilinadi\" .","title":"\u2705 9-topshiriq:"},{"location":"python/conditional-statements/#10-topshiriq","text":"Quyidagi kodni if...elif...else bilan yozing: temp o\u2018zgaruvchisi bo\u2018yicha: - 0 dan past \"Muzlab qolgan\" - 0-15 oralig\u2018ida \"Salqin\" - 16-30 oralig\u2018ida \"Me'yoriy\" - 30 dan yuqori \"Issiq\" temp = 23","title":"\u2705 10-topshiriq:"},{"location":"python/conditional-statements/#11-topshiriq","text":"Ro\u2018yxatda \"python\" va \"sql\" bo\u2018lsa \"Ikkalasi ham bor\" , faqat bittasi bo\u2018lsa \"Bittasi bor\" , ikkalasi ham bo\u2018lmasa \"Ikkalasi ham yo\u2018q\" deb chiqaring: skills = [\"html\", \"python\", \"css\"]","title":"\u2705 11-topshiriq:"},{"location":"python/conditional-statements/#12-topshiriq","text":"Foydalanuvchi parol kiritadi. Agar parol uzunligi 10 dan katta bo\u2018lsa \"Kuchli parol\" , 6-10 oralig\u2018ida bo\u2018lsa \"O\u2018rtacha parol\" , 6 dan kam bo\u2018lsa \"Juda qisqa\" .","title":"\u2705 12-topshiriq:"},{"location":"python/conditional-statements/#13-topshiriq","text":"Quyidagi dictionary berilgan: user = {\"username\": \"nargiza\", \"active\": True, \"role\": \"student\"} Agar user active va roli \"teacher\" bo\u2018lsa \"Yangi kurs yarata oladi\" , active va roli \"student\" bo\u2018lsa \"Faqat kursga yozila oladi\" , aks holda \"Ruxsat yo\u2018q\" .","title":"\u2705 13-topshiriq:"},{"location":"python/conditional-statements/#14-topshiriq","text":"Quyidagi o\u2018zgaruvchilar berilgan: speed = 7.2 is_connected = True Agar is_connected False bo\u2018lsa \"Internet yo\u2018q\" , else if speed < 1 bo\u2018lsa \"Eng past sifat\" , speed < 5 bo\u2018lsa \"O\u2018rtacha sifat\" , else \"Yuqori sifat\" .","title":"\u2705 14-topshiriq:"},{"location":"python/conditional-statements/#15-topshiriq","text":"Quyidagi dictionarylar orqali avtomobil ijarasi uchun quyidagilarni tekshiring: - \"registered\": True - \"has_license\": True - \"age\": 19 Agar hammasi to\u2018g\u2018ri bo\u2018lsa \"Ijaraga ruxsat\" , aks holda qaysi shart bajarilmaganini chiqaring.","title":"\u2705 15-topshiriq:"},{"location":"python/data-types/","text":"\ud83e\udde9 2-DARS DATA TYPES \u2705 MA'LUMOT TURLARI \ud83d\udccc Python dasturlash tilida har bir qiymat (value) \u2014 o\u2018zining ma'lumot turiga (data type) ega. Bu tur qiymatga qanday ishlov berishni aniqlaydi. \ud83d\udccc Python dasturlash tilida 8 ta ma'lumot turi bor, ular quyidagilar: Definition Type Text Type str Numeric Types int , float , complex Sequence Types list , tuple , range Mapping Type dict Set Types set , frozenset Boolean Type bool Binary Types bytes , bytearray , memoryview None Type NoneType \u2705 STRING \ud83d\udccc String \u2014 bu matnli ma\u2019lumotlarni ifodalovchi ma\u2019lumot turi. Ya\u2019ni, harflar, raqamlar, bo\u2018sh joy, belgilardan tashkil topgan qator (yoki matn). \ud83d\udccc Pythonda stringlar ikki yoki uchta qo\u2018shtirnoq (\" \") yoki tirtirnoq (' ') bilan yoziladi. # Double quotes \u2014 ikki tirnoq (\" \") bilan yozilgan oddiy string text = \"Hello world\" print(text) # Single quotes \u2014 bitta tirnoq (' ') bilan yozilgan oddiy string text = 'Hello world' print(text) # Triple double quotes \u2014 uchta ikki tirnoq (\"\"\" \"\"\") bilan yozilgan ko\u2018p qatorli matn (multiline string) text = \"\"\"This is a multiline string.\"\"\" print(text) # Triple single quotes \u2014 uchta bitta tirnoq (''' ''') bilan yozilgan ko\u2018p qatorli matn (multiline string) text = '''This is also a multiline string.''' print(text) \u2747\ufe0f STRING USTIDA AMALLAR \ud83d\udccc Matnlarni qo'shish uchun + operatoridan foydalanamiz. # '+' operatori yordamida ikki yoki undan ortiq stringlarni birlashtirish mumkin name = \"Umid\" print(\"Mening ismim \" + name) # Natija: Mening ismim Umid # Qo\u2018shishda so\u2018zlar orasiga bo\u2018sh joy (space) qo\u2018yish kerak, aks holda ular bir-biriga yopishib qoladi first_name = \"Umid\" last_name = \"G'aybullayev\" print(first_name + last_name) # Natija: UmidG'aybullayev (bo\u2018shliq yo\u2018q) # To\u2018g\u2018ri natija uchun so\u2018zlar orasiga bo\u2018sh joy qo\u2018shamiz print(first_name + \" \" + last_name) # Natija: Umid G'aybullayev \u2747\ufe0f STRING UZUNLIGINI ANIQLASH \ud83d\udccc String uzunligi \u2014 bu stringdagi belgilar (characters) soni. Belgilarga harflar, raqamlar, bo\u2018sh joylar (spaces) va maxsus belgilar kiradi. \ud83d\udccc String uzunligini topish uchun len() funksiyasidan foydalanamiz. # len() funksiyasi yordamida string uzunligini aniqlaymiz text = \"Hello, World!\" # text o'zgaruvchisidagi string uzunligini len() yordamida o'lchaymiz length = len(text) # Natija: 13 # Natijani ekranga chiqaramiz print(length) \u2747\ufe0f STRING E'LEMENTLARIGA MUROJAT QILISH \ud83d\udccc String ichidan o'zimizga kerak bo'lgan e'lementlarni ajratib olish uchun quyidagi usuldan foydalanamiz: # String ichidan kerakli elementlarni olish uchun indekslash (indexing) va kesish (slicing) usullaridan foydalanamiz text = \"Hello world!\" # Birinchi e'lementni olish uchun indeks 0 dan boshlanadi first_char = text[0] # Natija: 'H' # Oxirgi e'lementni olish uchun indeks sifatida -1 ishlatiladi last_char = text[-1] # Natija: '!' # e'lementlarni kesib olish (substring) uchun start va stop indekslar beriladi (stop indeksi kiritilgan indeksdan oldingi belgigacha) substring = text[0:5] # Natija: 'Hello' (0-indeksdan 4-indeksgacha) # Natijalarni ekranga chiqaramiz print(first_char) print(last_char) print(substring) \u2747\ufe0f STRINGLARNI KO'PAYTIRISH \ud83d\udccc Python dasturida string ni ko\u2018paytirish orqali bir xil matnni takrorlash mumkin. Buning uchun * operatoridan foydalanamiz. # Stringni ko\u2018paytirish orqali bir xil e'lementni takrorlash mumkin # Buning uchun '*' operatoridan foydalanamiz text = \"Hello\" # hello so'zini 3 marta takrorlaymiz text_repeated = text * 3 # Natija: 'HelloHelloHello' # Natijani ekranga chiqaramiz print(text_repeated) \u2747\ufe0f F-STRING(Python 3.6+) \ud83d\udccc Python 3.6 versiyasidan boshlab, string ichida o\u2018zgaruvchilarni (variables) va ifodalarni (expressions) to\u2018g\u2018ridan-to\u2018g\u2018ri joylashtirish uchun f-string (formatted string literal) usuli joriy etildi. Bu usul string formattingning eng qulay va tezkor usullaridan biri hisoblanadi. # O'zgaruvchilarni string ichida qulay tarzda qo'shish uchun f-string usulidan foydalanamiz ism = \"Umid\" yosh = 20 # f-string yordamida string ichiga o'zgaruvchilarni joylashtirish text = f\"Mening ismim {ism}, yoshim {yosh}da\" # Natija: Mening ismim Umid, yoshim 20da # Natijani ekranga chiqaramiz print(text) \u2747\ufe0f STRING METODLARI \ud83d\udccc Python dasturlash tilida, stringlar ustida turli xil operatsiyalarni bajarish uchun bir qancha o'rnatilgan metodlar mavjud. Quyida eng ko'p qo'llaniladigan string metodlari va ularning misollari keltirilgan: .upper() # .upper() - Matndagi barcha harflarni katta harfga aylantiradi text = \"hello\" print(text.upper()) # Natija: HELLO # Foydalanuvchi ismini doim katta harflarda saqlash uchun, # bazada bir xil ism turli holatda yozilgan bo\u2018lsa ham xatolik bo\u2018lmasin user_input = \"umid\" username = user_input.upper() print(username) # UMID .lower() # .lower() - Matndagi barcha harflarni kichik harfga aylantiradi text = \"HELLO\" print(text.lower()) # Natija: hello # Email yoki username tekshiruvda har doim kichik harflarga o\u2018zgartirish kerak, # chunki email kichik harflarda yoziladi email = \"User@Example.COM\" email_normalized = email.lower() print(email_normalized) # user@example.com .capitalize() # .capitalize() - Matnning birinchi harfini katta harfga, qolganlarini kichik harfga aylantiradi text = \"hello world\" print(text.capitalize()) # Natija: Hello world # Foydalanuvchi ismini chiroyli ko\u2018rsatish uchun, # faqat birinchi harf katta bo\u2018lsin name = \"umid\" print(name.capitalize()) # Umid .title() # .title() - Matndagi har bir so'zning birinchi harfini katta harfga aylantiradi text = \"hello world\" print(text.title()) # Natija: Hello World # Blog post yoki maqola sarlavhasini # har bir so\u2018zni bosh harfi katta bo\u2018lsin uchun formatlash title = \"python dasturlash asoslari\" print(title.title()) # Python Dasturlash Asoslari .lstrip() # .lstrip() - Matnning boshidagi bo'sh joylarni olib tashlaydi text = \" hello world \" print(text.lstrip()) # Natija: \"hello world \" .rstrip() # .rstrip() - Matnning oxiridagi bo'sh joylarni olib tashlaydi text = \" hello world \" print(text.rstrip()) # Natija: \" hello world\" .strip() # .strip() - Matnning boshidagi va oxiridagi bo'sh joylarni olib tashlaydi text = \" hello world \" print(text.strip()) # Natija: \"hello world\" # toza ma\u2019lumot olish maqsadida user_input = \" umid \" clean_input = user_input.strip() print(clean_input) # \"umid\" .replace(old, new) # 1-qator: \"matn\" nomli o'zgaruvchiga biror matn qiymatini beramiz matn = \"Salom dunyo\" # 2-qator: \"matn\"dagi \"dunyo\" so'zini \"Umid\" so'ziga almashtiramiz. # replace() metodi eski so'zni yangi so'z bilan almashtirib, natijani \"yangi_matn\" ga saqlaydi yangi_matn = matn.replace(\"dunyo\", \"Umid\") # 3-qator: Yangi hosil bo'lgan matnni ekranga chiqaramiz print(yangi_matn) # 1-qator: \"raqam\" o'zgaruvchisiga telefon raqamini matn ko'rinishida beramiz raqam = \"+998 90 123 45 67\" # 2-qator: # .replace(\" \", \"\") - bu yerda barcha bo'sh joylar (\" \") olib tashlanadi # .replace(\"+\", \"\") - bu yerda \"+\" belgisi olib tashlanadi raqam = raqam.replace(\" \", \"\").replace(\"+\", \"\") # 3-qator: Tozalangan raqamni ekranga chiqaramiz print(raqam) .split(separator) # 1-qator: \"text\" o'zgaruvchisiga matn berilgan text = \"Hello world Python\" # 2-qator: .split() metodi bo'sh joy (\" \") bo'yicha matnni bo'lib, ro'yxatga aylantiradi print(text.split()) # Natija: ['Hello', 'world', 'Python'] # 3-qator: .split('o') metodi \"o\" harfi bo'yicha bo'lib ro'yxatga aylantiradi print(text.split('o')) # Natija: ['Hell', ' w', 'rld Pyth', 'n'] # 1-qator: \"qidiruv\" nomli o'zgaruvchiga foydalanuvchi yozgan matn saqlanadi qidiruv = \"telefon kompyuter printer\" # 2-qator: .split() metodi yordamida matn bo'sh joy bo'yicha bo'linadi # Natijada ['telefon', 'kompyuter', 'printer'] degan ro'yxat (list) hosil bo'ladi sozlar = qidiruv.split() # 3-qator: ro'yxatdagi har bir so'z ustida aylanish (for loop) boshlanadi for text in sozlar: # 4-qator: har bir so'z ekranga chiqariladi print(\"Qidirilmoqda:\", text) .join(iterable) # 1-qator: 3 ta so'zdan iborat ro'yxat yaratiladi words = ['Hello', 'world', 'Python'] # 2-qator: ' '.join(words) ro'yxatdagi so'zlarni bo'sh joy bilan birlashtiradi print(' '.join(words)) # Natija: Hello world Python # 3-qator: '-'.join(words) so'zlarni \"-\" bilan birlashtiradi print('-'.join(words)) # Natija: Hello-world-Python # 1-qator: 'kodlar' nomli ro'yxat yaratilmoqda, # ichida 3 ta element - matn ko'rinishidagi kodlar bor kodlar = ['AB12', 'CD34', 'EF56'] # 2-qator: '-'.join(kodlar) yordamida ro'yxat elementlari orasiga # chiziqcha (\"-\") qo'yib, ularni bitta matnga birlashtiramiz parol = '-'.join(kodlar) # 3-qator: natijani ekranga chiqaramiz print(\"Yangi parol:\", parol) .find(substring) # 1-qator: text o'zgaruvchisiga \"Hello world\" matni saqlanmoqda text = \"Hello world\" # 2-qator: .find() metodi yordamida \"world\" so'zining text ichidagi # boshlanish indeksini topamiz. Agar topilsa, indeks qaytariladi print(text.find(\"world\")) # Natija: 6 # 3-qator: .find() metodi yordamida \"Python\" so'zining indeksini izlaymiz, # lekin matnda yo'q, shuning uchun -1 qaytariladi print(text.find(\"Python\")) # Natija: -1 # 1-qator: url o'zgaruvchisiga URL matni saqlanmoqda url = \"https://example.com/page?id=123\" # 2-qator: url ichidan \"id=\" matnining indeksini topamiz pos = url.find(\"id=\") # 3-qator: agar \"id=\" topilgan bo'lsa (indeks -1 emas) if pos != -1: # 4-qator: identifikatorni \"id=\" dan keyingi qismdan ajratib olamiz # pos+3 degani \"id=\" so'zidan keyingi belgidan boshlab olish identifikator = url[pos+3:] # 5-qator: ekranga chiqaramiz print(\"ID:\", identifikator) .startswith(prefix) # 1-qator: text o'zgaruvchisiga \"Hello world\" matni saqlanmoqda text = \"Hello world\" # 2-qator: .startswith() metodi yordamida matn \"Hello\" bilan boshlanishini tekshiramiz print(text.startswith(\"Hello\")) # Natija: True # 3-qator: .startswith() metodi yordamida matn \"world\" bilan boshlanishini tekshiramiz print(text.startswith(\"world\")) # Natija: False # 1-qator: url o'zgaruvchisiga URL manzili saqlanmoqda url = \"https://example.com/api/user\" # 2-qator: url matni \"https://example.com/api/\" bilan boshlanishini tekshiramiz if url.startswith(\"https://example.com/api/\"): # 3-qator: agar to'g'ri bo'lsa, \"API so'rovi\" deb chiqaramiz print(\"API so'rovi\") .endswith(suffix) # 1-qator: text o'zgaruvchisiga \"Hello world\" matni saqlanmoqda text = \"Hello world\" # 2-qator: .endswith() metodi yordamida matn \"world\" bilan tugashini tekshiramiz print(text.endswith(\"world\")) # Natija: True # 3-qator: .endswith() metodi yordamida matn \"Hello\" bilan tugashini tekshiramiz print(text.endswith(\"Hello\")) # Natija: False # 1-qator: filename o'zgaruvchisiga fayl nomi saqlanmoqda filename = \"photo.jpg\" # 2-qator: agar filename \".jpg\" bilan tugasa, shart bajariladi if filename.endswith(\".jpg\"): # 3-qator: ekranga \"Rasm fayli\" deb chiqaramiz print(\"Rasm fayli\") .count(substring) # 1-qator: text o'zgaruvchisiga \"hello hello world\" matni saqlanmoqda text = \"hello hello world\" # 2-qator: .count() metodi yordamida matnda \"hello\" so'zi necha marta takrorlanganini hisoblaymiz print(text.count(\"hello\")) # Natija: 2 \u2705 NUMBERS \ud83d\udccc Numbers \u2014 bu sonlarni ifodalash uchun ishlatiladigan ma'lumot turi. \ud83d\udccc Pythonda asosiy 3ta number type mavjud: int \u2014 butun sonlar (masalan, 5, -10, 100) float \u2014 o'nlik sonlar (masalan, 3.14, -0.001, 2.0) complex \u2014 kompleks sonlar (masalan, 2 + 3j, -1j) \u2747\ufe0f INTEGER \ud83d\udccc Integer ma'lumot turi butun sonlarni ifodalaydi. Bu sonlar manfiy , musbat yoki 0 bo'lishi mumkin. Integerlar cheklanmagan uzunlikka ega, ya'ni Python juda katta sonlarni ham integer sifatida saqlay oladi. x = 10 # musbat butun son y = -5 # manfiy butun son z = 0 # nol a = 12345678901234567890 # juda katta butun son # Quyidagi print() funksiyalari har bir o'zgaruvchining turini ko'rsatadi print(type(x)) # <class 'int'> print(type(y)) # <class 'int'> print(type(z)) # <class 'int'> print(type(a)) # <class 'int'> \u2705 INTEGER USTIDA AMALLAR \ud83d\udccc Integerlar ustida asosiy matematik amallarni bajarish mumkin: # Integerlar (butun sonlar) ustida bajariladigan asosiy matematik amallar a = 10 # Birinchi butun son b = 3 # Ikkinchi butun son # Qo'shish: ikkita sonni qo'shadi, natija 13 bo'ladi print(a + b) # 10 + 3 = 13 # Ayirish: birinchi sondan ikkinchi sonni ayiradi, natija 7 bo'ladi print(a - b) # 10 - 3 = 7 # Ko'paytirish: ikkita sonni ko'paytiradi, natija 30 bo'ladi print(a * b) # 10 * 3 = 30 # Bo'lish: birinchi sonni ikkinchi songa bo'ladi, natija float (kasr) turida chiqadi print(a / b) # 10 / 3 \u2248 3.3333333333333335 # Butun qismini olish: bo'linmaning faqat butun qismini oladi, o'nlik qismi tashlanadi print(a // b) # 10 // 3 = 3 # Qoldiqni olish: bo'linmaning qoldig'ini hisoblaydi (modulus) print(a % b) # 10 % 3 = 1 # Darajaga ko'tarish: birinchi sonni ikkinchi son darajasiga ko'taradi print(a ** b) # 10 ** 3 = 1000 \u2705 UZUN SONLARNI KIRITISH \ud83d\udccc Uzun sonlarni kiritishda, qulaylik uchun, raqamlarni pastki chiziq ( _ ) yordamida guruhlash mumkin. Python - son tarkibidagi pastki chiziqlarni ( _ ) inobatga olmasdan, uzun sonligicha qabul qiladi. # Bank hisobidagi pul miqdori (katta son) bank_hisobi = 1_250_000_000 # 1 milliard 250 million so'm print(\"Sizning hisobingizdagi mablag'\", bank_hisobi, \"so'm\") # Chiqarish: Sizning hisobingizdagi mablag' 1250000000 so'm \u2705 BIR NECHTA O'ZGARUVCHIGA QIYMAT BERISH \ud83d\udccc Birdaniga bir nechta o'zgaruvchiga qiymat berish uchun o'zgaruvchilar va ularga mos qiymatlar vergul ( , ) bilan ajratiladi: # Bir nechta o'zgaruvchilarga bir qatorda qiymat berish mumkin # x ga 10 (integer), y ga -7.25 (float), z ga -30 (integer) qiymatlari bir vaqtning o'zida berildi x, y, z = 10, -7.25, -30 # Natijalarni chiqaramiz print(\"x ning qiymati:\", x) # 10 print(\"y ning qiymati:\", y) # -7.25 print(\"z ning qiymati:\", z) # -30 \u2705 O'ZGARUVCHI TURINI ALMASHTIRISH \ud83d\udccc Python dasturlash tilida o'zgaruvchilar turini bir ma'lumot turidan boshqa ma'lumot turiga o'zgartirish jarayoni type casting deb ataladi. # Type casting misollari \u2014 qiymatlarni o'zgaruvchilarga saqlash va ularni turini tekshirish # 1. int() \u2014 float va stringdan int ga o'tish float_son = 3.7 int_from_float = int(float_son) # 3.7 dan 3 ga (kasr qismi tashlanadi) string_son = \"25\" int_from_string = int(string_son) # \"25\" matnidan 25 (int) hosil bo'ladi # 2. float() \u2014 int va stringdan float ga o'tish int_son = 10 float_from_int = float(int_son) # 10 dan 10.0 ga string_float = \"3.14\" float_from_string = float(string_float) # \"3.14\" matnidan 3.14 hosil bo'ladi # 3. str() \u2014 har qanday qiymatni stringga aylantirish int_num = 123 str_from_int = str(int_num) # int 123 -> string \"123\" float_num = 3.14 str_from_float = str(float_num) # float 3.14 -> string \"3.14\" bool_val = True str_from_bool = str(bool_val) # True -> \"True\" # 4. bool() \u2014 qiymatni True yoki False ga aylantirish bool_from_one = bool(1) # 1 -> True bool_from_zero = bool(0) # 0 -> False bool_from_empty_str = bool(\"\") # bo'sh string -> False bool_from_nonempty_str = bool(\"Hello\") # bo'sh bo'lmagan string -> True bool_from_empty_list = bool([]) # bo'sh ro'yxat -> False bool_from_list = bool([1, 2, 3]) # bo'sh bo'lmagan ro'yxat -> True # Natijalarni chiqaramiz print(int_from_float, type(int_from_float)) # 3 <class 'int'> print(int_from_string, type(int_from_string)) # 25 <class 'int'> print(float_from_int, type(float_from_int)) # 10.0 <class 'float'> print(float_from_string, type(float_from_string)) # 3.14 <class 'float'> print(str_from_int, type(str_from_int)) # '123' <class 'str'> print(str_from_float, type(str_from_float)) # '3.14' <class 'str'> print(str_from_bool, type(str_from_bool)) # 'True' <class 'str'> print(bool_from_one, type(bool_from_one)) # True <class 'bool'> print(bool_from_zero, type(bool_from_zero)) # False <class 'bool'> print(bool_from_empty_str, type(bool_from_empty_str)) # False <class 'bool'> print(bool_from_nonempty_str, type(bool_from_nonempty_str)) # True <class 'bool'> print(bool_from_empty_list, type(bool_from_empty_list)) # False <class 'bool'> print(bool_from_list, type(bool_from_list)) # True <class 'bool'> \u2705 INPUT \ud83d\udccc input() \u2014 bu Python dasturlash tilidagi maxsus funksiya bo\u2018lib, u foydalanuvchidan klaviatura orqali ma'lumot olish uchun ishlatiladi. # input() funksiyasi foydalanuvchidan ma'lumot olish uchun ishlatiladi. # Funksiya ichidagi matn \u2014 bu foydalanuvchiga ko'rsatiladigan savol yoki so'rov. ism = input(\"Ismingizni kiriting: \") # Foydalanuvchidan ismni so'raymiz print(\"Salom,\", ism) # Kiritilgan ismni ekranga chiqaramiz \ud83d\udccc input() har doim matn (string) ko\u2018rinishida qiymat oladi. Agar son kiritilishini istasak, stringni son turiga o\u2018zgartirish kerak. # foydalanuvchi kiritgan matnni butun songa aylantiramiz yosh = int(input(\"Yoshingizni kiriting: \")) print(\"Sizning yoshingiz:\", yosh) # 1. Foydalanuvchidan tug'ilgan yilini so'raymiz t_yil = input(\"Tug'ilgan yilingizni kiriting: \") # 2. input() funksiyasi har doim matn (string) ko'rinishida ma'lumot beradi, # shuning uchun uni butun son (integer) ga o'tkazamiz t_yil = int(t_yil) # 3. Yilni hozirgi yil bilan solishtirib, yoshni hisoblaymiz hozirgi_yil = 2025 yosh = hozirgi_yil - t_yil # 4. Natijani ekranga chiqaramiz print(\"Siz \" + str(yosh) + \" yoshda ekansiz.\") \u2747\ufe0f FLOAT \ud83d\udccc Pythonda o'nlik sonlar floating point numbers yoki qisqa qilib floats deyiladi. Ingliz tilida o'nlik sonlarni yozishda vergul ( , ) emas nuqta ( . ) belgisi ishlatiladi, va bu nuqta sonning katta kichikligiga qarab joyi o'zgargani uchun \"floating\" deyiladi. pi = 3.14159 # o'nlik son, ya'ni float turidagi o'zgaruvchi radius = 10 # butun son, ya'ni int turidagi o'zgaruvchi diametr = 2 * radius # diametrni hisoblaymiz (radiusning 2 barobariga teng) # aylana uzunligini hisoblab, natijani chiqaramiz print(\"Aylana uzunligi \", pi * diametr, \" ga teng.\") \u2747\ufe0f FLOAT USTIDA AMALLAR a = 5.5 # a o'zgaruvchisiga 5.5 (float) qiymat berildi b = 2.0 # b o'zgaruvchisiga 2.0 (float) qiymat berildi print(\"Qo\u2018shish:\", a + b) # a va b ni qo\u2018shish => 7.5 print(\"Ayirish:\", a - b) # a dan b ni ayirish => 3.5 print(\"Ko\u2018paytirish:\", a * b) # a va b ni ko\u2018paytirish => 11.0 print(\"Bo\u2018lish:\", a / b) # a ni b ga bo\u2018lish (haqiqiy bo\u2018lish) => 2.75 print(\"Butun qismga bo\u2018lish:\", a // b) # a ni b ga bo\u2018lish va butun qismni olish => 2.0 print(\"Qoldiq:\", a % b) # a ni b ga bo\u2018lishda qolgan qoldiq => 1.5 print(\"Daraja:\", a ** b) # a ni b-darajaga ko\u2018tarish => 30.25 \u2705 COMPLEX \ud83d\udccc Complex sonlar \u2014 bu ikkita qismdan iborat sonlar: haqiqiy qism (real part) va mavhum qism (imaginary part). \ud83d\udccc Pythonda murakkab sonlar complex tipida saqlanadi. Pythonda imaginary part j yoki J harfi bilan ifodalanadi (elektronika va fizikada j ishlatiladi, matematikada esa i ). \u2747\ufe0f COMPLEX SON YARATISH # Kompleks son yaratamiz: real part 3, imaginary part 4j z1 = 3 + 4j # Kompleks sonni konsolga chiqaramiz print(z1) # Natija: (3+4j) \u2705 KONSTANTA \ud83d\udccc Python dasturlash tilida \"constant\" deb ataladigan o'zgaruvchilar mavjud emas, lekin dasturchilar odatda o'zgaruvchilarni konstantalar sifatida ishlatishadi. Bu odatda o'zgaruvchining qiymati dastur davomida o'zgarmasligini anglatadi. Konstantalarni nomlash: Konstantalarni nomlashda katta harflar ishlatiladi. Bu, dasturchiga o'zgaruvchining qiymati o'zgarmasligini anglatadi. # Bu yerda PI nomli konstanta e'lon qilinmoqda # Odatda konstanta nomlari katta harflarda yoziladi # PI ning qiymati o\u2018zgarmaydi va doim 3.14159 bo\u2018lib qoladi PI = 3.14159 # Bu yerda MAX_USERS nomli konstanta e'lon qilinmoqda # Bu maksimum foydalanuvchilar sonini bildiradi MAX_USERS = 100 Konstantalarni modullarda saqlash: Konstantalarni alohida Python faylida (modulda) saqlash tavsiya etiladi. Bu, konstantalarni boshqa fayllarda ishlatishni osonlashtiradi. Misol uchun, constants.py nomli fayl yaratib, unda konstantalarni saqlash mumkin: # constants.py # constants.py faylida o'zgarmas (konstanta) qiymatlar saqlanadi # Bu konstantalar boshqa fayllardan import qilib ishlatiladi # Aylana uchun PI qiymati PI = 3.14159 # Maksimal foydalanuvchilar soni MAX_USERS = 100 Keyin boshqa faylda bu konstantalarni ishlatish mumkin: # main.py # constants.py modulidagi konstantalarni import qilamiz import constants # PI konstantasini terminalga chiqaramiz print(constants.PI) # Natija: 3.14159 # MAX_USERS konstantasini terminalga chiqaramiz print(constants.MAX_USERS) # Natija: 100 Konstantalarni o'zgartirishga urinish: Python tilida konstantalarni o'zgartirish mumkin, lekin bu tavsiya etilmaydi. Agar siz konstantani o'zgartirmoqchi bo'lsangiz, bu dastur xatolarga olib kelishi mumkin. # PI konstanta deb qaralmoqda, ya'ni doimiy qiymat sifatida ishlatiladi PI = 3.14159 # Ammo bu yerda PI qiymatini o'zgartirib yubordik # Bu sintaktik jihatdan xato emas, lekin yomon amaliyot hisoblanadi # Chunki dasturchilar PI o'zgarmaydi deb o'ylaydi PI = 3.14 # \u274c Bu tavsiya etilmaydi # Dastur davomida bu o'zgarish kutilmagan xatolarga olib kelishi mumkin print(\"PI qiymati:\", PI) # Natija: 3.14 \u2705 AMALIYOT \u2705 1-topshiriq: String birlashtirish Foydalanuvchidan ism va familiya input() orqali oling. Ularni birlashtirib, \"F.I.O: \" tarzida ekranga chiqaring. \u2705 2-topshiriq: String uzunligini topish Foydalanuvchidan matn input() orqali oling va uning uzunligini len() yordamida aniqlang. \u2705 3-topshiriq: String indekslash va kesish \"Python dasturlash\" matnini o\u2018zgaruvchiga saqlang. Birinchi harfini, oxirgi harfini va \"dastur\" so\u2018zini alohida ekranga chiqaring. \u2705 4-topshiriq: String ko\u2018paytirish Foydalanuvchidan so\u2018z oling va uni 4 marta ketma-ket chiqaruvchi dastur yozing. \u2705 5-topshiriq: F-stringdan foydalanish Foydalanuvchidan ism va yosh input() orqali olib, quyidagicha f-string yordamida chiqaring. Misol: Ismingiz: Aziza, Yoshingiz: 19 \u2705 6-topshiriq: String metodlari bilan ishlash Foydalanuvchidan matn input() orqali oling. Uni: - katta harflarga, - kichik harflarga, - birinchi harfini katta qilishga o\u2018zgartirib, har birini alohida ekranga chiqaring. \u2705 7-topshiriq: .replace() va .split() metodi Foydalanuvchidan telefon raqami oling (masalan: \"+998 90 123 45 67\") va uni bo\u2018sh joylar va \"+\" belgisidan tozalang, so\u2018ng split() yordamida 2 xonali bloklarga ajrating. \u2705 8-topshiriq: .join() va .count() Foydalanuvchidan so\u2018zlar ro\u2018yxatini input() orqali so\u2018rab, ularni vergul bilan birlashtiring va \"a\" harfi necha marta qatnashganini hisoblang. \u2705 9-topshiriq: .find(), .startswith(), .endswith() Foydalanuvchidan matn va so\u2018z oling. Matnda so\u2018z qayerdan boshlanishini, matn aynan shu so\u2018z bilan boshlanish yoki tugashini aniqlang. \u2705 10-topshiriq: Integer va float ustida amallar Foydalanuvchidan ikkita butun son va bir float son oling. Ularning yig\u2018indisi, ko\u2018paytmasi va o\u2018zaro bo\u2018linmasini hisoblang. \u2705 11-topshiriq: Uzoq sonni guruhlash Bank hisobingizdagi pul miqdorini pastki chiziq yordamida o\u2018qish oson bo\u2018ladigan formatda yozing va ekranga chiqaring. \u2705 12-topshiriq: Type casting (turini o\u2018zgartirish) Foydalanuvchidan raqamli matn oling va uni int, float, str va bool turiga o\u2018tkazib, har birini va turini chiqaring. \u2705 13-topshiriq: Kompleks son Real va imag qismlarni input orqali olib, kompleks son yarating va uni ekranga chiqaring. \u2705 14-topshiriq: Konstantadan foydalanish PI va MAX_USERS konstantasini yarating (katta harflar bilan). Ularni ekranga chiqaruvchi dastur yozing. \u2705 15-topshiriq: Foydalanuvchi yoshi va input Foydalanuvchidan tug\u2018ilgan yilini input orqali olib, yoshini hisoblab chiqaring (hozirgi yilni o\u2018zingiz yozing). Misol: Siz 20 yoshdasiz.","title":"Data Types"},{"location":"python/data-types/#2-dars-data-types","text":"","title":"\ud83e\udde9 2-DARS DATA TYPES"},{"location":"python/data-types/#malumot-turlari","text":"\ud83d\udccc Python dasturlash tilida har bir qiymat (value) \u2014 o\u2018zining ma'lumot turiga (data type) ega. Bu tur qiymatga qanday ishlov berishni aniqlaydi. \ud83d\udccc Python dasturlash tilida 8 ta ma'lumot turi bor, ular quyidagilar: Definition Type Text Type str Numeric Types int , float , complex Sequence Types list , tuple , range Mapping Type dict Set Types set , frozenset Boolean Type bool Binary Types bytes , bytearray , memoryview None Type NoneType","title":"\u2705 MA'LUMOT TURLARI"},{"location":"python/data-types/#string","text":"\ud83d\udccc String \u2014 bu matnli ma\u2019lumotlarni ifodalovchi ma\u2019lumot turi. Ya\u2019ni, harflar, raqamlar, bo\u2018sh joy, belgilardan tashkil topgan qator (yoki matn). \ud83d\udccc Pythonda stringlar ikki yoki uchta qo\u2018shtirnoq (\" \") yoki tirtirnoq (' ') bilan yoziladi. # Double quotes \u2014 ikki tirnoq (\" \") bilan yozilgan oddiy string text = \"Hello world\" print(text) # Single quotes \u2014 bitta tirnoq (' ') bilan yozilgan oddiy string text = 'Hello world' print(text) # Triple double quotes \u2014 uchta ikki tirnoq (\"\"\" \"\"\") bilan yozilgan ko\u2018p qatorli matn (multiline string) text = \"\"\"This is a multiline string.\"\"\" print(text) # Triple single quotes \u2014 uchta bitta tirnoq (''' ''') bilan yozilgan ko\u2018p qatorli matn (multiline string) text = '''This is also a multiline string.''' print(text)","title":"\u2705 STRING"},{"location":"python/data-types/#string-ustida-amallar","text":"\ud83d\udccc Matnlarni qo'shish uchun + operatoridan foydalanamiz. # '+' operatori yordamida ikki yoki undan ortiq stringlarni birlashtirish mumkin name = \"Umid\" print(\"Mening ismim \" + name) # Natija: Mening ismim Umid # Qo\u2018shishda so\u2018zlar orasiga bo\u2018sh joy (space) qo\u2018yish kerak, aks holda ular bir-biriga yopishib qoladi first_name = \"Umid\" last_name = \"G'aybullayev\" print(first_name + last_name) # Natija: UmidG'aybullayev (bo\u2018shliq yo\u2018q) # To\u2018g\u2018ri natija uchun so\u2018zlar orasiga bo\u2018sh joy qo\u2018shamiz print(first_name + \" \" + last_name) # Natija: Umid G'aybullayev","title":"\u2747\ufe0f STRING USTIDA AMALLAR"},{"location":"python/data-types/#string-uzunligini-aniqlash","text":"\ud83d\udccc String uzunligi \u2014 bu stringdagi belgilar (characters) soni. Belgilarga harflar, raqamlar, bo\u2018sh joylar (spaces) va maxsus belgilar kiradi. \ud83d\udccc String uzunligini topish uchun len() funksiyasidan foydalanamiz. # len() funksiyasi yordamida string uzunligini aniqlaymiz text = \"Hello, World!\" # text o'zgaruvchisidagi string uzunligini len() yordamida o'lchaymiz length = len(text) # Natija: 13 # Natijani ekranga chiqaramiz print(length)","title":"\u2747\ufe0f STRING UZUNLIGINI ANIQLASH"},{"location":"python/data-types/#string-elementlariga-murojat-qilish","text":"\ud83d\udccc String ichidan o'zimizga kerak bo'lgan e'lementlarni ajratib olish uchun quyidagi usuldan foydalanamiz: # String ichidan kerakli elementlarni olish uchun indekslash (indexing) va kesish (slicing) usullaridan foydalanamiz text = \"Hello world!\" # Birinchi e'lementni olish uchun indeks 0 dan boshlanadi first_char = text[0] # Natija: 'H' # Oxirgi e'lementni olish uchun indeks sifatida -1 ishlatiladi last_char = text[-1] # Natija: '!' # e'lementlarni kesib olish (substring) uchun start va stop indekslar beriladi (stop indeksi kiritilgan indeksdan oldingi belgigacha) substring = text[0:5] # Natija: 'Hello' (0-indeksdan 4-indeksgacha) # Natijalarni ekranga chiqaramiz print(first_char) print(last_char) print(substring)","title":"\u2747\ufe0f STRING E'LEMENTLARIGA MUROJAT QILISH"},{"location":"python/data-types/#stringlarni-kopaytirish","text":"\ud83d\udccc Python dasturida string ni ko\u2018paytirish orqali bir xil matnni takrorlash mumkin. Buning uchun * operatoridan foydalanamiz. # Stringni ko\u2018paytirish orqali bir xil e'lementni takrorlash mumkin # Buning uchun '*' operatoridan foydalanamiz text = \"Hello\" # hello so'zini 3 marta takrorlaymiz text_repeated = text * 3 # Natija: 'HelloHelloHello' # Natijani ekranga chiqaramiz print(text_repeated)","title":"\u2747\ufe0f STRINGLARNI KO'PAYTIRISH"},{"location":"python/data-types/#f-stringpython-36","text":"\ud83d\udccc Python 3.6 versiyasidan boshlab, string ichida o\u2018zgaruvchilarni (variables) va ifodalarni (expressions) to\u2018g\u2018ridan-to\u2018g\u2018ri joylashtirish uchun f-string (formatted string literal) usuli joriy etildi. Bu usul string formattingning eng qulay va tezkor usullaridan biri hisoblanadi. # O'zgaruvchilarni string ichida qulay tarzda qo'shish uchun f-string usulidan foydalanamiz ism = \"Umid\" yosh = 20 # f-string yordamida string ichiga o'zgaruvchilarni joylashtirish text = f\"Mening ismim {ism}, yoshim {yosh}da\" # Natija: Mening ismim Umid, yoshim 20da # Natijani ekranga chiqaramiz print(text)","title":"\u2747\ufe0f F-STRING(Python 3.6+)"},{"location":"python/data-types/#string-metodlari","text":"\ud83d\udccc Python dasturlash tilida, stringlar ustida turli xil operatsiyalarni bajarish uchun bir qancha o'rnatilgan metodlar mavjud. Quyida eng ko'p qo'llaniladigan string metodlari va ularning misollari keltirilgan: .upper() # .upper() - Matndagi barcha harflarni katta harfga aylantiradi text = \"hello\" print(text.upper()) # Natija: HELLO # Foydalanuvchi ismini doim katta harflarda saqlash uchun, # bazada bir xil ism turli holatda yozilgan bo\u2018lsa ham xatolik bo\u2018lmasin user_input = \"umid\" username = user_input.upper() print(username) # UMID .lower() # .lower() - Matndagi barcha harflarni kichik harfga aylantiradi text = \"HELLO\" print(text.lower()) # Natija: hello # Email yoki username tekshiruvda har doim kichik harflarga o\u2018zgartirish kerak, # chunki email kichik harflarda yoziladi email = \"User@Example.COM\" email_normalized = email.lower() print(email_normalized) # user@example.com .capitalize() # .capitalize() - Matnning birinchi harfini katta harfga, qolganlarini kichik harfga aylantiradi text = \"hello world\" print(text.capitalize()) # Natija: Hello world # Foydalanuvchi ismini chiroyli ko\u2018rsatish uchun, # faqat birinchi harf katta bo\u2018lsin name = \"umid\" print(name.capitalize()) # Umid .title() # .title() - Matndagi har bir so'zning birinchi harfini katta harfga aylantiradi text = \"hello world\" print(text.title()) # Natija: Hello World # Blog post yoki maqola sarlavhasini # har bir so\u2018zni bosh harfi katta bo\u2018lsin uchun formatlash title = \"python dasturlash asoslari\" print(title.title()) # Python Dasturlash Asoslari .lstrip() # .lstrip() - Matnning boshidagi bo'sh joylarni olib tashlaydi text = \" hello world \" print(text.lstrip()) # Natija: \"hello world \" .rstrip() # .rstrip() - Matnning oxiridagi bo'sh joylarni olib tashlaydi text = \" hello world \" print(text.rstrip()) # Natija: \" hello world\" .strip() # .strip() - Matnning boshidagi va oxiridagi bo'sh joylarni olib tashlaydi text = \" hello world \" print(text.strip()) # Natija: \"hello world\" # toza ma\u2019lumot olish maqsadida user_input = \" umid \" clean_input = user_input.strip() print(clean_input) # \"umid\" .replace(old, new) # 1-qator: \"matn\" nomli o'zgaruvchiga biror matn qiymatini beramiz matn = \"Salom dunyo\" # 2-qator: \"matn\"dagi \"dunyo\" so'zini \"Umid\" so'ziga almashtiramiz. # replace() metodi eski so'zni yangi so'z bilan almashtirib, natijani \"yangi_matn\" ga saqlaydi yangi_matn = matn.replace(\"dunyo\", \"Umid\") # 3-qator: Yangi hosil bo'lgan matnni ekranga chiqaramiz print(yangi_matn) # 1-qator: \"raqam\" o'zgaruvchisiga telefon raqamini matn ko'rinishida beramiz raqam = \"+998 90 123 45 67\" # 2-qator: # .replace(\" \", \"\") - bu yerda barcha bo'sh joylar (\" \") olib tashlanadi # .replace(\"+\", \"\") - bu yerda \"+\" belgisi olib tashlanadi raqam = raqam.replace(\" \", \"\").replace(\"+\", \"\") # 3-qator: Tozalangan raqamni ekranga chiqaramiz print(raqam) .split(separator) # 1-qator: \"text\" o'zgaruvchisiga matn berilgan text = \"Hello world Python\" # 2-qator: .split() metodi bo'sh joy (\" \") bo'yicha matnni bo'lib, ro'yxatga aylantiradi print(text.split()) # Natija: ['Hello', 'world', 'Python'] # 3-qator: .split('o') metodi \"o\" harfi bo'yicha bo'lib ro'yxatga aylantiradi print(text.split('o')) # Natija: ['Hell', ' w', 'rld Pyth', 'n'] # 1-qator: \"qidiruv\" nomli o'zgaruvchiga foydalanuvchi yozgan matn saqlanadi qidiruv = \"telefon kompyuter printer\" # 2-qator: .split() metodi yordamida matn bo'sh joy bo'yicha bo'linadi # Natijada ['telefon', 'kompyuter', 'printer'] degan ro'yxat (list) hosil bo'ladi sozlar = qidiruv.split() # 3-qator: ro'yxatdagi har bir so'z ustida aylanish (for loop) boshlanadi for text in sozlar: # 4-qator: har bir so'z ekranga chiqariladi print(\"Qidirilmoqda:\", text) .join(iterable) # 1-qator: 3 ta so'zdan iborat ro'yxat yaratiladi words = ['Hello', 'world', 'Python'] # 2-qator: ' '.join(words) ro'yxatdagi so'zlarni bo'sh joy bilan birlashtiradi print(' '.join(words)) # Natija: Hello world Python # 3-qator: '-'.join(words) so'zlarni \"-\" bilan birlashtiradi print('-'.join(words)) # Natija: Hello-world-Python # 1-qator: 'kodlar' nomli ro'yxat yaratilmoqda, # ichida 3 ta element - matn ko'rinishidagi kodlar bor kodlar = ['AB12', 'CD34', 'EF56'] # 2-qator: '-'.join(kodlar) yordamida ro'yxat elementlari orasiga # chiziqcha (\"-\") qo'yib, ularni bitta matnga birlashtiramiz parol = '-'.join(kodlar) # 3-qator: natijani ekranga chiqaramiz print(\"Yangi parol:\", parol) .find(substring) # 1-qator: text o'zgaruvchisiga \"Hello world\" matni saqlanmoqda text = \"Hello world\" # 2-qator: .find() metodi yordamida \"world\" so'zining text ichidagi # boshlanish indeksini topamiz. Agar topilsa, indeks qaytariladi print(text.find(\"world\")) # Natija: 6 # 3-qator: .find() metodi yordamida \"Python\" so'zining indeksini izlaymiz, # lekin matnda yo'q, shuning uchun -1 qaytariladi print(text.find(\"Python\")) # Natija: -1 # 1-qator: url o'zgaruvchisiga URL matni saqlanmoqda url = \"https://example.com/page?id=123\" # 2-qator: url ichidan \"id=\" matnining indeksini topamiz pos = url.find(\"id=\") # 3-qator: agar \"id=\" topilgan bo'lsa (indeks -1 emas) if pos != -1: # 4-qator: identifikatorni \"id=\" dan keyingi qismdan ajratib olamiz # pos+3 degani \"id=\" so'zidan keyingi belgidan boshlab olish identifikator = url[pos+3:] # 5-qator: ekranga chiqaramiz print(\"ID:\", identifikator) .startswith(prefix) # 1-qator: text o'zgaruvchisiga \"Hello world\" matni saqlanmoqda text = \"Hello world\" # 2-qator: .startswith() metodi yordamida matn \"Hello\" bilan boshlanishini tekshiramiz print(text.startswith(\"Hello\")) # Natija: True # 3-qator: .startswith() metodi yordamida matn \"world\" bilan boshlanishini tekshiramiz print(text.startswith(\"world\")) # Natija: False # 1-qator: url o'zgaruvchisiga URL manzili saqlanmoqda url = \"https://example.com/api/user\" # 2-qator: url matni \"https://example.com/api/\" bilan boshlanishini tekshiramiz if url.startswith(\"https://example.com/api/\"): # 3-qator: agar to'g'ri bo'lsa, \"API so'rovi\" deb chiqaramiz print(\"API so'rovi\") .endswith(suffix) # 1-qator: text o'zgaruvchisiga \"Hello world\" matni saqlanmoqda text = \"Hello world\" # 2-qator: .endswith() metodi yordamida matn \"world\" bilan tugashini tekshiramiz print(text.endswith(\"world\")) # Natija: True # 3-qator: .endswith() metodi yordamida matn \"Hello\" bilan tugashini tekshiramiz print(text.endswith(\"Hello\")) # Natija: False # 1-qator: filename o'zgaruvchisiga fayl nomi saqlanmoqda filename = \"photo.jpg\" # 2-qator: agar filename \".jpg\" bilan tugasa, shart bajariladi if filename.endswith(\".jpg\"): # 3-qator: ekranga \"Rasm fayli\" deb chiqaramiz print(\"Rasm fayli\") .count(substring) # 1-qator: text o'zgaruvchisiga \"hello hello world\" matni saqlanmoqda text = \"hello hello world\" # 2-qator: .count() metodi yordamida matnda \"hello\" so'zi necha marta takrorlanganini hisoblaymiz print(text.count(\"hello\")) # Natija: 2","title":"\u2747\ufe0f STRING METODLARI"},{"location":"python/data-types/#numbers","text":"\ud83d\udccc Numbers \u2014 bu sonlarni ifodalash uchun ishlatiladigan ma'lumot turi. \ud83d\udccc Pythonda asosiy 3ta number type mavjud: int \u2014 butun sonlar (masalan, 5, -10, 100) float \u2014 o'nlik sonlar (masalan, 3.14, -0.001, 2.0) complex \u2014 kompleks sonlar (masalan, 2 + 3j, -1j)","title":"\u2705 NUMBERS"},{"location":"python/data-types/#integer","text":"\ud83d\udccc Integer ma'lumot turi butun sonlarni ifodalaydi. Bu sonlar manfiy , musbat yoki 0 bo'lishi mumkin. Integerlar cheklanmagan uzunlikka ega, ya'ni Python juda katta sonlarni ham integer sifatida saqlay oladi. x = 10 # musbat butun son y = -5 # manfiy butun son z = 0 # nol a = 12345678901234567890 # juda katta butun son # Quyidagi print() funksiyalari har bir o'zgaruvchining turini ko'rsatadi print(type(x)) # <class 'int'> print(type(y)) # <class 'int'> print(type(z)) # <class 'int'> print(type(a)) # <class 'int'>","title":"\u2747\ufe0f INTEGER"},{"location":"python/data-types/#integer-ustida-amallar","text":"\ud83d\udccc Integerlar ustida asosiy matematik amallarni bajarish mumkin: # Integerlar (butun sonlar) ustida bajariladigan asosiy matematik amallar a = 10 # Birinchi butun son b = 3 # Ikkinchi butun son # Qo'shish: ikkita sonni qo'shadi, natija 13 bo'ladi print(a + b) # 10 + 3 = 13 # Ayirish: birinchi sondan ikkinchi sonni ayiradi, natija 7 bo'ladi print(a - b) # 10 - 3 = 7 # Ko'paytirish: ikkita sonni ko'paytiradi, natija 30 bo'ladi print(a * b) # 10 * 3 = 30 # Bo'lish: birinchi sonni ikkinchi songa bo'ladi, natija float (kasr) turida chiqadi print(a / b) # 10 / 3 \u2248 3.3333333333333335 # Butun qismini olish: bo'linmaning faqat butun qismini oladi, o'nlik qismi tashlanadi print(a // b) # 10 // 3 = 3 # Qoldiqni olish: bo'linmaning qoldig'ini hisoblaydi (modulus) print(a % b) # 10 % 3 = 1 # Darajaga ko'tarish: birinchi sonni ikkinchi son darajasiga ko'taradi print(a ** b) # 10 ** 3 = 1000","title":"\u2705 INTEGER USTIDA AMALLAR"},{"location":"python/data-types/#uzun-sonlarni-kiritish","text":"\ud83d\udccc Uzun sonlarni kiritishda, qulaylik uchun, raqamlarni pastki chiziq ( _ ) yordamida guruhlash mumkin. Python - son tarkibidagi pastki chiziqlarni ( _ ) inobatga olmasdan, uzun sonligicha qabul qiladi. # Bank hisobidagi pul miqdori (katta son) bank_hisobi = 1_250_000_000 # 1 milliard 250 million so'm print(\"Sizning hisobingizdagi mablag'\", bank_hisobi, \"so'm\") # Chiqarish: Sizning hisobingizdagi mablag' 1250000000 so'm","title":"\u2705 UZUN SONLARNI KIRITISH"},{"location":"python/data-types/#bir-nechta-ozgaruvchiga-qiymat-berish","text":"\ud83d\udccc Birdaniga bir nechta o'zgaruvchiga qiymat berish uchun o'zgaruvchilar va ularga mos qiymatlar vergul ( , ) bilan ajratiladi: # Bir nechta o'zgaruvchilarga bir qatorda qiymat berish mumkin # x ga 10 (integer), y ga -7.25 (float), z ga -30 (integer) qiymatlari bir vaqtning o'zida berildi x, y, z = 10, -7.25, -30 # Natijalarni chiqaramiz print(\"x ning qiymati:\", x) # 10 print(\"y ning qiymati:\", y) # -7.25 print(\"z ning qiymati:\", z) # -30","title":"\u2705 BIR NECHTA O'ZGARUVCHIGA QIYMAT BERISH"},{"location":"python/data-types/#ozgaruvchi-turini-almashtirish","text":"\ud83d\udccc Python dasturlash tilida o'zgaruvchilar turini bir ma'lumot turidan boshqa ma'lumot turiga o'zgartirish jarayoni type casting deb ataladi. # Type casting misollari \u2014 qiymatlarni o'zgaruvchilarga saqlash va ularni turini tekshirish # 1. int() \u2014 float va stringdan int ga o'tish float_son = 3.7 int_from_float = int(float_son) # 3.7 dan 3 ga (kasr qismi tashlanadi) string_son = \"25\" int_from_string = int(string_son) # \"25\" matnidan 25 (int) hosil bo'ladi # 2. float() \u2014 int va stringdan float ga o'tish int_son = 10 float_from_int = float(int_son) # 10 dan 10.0 ga string_float = \"3.14\" float_from_string = float(string_float) # \"3.14\" matnidan 3.14 hosil bo'ladi # 3. str() \u2014 har qanday qiymatni stringga aylantirish int_num = 123 str_from_int = str(int_num) # int 123 -> string \"123\" float_num = 3.14 str_from_float = str(float_num) # float 3.14 -> string \"3.14\" bool_val = True str_from_bool = str(bool_val) # True -> \"True\" # 4. bool() \u2014 qiymatni True yoki False ga aylantirish bool_from_one = bool(1) # 1 -> True bool_from_zero = bool(0) # 0 -> False bool_from_empty_str = bool(\"\") # bo'sh string -> False bool_from_nonempty_str = bool(\"Hello\") # bo'sh bo'lmagan string -> True bool_from_empty_list = bool([]) # bo'sh ro'yxat -> False bool_from_list = bool([1, 2, 3]) # bo'sh bo'lmagan ro'yxat -> True # Natijalarni chiqaramiz print(int_from_float, type(int_from_float)) # 3 <class 'int'> print(int_from_string, type(int_from_string)) # 25 <class 'int'> print(float_from_int, type(float_from_int)) # 10.0 <class 'float'> print(float_from_string, type(float_from_string)) # 3.14 <class 'float'> print(str_from_int, type(str_from_int)) # '123' <class 'str'> print(str_from_float, type(str_from_float)) # '3.14' <class 'str'> print(str_from_bool, type(str_from_bool)) # 'True' <class 'str'> print(bool_from_one, type(bool_from_one)) # True <class 'bool'> print(bool_from_zero, type(bool_from_zero)) # False <class 'bool'> print(bool_from_empty_str, type(bool_from_empty_str)) # False <class 'bool'> print(bool_from_nonempty_str, type(bool_from_nonempty_str)) # True <class 'bool'> print(bool_from_empty_list, type(bool_from_empty_list)) # False <class 'bool'> print(bool_from_list, type(bool_from_list)) # True <class 'bool'>","title":"\u2705 O'ZGARUVCHI TURINI ALMASHTIRISH"},{"location":"python/data-types/#input","text":"\ud83d\udccc input() \u2014 bu Python dasturlash tilidagi maxsus funksiya bo\u2018lib, u foydalanuvchidan klaviatura orqali ma'lumot olish uchun ishlatiladi. # input() funksiyasi foydalanuvchidan ma'lumot olish uchun ishlatiladi. # Funksiya ichidagi matn \u2014 bu foydalanuvchiga ko'rsatiladigan savol yoki so'rov. ism = input(\"Ismingizni kiriting: \") # Foydalanuvchidan ismni so'raymiz print(\"Salom,\", ism) # Kiritilgan ismni ekranga chiqaramiz \ud83d\udccc input() har doim matn (string) ko\u2018rinishida qiymat oladi. Agar son kiritilishini istasak, stringni son turiga o\u2018zgartirish kerak. # foydalanuvchi kiritgan matnni butun songa aylantiramiz yosh = int(input(\"Yoshingizni kiriting: \")) print(\"Sizning yoshingiz:\", yosh) # 1. Foydalanuvchidan tug'ilgan yilini so'raymiz t_yil = input(\"Tug'ilgan yilingizni kiriting: \") # 2. input() funksiyasi har doim matn (string) ko'rinishida ma'lumot beradi, # shuning uchun uni butun son (integer) ga o'tkazamiz t_yil = int(t_yil) # 3. Yilni hozirgi yil bilan solishtirib, yoshni hisoblaymiz hozirgi_yil = 2025 yosh = hozirgi_yil - t_yil # 4. Natijani ekranga chiqaramiz print(\"Siz \" + str(yosh) + \" yoshda ekansiz.\")","title":"\u2705 INPUT"},{"location":"python/data-types/#float","text":"\ud83d\udccc Pythonda o'nlik sonlar floating point numbers yoki qisqa qilib floats deyiladi. Ingliz tilida o'nlik sonlarni yozishda vergul ( , ) emas nuqta ( . ) belgisi ishlatiladi, va bu nuqta sonning katta kichikligiga qarab joyi o'zgargani uchun \"floating\" deyiladi. pi = 3.14159 # o'nlik son, ya'ni float turidagi o'zgaruvchi radius = 10 # butun son, ya'ni int turidagi o'zgaruvchi diametr = 2 * radius # diametrni hisoblaymiz (radiusning 2 barobariga teng) # aylana uzunligini hisoblab, natijani chiqaramiz print(\"Aylana uzunligi \", pi * diametr, \" ga teng.\")","title":"\u2747\ufe0f FLOAT"},{"location":"python/data-types/#float-ustida-amallar","text":"a = 5.5 # a o'zgaruvchisiga 5.5 (float) qiymat berildi b = 2.0 # b o'zgaruvchisiga 2.0 (float) qiymat berildi print(\"Qo\u2018shish:\", a + b) # a va b ni qo\u2018shish => 7.5 print(\"Ayirish:\", a - b) # a dan b ni ayirish => 3.5 print(\"Ko\u2018paytirish:\", a * b) # a va b ni ko\u2018paytirish => 11.0 print(\"Bo\u2018lish:\", a / b) # a ni b ga bo\u2018lish (haqiqiy bo\u2018lish) => 2.75 print(\"Butun qismga bo\u2018lish:\", a // b) # a ni b ga bo\u2018lish va butun qismni olish => 2.0 print(\"Qoldiq:\", a % b) # a ni b ga bo\u2018lishda qolgan qoldiq => 1.5 print(\"Daraja:\", a ** b) # a ni b-darajaga ko\u2018tarish => 30.25","title":"\u2747\ufe0f FLOAT USTIDA AMALLAR"},{"location":"python/data-types/#complex","text":"\ud83d\udccc Complex sonlar \u2014 bu ikkita qismdan iborat sonlar: haqiqiy qism (real part) va mavhum qism (imaginary part). \ud83d\udccc Pythonda murakkab sonlar complex tipida saqlanadi. Pythonda imaginary part j yoki J harfi bilan ifodalanadi (elektronika va fizikada j ishlatiladi, matematikada esa i ).","title":"\u2705 COMPLEX"},{"location":"python/data-types/#complex-son-yaratish","text":"# Kompleks son yaratamiz: real part 3, imaginary part 4j z1 = 3 + 4j # Kompleks sonni konsolga chiqaramiz print(z1) # Natija: (3+4j)","title":"\u2747\ufe0f COMPLEX SON YARATISH"},{"location":"python/data-types/#konstanta","text":"\ud83d\udccc Python dasturlash tilida \"constant\" deb ataladigan o'zgaruvchilar mavjud emas, lekin dasturchilar odatda o'zgaruvchilarni konstantalar sifatida ishlatishadi. Bu odatda o'zgaruvchining qiymati dastur davomida o'zgarmasligini anglatadi. Konstantalarni nomlash: Konstantalarni nomlashda katta harflar ishlatiladi. Bu, dasturchiga o'zgaruvchining qiymati o'zgarmasligini anglatadi. # Bu yerda PI nomli konstanta e'lon qilinmoqda # Odatda konstanta nomlari katta harflarda yoziladi # PI ning qiymati o\u2018zgarmaydi va doim 3.14159 bo\u2018lib qoladi PI = 3.14159 # Bu yerda MAX_USERS nomli konstanta e'lon qilinmoqda # Bu maksimum foydalanuvchilar sonini bildiradi MAX_USERS = 100 Konstantalarni modullarda saqlash: Konstantalarni alohida Python faylida (modulda) saqlash tavsiya etiladi. Bu, konstantalarni boshqa fayllarda ishlatishni osonlashtiradi. Misol uchun, constants.py nomli fayl yaratib, unda konstantalarni saqlash mumkin: # constants.py # constants.py faylida o'zgarmas (konstanta) qiymatlar saqlanadi # Bu konstantalar boshqa fayllardan import qilib ishlatiladi # Aylana uchun PI qiymati PI = 3.14159 # Maksimal foydalanuvchilar soni MAX_USERS = 100 Keyin boshqa faylda bu konstantalarni ishlatish mumkin: # main.py # constants.py modulidagi konstantalarni import qilamiz import constants # PI konstantasini terminalga chiqaramiz print(constants.PI) # Natija: 3.14159 # MAX_USERS konstantasini terminalga chiqaramiz print(constants.MAX_USERS) # Natija: 100 Konstantalarni o'zgartirishga urinish: Python tilida konstantalarni o'zgartirish mumkin, lekin bu tavsiya etilmaydi. Agar siz konstantani o'zgartirmoqchi bo'lsangiz, bu dastur xatolarga olib kelishi mumkin. # PI konstanta deb qaralmoqda, ya'ni doimiy qiymat sifatida ishlatiladi PI = 3.14159 # Ammo bu yerda PI qiymatini o'zgartirib yubordik # Bu sintaktik jihatdan xato emas, lekin yomon amaliyot hisoblanadi # Chunki dasturchilar PI o'zgarmaydi deb o'ylaydi PI = 3.14 # \u274c Bu tavsiya etilmaydi # Dastur davomida bu o'zgarish kutilmagan xatolarga olib kelishi mumkin print(\"PI qiymati:\", PI) # Natija: 3.14","title":"\u2705 KONSTANTA"},{"location":"python/data-types/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/data-types/#1-topshiriq-string-birlashtirish","text":"Foydalanuvchidan ism va familiya input() orqali oling. Ularni birlashtirib, \"F.I.O: \" tarzida ekranga chiqaring.","title":"\u2705 1-topshiriq: String birlashtirish"},{"location":"python/data-types/#2-topshiriq-string-uzunligini-topish","text":"Foydalanuvchidan matn input() orqali oling va uning uzunligini len() yordamida aniqlang.","title":"\u2705 2-topshiriq: String uzunligini topish"},{"location":"python/data-types/#3-topshiriq-string-indekslash-va-kesish","text":"\"Python dasturlash\" matnini o\u2018zgaruvchiga saqlang. Birinchi harfini, oxirgi harfini va \"dastur\" so\u2018zini alohida ekranga chiqaring.","title":"\u2705 3-topshiriq: String indekslash va kesish"},{"location":"python/data-types/#4-topshiriq-string-kopaytirish","text":"Foydalanuvchidan so\u2018z oling va uni 4 marta ketma-ket chiqaruvchi dastur yozing.","title":"\u2705 4-topshiriq: String ko\u2018paytirish"},{"location":"python/data-types/#5-topshiriq-f-stringdan-foydalanish","text":"Foydalanuvchidan ism va yosh input() orqali olib, quyidagicha f-string yordamida chiqaring. Misol: Ismingiz: Aziza, Yoshingiz: 19","title":"\u2705 5-topshiriq: F-stringdan foydalanish"},{"location":"python/data-types/#6-topshiriq-string-metodlari-bilan-ishlash","text":"Foydalanuvchidan matn input() orqali oling. Uni: - katta harflarga, - kichik harflarga, - birinchi harfini katta qilishga o\u2018zgartirib, har birini alohida ekranga chiqaring.","title":"\u2705 6-topshiriq: String metodlari bilan ishlash"},{"location":"python/data-types/#7-topshiriq-replace-va-split-metodi","text":"Foydalanuvchidan telefon raqami oling (masalan: \"+998 90 123 45 67\") va uni bo\u2018sh joylar va \"+\" belgisidan tozalang, so\u2018ng split() yordamida 2 xonali bloklarga ajrating.","title":"\u2705 7-topshiriq: .replace() va .split() metodi"},{"location":"python/data-types/#8-topshiriq-join-va-count","text":"Foydalanuvchidan so\u2018zlar ro\u2018yxatini input() orqali so\u2018rab, ularni vergul bilan birlashtiring va \"a\" harfi necha marta qatnashganini hisoblang.","title":"\u2705 8-topshiriq: .join() va .count()"},{"location":"python/data-types/#9-topshiriq-find-startswith-endswith","text":"Foydalanuvchidan matn va so\u2018z oling. Matnda so\u2018z qayerdan boshlanishini, matn aynan shu so\u2018z bilan boshlanish yoki tugashini aniqlang.","title":"\u2705 9-topshiriq: .find(), .startswith(), .endswith()"},{"location":"python/data-types/#10-topshiriq-integer-va-float-ustida-amallar","text":"Foydalanuvchidan ikkita butun son va bir float son oling. Ularning yig\u2018indisi, ko\u2018paytmasi va o\u2018zaro bo\u2018linmasini hisoblang.","title":"\u2705 10-topshiriq: Integer va float ustida amallar"},{"location":"python/data-types/#11-topshiriq-uzoq-sonni-guruhlash","text":"Bank hisobingizdagi pul miqdorini pastki chiziq yordamida o\u2018qish oson bo\u2018ladigan formatda yozing va ekranga chiqaring.","title":"\u2705 11-topshiriq: Uzoq sonni guruhlash"},{"location":"python/data-types/#12-topshiriq-type-casting-turini-ozgartirish","text":"Foydalanuvchidan raqamli matn oling va uni int, float, str va bool turiga o\u2018tkazib, har birini va turini chiqaring.","title":"\u2705 12-topshiriq: Type casting (turini o\u2018zgartirish)"},{"location":"python/data-types/#13-topshiriq-kompleks-son","text":"Real va imag qismlarni input orqali olib, kompleks son yarating va uni ekranga chiqaring.","title":"\u2705 13-topshiriq: Kompleks son"},{"location":"python/data-types/#14-topshiriq-konstantadan-foydalanish","text":"PI va MAX_USERS konstantasini yarating (katta harflar bilan). Ularni ekranga chiqaruvchi dastur yozing.","title":"\u2705 14-topshiriq: Konstantadan foydalanish"},{"location":"python/data-types/#15-topshiriq-foydalanuvchi-yoshi-va-input","text":"Foydalanuvchidan tug\u2018ilgan yilini input orqali olib, yoshini hisoblab chiqaring (hozirgi yilni o\u2018zingiz yozing). Misol: Siz 20 yoshdasiz.","title":"\u2705 15-topshiriq: Foydalanuvchi yoshi va input"},{"location":"python/database/","text":"\ud83e\udde9 15-DARS DATABASE \u2705 MA'LUMOTLAR BAZASI VA PYTHON HAQIDA TUSHUNCHA [!NOTE] SQLite \u2014 bu kichik, mustaqil va yengil ma\u2019lumotlar bazasi tizimi. U server talab qilmaydi, ya\u2019ni barcha ma\u2019lumotlar bitta faylda saqlanadi. Python sqlite3 moduli orqali biz SQLite bilan to\u2018g\u2018ridan-to\u2018g\u2018ri ishlashimiz mumkin. \u2705 SQLite AFZALLIKLARI: \u2705 Kichik va tez ishlaydi \u2705 Server talab qilmaydi \u2705 Platformadan mustaqil \u2705 Python\u2019da sqlite3 moduli bilan oson ishlaydi \u2705 DATABASE BILAN ISHLASH BOSQICHLARI \ud83d\udccc SQLite bilan ishlash uchun 5 asosiy bosqich mavjud: Bazaga ulanish \u2013 SQLite bazasiga ulanish yoki yangi fayl yaratish. Jadval yaratish \u2013 Ma\u2019lumotlarni saqlash uchun jadval hosil qilish. Ma\u2019lumot qo\u2018shish \u2013 Bazaga yangi malumotlar kiritish. Ma\u2019lumotlarni o\u2018qish \u2013 Jadvaldagi ma\u2019lumotlarni olish. Ma\u2019lumotlarni yangilash va o\u2018chirish \u2013 Malumotlarni o\u2018zgartirish yoki o\u2018chirish. \u2705 DATABASE BILAN ISHLASHNI BOSHLASH \u2705 MA'LUMOTLAR BAZASIGA ULANISH \ud83d\udccc Ma\u2019lumotlar bazasiga ulanish uchun sqlite3.connect() funksiyasidan foydalanamiz. # sqlite3 modulini import qilamiz \u2014 SQLite ma'lumotlar bazasi bilan ishlash uchun kerak import sqlite3 # students.db nomli SQLite ma'lumotlar bazasiga ulanamiz # Agar bunday fayl bo\u2018lmasa, yangi ma'lumotlar bazasi yaratiladi conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz \u2014 bu orqali SQL buyruqlarini bajarish mumkin bo\u2018ladi cur = conn.cursor() # Bazaga muvaffaqiyatli ulanganimiz haqida xabar chiqaramiz print(\"Ma\u2019lumotlar bazasiga bog\u2018landik!\") # Ma'lumotlar bazasi bilan ish tugagach, ulanishni yopamiz conn.close() \u2705 JADVAL YARATISH \ud83d\udccc Jadval yaratish uchun CREATE TABLE SQL buyrug\u2018idan foydalanamiz. # sqlite3 modulini import qilamiz \u2014 SQLite bilan ishlash uchun kerak import sqlite3 # Bazaga ulanamiz (\"students.db\" fayl ko\u2018rinishida bo\u2018ladi) conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz \u2014 SQL buyruqlarini bajarish uchun kerak cur = conn.cursor() # Studentlar jadvalini yaratamiz agar mavjud bo\u2018lmasa # Jadvalda quyidagi ustunlar bo\u2018ladi: # id - unikal ID, avtomatik raqamlanadi # name - talabaning ismi (string, bo\u2018sh bo\u2018lishi mumkin emas) # age - talabaning yoshi (integer, bo\u2018sh bo\u2018lishi mumkin emas) # grade - talabaning bahosi yoki kursi (string, bo\u2018sh bo\u2018lishi mumkin emas) cur.execute(\"\"\" CREATE TABLE IF NOT EXISTS students ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER NOT NULL, grade TEXT NOT NULL ) \"\"\") # Jadval yaratildi degan xabarni chiqaramiz print(\"Jadval yaratildi!\") # O\u2018zgartirishlarni saqlaymiz (commit qilamiz) conn.commit() # Bazaga ulanishni yopamiz conn.close() \u2705 MA'LUMOT QO'SHISH \ud83d\udccc Ma\u2019lumot qo\u2018shish uchun INSERT INTO buyrug\u2018idan foydalanamiz. # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvaliga yangi talaba ma'lumotini qo\u2018shamiz # SQL so\u2018rovda parametrlar o\u2018rnida ? ishlatiladi, bu xavfsizroq va SQL injection xavfini kamaytiradi # (\"Ali\", 20, \"A\") \u2014 bu parametrlar name, age va grade ustunlariga mos keladi cur.execute(\"INSERT INTO students (name, age, grade) VALUES (?, ?, ?)\", (\"Ali\", 20, \"A\")) # Ma'lumot qo\u2018shilgani haqida xabar chiqaramiz print(\"Ma\u2019lumot qo\u2018shildi!\") # O\u2018zgarishlarni saqlaymiz conn.commit() # Bazaga ulanishni yopamiz conn.close() \ud83d\udccc Agar bir nechta ma\u2019lumot qo\u2018shmoqchi bo\u2018lsak: # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # Bir nechta talaba ma'lumotlarini ro'yxat shaklida tayyorlaymiz students = [ (\"Vali\", 19, \"B\"), (\"Hasan\", 21, \"A\"), (\"Shahnoza\", 20, \"C\") ] # Ro'yxatdagi barcha ma'lumotlarni jadvalga bir vaqtning o'zida qo'shamiz cur.executemany(\"INSERT INTO students (name, age, grade) VALUES (?, ?, ?)\", students) # Ma'lumotlar qo'shilganini bildiruvchi xabar chiqaramiz print(\"Bir nechta yozuv qo\u2018shildi!\") # O'zgarishlarni saqlaymiz conn.commit() # Bazaga ulanishni yopamiz conn.close() \u2705 MA'LUMOTLARNI O'QISH \ud83d\udccc Jadvaldagi barcha ma\u2019lumotlarni olish uchun SELECT buyrug\u2018idan foydalanamiz. # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvalidan barcha ustunlarni tanlab olamiz cur.execute(\"SELECT * FROM students\") # \"SELECT *\" \u2014 jadvaldagi barcha ustunlar va qatorlar # Barcha natijalarni list ko\u2018rinishida olamiz students = cur.fetchall() # Har bir talaba ma'lumotini alohida chiqaramiz for student in students: print(student) # Bazaga ulanishni yopamiz conn.close() \ud83d\udccc Agar faqat bitta ma\u2019lumot olish kerak bo\u2018lsa: # students jadvalidan name ustuni \"Ali\" ga teng bo\u2018lgan birinchi qatorni tanlab olish cur.execute(\"SELECT * FROM students WHERE name = ?\", (\"Ali\",)) # Natijadan faqat bitta qatorni olish (birinchi topilgan) student = cur.fetchone() # Topilgan yozuvni konsolga chiqarish print(student) \u2705 MA'LUMOTLARNI YANGILASH \ud83d\udccc Ma\u2019lumotlarni o\u2018zgartirish uchun UPDATE buyrug\u2018idan foydalanamiz. # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvalidagi name ustuni \"Ali\" bo\u2018lgan qatorni age ustunini 21 ga o\u2018zgartiramiz cur.execute(\"UPDATE students SET age = ? WHERE name = ?\", (21, \"Ali\")) # Yangilanganini bildiruvchi xabar chiqaramiz print(\"Ma\u2019lumot yangilandi!\") # O\u2018zgarishlarni saqlaymiz conn.commit() # Bazaga ulanishni yopamiz conn.close() \u2705 MA'LUMOTLARNI O'CHIRISH \ud83d\udccc Ma\u2019lumotlarni o\u2018chirish uchun DELETE FROM buyrug\u2018idan foydalanamiz. # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvalidan name ustuni \"Ali\" bo\u2018lgan qatorni o\u2018chiramiz cur.execute(\"DELETE FROM students WHERE name = ?\", (\"Ali\",)) # O\u2018chirildi degan xabarni chiqaramiz print(\"Ma\u2019lumot o\u2018chirildi!\") # O\u2018zgarishlarni saqlaymiz conn.commit() # Bazaga ulanishni yopamiz conn.close() \u2705 XATOLIKLARNI USHLASH \ud83d\udccc Ma\u2019lumotlar bazasi bilan ishlaganda xatoliklarni ushlash muhim. # try-except-finally blokida kod yozamiz \u2014 xatolik yuz berganda uni ushlab, boshqarish uchun try: # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvalidan barcha ustunlar va qatorlarni olamiz cur.execute(\"SELECT * FROM students\") # Natijalarni list sifatida saqlaymiz students = cur.fetchall() # Har bir ma'lumotni ekranga chiqaramiz for student in students: print(student) # Agar sqlite3 bilan bog\u2018liq xatolik yuz bersa, uni ushlaymiz va xabar chiqaramiz except sqlite3.Error as e: print(\"Xatolik yuz berdi:\", e) # Nihoyat, kod tugagach (xato bo\u2018lsa ham yoki bo\u2018lmasa ham) bazaga ulanishni yopamiz finally: conn.close() \u2705 AMALIYOT \u2705 1-topshiriq: \"library.db\" nomli SQLite bazasini yarating. \"books\" nomli jadval yarating ( id , title , author , year ). - id INTEGER PRIMARY KEY AUTOINCREMENT - title , author , year NOT NULL \u2705 2-topshiriq: \"books\" jadvaliga quyidagi ma\u2019lumotlarni kiriting ( executemany() funksiyasidan foydalaning): | id | title | author | year | |-----|--------------------|---------------|-------| | 1 | Python Basics | John Smith | 2020 | | 2 | SQL for Beginners | Alice Brown | 2018 | | 3 | Data Science Guide | Michael Clark | 2021 | \u2705 3-topshiriq: \"books\" jadvalidagi barcha kitoblarni ekranga chiqaring. Natija id , title , author , year formatida bo\u2018lsin. \u2705 4-topshiriq: Foydalanuvchidan muallif nomini so\u2018rang. Shu muallif tomonidan yozilgan barcha kitoblarni chiqaring. Agar kitob topilmasa, \"Bu muallifning kitoblari yo'q\" deb chiqaring. \u2705 5-topshiriq: \"SQL for Beginners\" kitobining chiqish yilini 2019 ga o\u2018zgartiring. Yangilangan ma\u2019lumotni ekranga chiqaring. \u2705 6-topshiriq: \"books\" jadvalidan chiqish yili eng kichik bo\u2018lgan kitobni toping (eng eski kitob). \u2705 7-topshiriq: \"books\" jadvalidan 2020 yildan keyin chiqqan kitoblarni chiqarish kodini yozing. \u2705 8-topshiriq: \"Data Science Guide\" kitobini \"books\" jadvalidan o\u2018chiring. O\u2018chirilganidan keyin jadvaldagi barcha kitoblarni ekranga chiqaring. \u2705 9-topshiriq: \"university.db\" bazasini yarating va \"students\" jadvalini yarating: - id INTEGER PRIMARY KEY AUTOINCREMENT - name TEXT NOT NULL - age INTEGER NOT NULL - faculty TEXT NOT NULL \u2705 10-topshiriq: \"students\" jadvaliga kamida 5 ta talaba haqida ma\u2019lumot kiriting. \u2705 11-topshiriq: Foydalanuvchidan fakultet nomini so\u2018rang va shu fakultetdagi talabalarni chiqaring. \u2705 12-topshiriq: \"students\" jadvalidan eng yosh talabani toping. \u2705 13-topshiriq: \"name\" ismli talabaning yoshini 21 ga o\u2018zgartiring. \u2705 14-topshiriq: \"students\" jadvalidagi har bir fakultet bo\u2018yicha nechta talaba borligini hisoblang. \u2705 15-topshiriq: \"students\" jadvalidan eng ko\u2018p talabaga ega bo\u2018lgan fakultetni aniqlang.","title":"Database"},{"location":"python/database/#15-dars-database","text":"","title":"\ud83e\udde9 15-DARS DATABASE"},{"location":"python/database/#malumotlar-bazasi-va-python-haqida-tushuncha","text":"[!NOTE] SQLite \u2014 bu kichik, mustaqil va yengil ma\u2019lumotlar bazasi tizimi. U server talab qilmaydi, ya\u2019ni barcha ma\u2019lumotlar bitta faylda saqlanadi. Python sqlite3 moduli orqali biz SQLite bilan to\u2018g\u2018ridan-to\u2018g\u2018ri ishlashimiz mumkin. \u2705 SQLite AFZALLIKLARI: \u2705 Kichik va tez ishlaydi \u2705 Server talab qilmaydi \u2705 Platformadan mustaqil \u2705 Python\u2019da sqlite3 moduli bilan oson ishlaydi","title":"\u2705 MA'LUMOTLAR BAZASI VA PYTHON HAQIDA TUSHUNCHA"},{"location":"python/database/#database-bilan-ishlash-bosqichlari","text":"\ud83d\udccc SQLite bilan ishlash uchun 5 asosiy bosqich mavjud: Bazaga ulanish \u2013 SQLite bazasiga ulanish yoki yangi fayl yaratish. Jadval yaratish \u2013 Ma\u2019lumotlarni saqlash uchun jadval hosil qilish. Ma\u2019lumot qo\u2018shish \u2013 Bazaga yangi malumotlar kiritish. Ma\u2019lumotlarni o\u2018qish \u2013 Jadvaldagi ma\u2019lumotlarni olish. Ma\u2019lumotlarni yangilash va o\u2018chirish \u2013 Malumotlarni o\u2018zgartirish yoki o\u2018chirish.","title":"\u2705 DATABASE BILAN ISHLASH BOSQICHLARI"},{"location":"python/database/#database-bilan-ishlashni-boshlash","text":"","title":"\u2705 DATABASE BILAN ISHLASHNI BOSHLASH"},{"location":"python/database/#malumotlar-bazasiga-ulanish","text":"\ud83d\udccc Ma\u2019lumotlar bazasiga ulanish uchun sqlite3.connect() funksiyasidan foydalanamiz. # sqlite3 modulini import qilamiz \u2014 SQLite ma'lumotlar bazasi bilan ishlash uchun kerak import sqlite3 # students.db nomli SQLite ma'lumotlar bazasiga ulanamiz # Agar bunday fayl bo\u2018lmasa, yangi ma'lumotlar bazasi yaratiladi conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz \u2014 bu orqali SQL buyruqlarini bajarish mumkin bo\u2018ladi cur = conn.cursor() # Bazaga muvaffaqiyatli ulanganimiz haqida xabar chiqaramiz print(\"Ma\u2019lumotlar bazasiga bog\u2018landik!\") # Ma'lumotlar bazasi bilan ish tugagach, ulanishni yopamiz conn.close()","title":"\u2705 MA'LUMOTLAR BAZASIGA ULANISH"},{"location":"python/database/#jadval-yaratish","text":"\ud83d\udccc Jadval yaratish uchun CREATE TABLE SQL buyrug\u2018idan foydalanamiz. # sqlite3 modulini import qilamiz \u2014 SQLite bilan ishlash uchun kerak import sqlite3 # Bazaga ulanamiz (\"students.db\" fayl ko\u2018rinishida bo\u2018ladi) conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz \u2014 SQL buyruqlarini bajarish uchun kerak cur = conn.cursor() # Studentlar jadvalini yaratamiz agar mavjud bo\u2018lmasa # Jadvalda quyidagi ustunlar bo\u2018ladi: # id - unikal ID, avtomatik raqamlanadi # name - talabaning ismi (string, bo\u2018sh bo\u2018lishi mumkin emas) # age - talabaning yoshi (integer, bo\u2018sh bo\u2018lishi mumkin emas) # grade - talabaning bahosi yoki kursi (string, bo\u2018sh bo\u2018lishi mumkin emas) cur.execute(\"\"\" CREATE TABLE IF NOT EXISTS students ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER NOT NULL, grade TEXT NOT NULL ) \"\"\") # Jadval yaratildi degan xabarni chiqaramiz print(\"Jadval yaratildi!\") # O\u2018zgartirishlarni saqlaymiz (commit qilamiz) conn.commit() # Bazaga ulanishni yopamiz conn.close()","title":"\u2705 JADVAL YARATISH"},{"location":"python/database/#malumot-qoshish","text":"\ud83d\udccc Ma\u2019lumot qo\u2018shish uchun INSERT INTO buyrug\u2018idan foydalanamiz. # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvaliga yangi talaba ma'lumotini qo\u2018shamiz # SQL so\u2018rovda parametrlar o\u2018rnida ? ishlatiladi, bu xavfsizroq va SQL injection xavfini kamaytiradi # (\"Ali\", 20, \"A\") \u2014 bu parametrlar name, age va grade ustunlariga mos keladi cur.execute(\"INSERT INTO students (name, age, grade) VALUES (?, ?, ?)\", (\"Ali\", 20, \"A\")) # Ma'lumot qo\u2018shilgani haqida xabar chiqaramiz print(\"Ma\u2019lumot qo\u2018shildi!\") # O\u2018zgarishlarni saqlaymiz conn.commit() # Bazaga ulanishni yopamiz conn.close() \ud83d\udccc Agar bir nechta ma\u2019lumot qo\u2018shmoqchi bo\u2018lsak: # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # Bir nechta talaba ma'lumotlarini ro'yxat shaklida tayyorlaymiz students = [ (\"Vali\", 19, \"B\"), (\"Hasan\", 21, \"A\"), (\"Shahnoza\", 20, \"C\") ] # Ro'yxatdagi barcha ma'lumotlarni jadvalga bir vaqtning o'zida qo'shamiz cur.executemany(\"INSERT INTO students (name, age, grade) VALUES (?, ?, ?)\", students) # Ma'lumotlar qo'shilganini bildiruvchi xabar chiqaramiz print(\"Bir nechta yozuv qo\u2018shildi!\") # O'zgarishlarni saqlaymiz conn.commit() # Bazaga ulanishni yopamiz conn.close()","title":"\u2705 MA'LUMOT QO'SHISH"},{"location":"python/database/#malumotlarni-oqish","text":"\ud83d\udccc Jadvaldagi barcha ma\u2019lumotlarni olish uchun SELECT buyrug\u2018idan foydalanamiz. # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvalidan barcha ustunlarni tanlab olamiz cur.execute(\"SELECT * FROM students\") # \"SELECT *\" \u2014 jadvaldagi barcha ustunlar va qatorlar # Barcha natijalarni list ko\u2018rinishida olamiz students = cur.fetchall() # Har bir talaba ma'lumotini alohida chiqaramiz for student in students: print(student) # Bazaga ulanishni yopamiz conn.close() \ud83d\udccc Agar faqat bitta ma\u2019lumot olish kerak bo\u2018lsa: # students jadvalidan name ustuni \"Ali\" ga teng bo\u2018lgan birinchi qatorni tanlab olish cur.execute(\"SELECT * FROM students WHERE name = ?\", (\"Ali\",)) # Natijadan faqat bitta qatorni olish (birinchi topilgan) student = cur.fetchone() # Topilgan yozuvni konsolga chiqarish print(student)","title":"\u2705 MA'LUMOTLARNI O'QISH"},{"location":"python/database/#malumotlarni-yangilash","text":"\ud83d\udccc Ma\u2019lumotlarni o\u2018zgartirish uchun UPDATE buyrug\u2018idan foydalanamiz. # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvalidagi name ustuni \"Ali\" bo\u2018lgan qatorni age ustunini 21 ga o\u2018zgartiramiz cur.execute(\"UPDATE students SET age = ? WHERE name = ?\", (21, \"Ali\")) # Yangilanganini bildiruvchi xabar chiqaramiz print(\"Ma\u2019lumot yangilandi!\") # O\u2018zgarishlarni saqlaymiz conn.commit() # Bazaga ulanishni yopamiz conn.close()","title":"\u2705 MA'LUMOTLARNI YANGILASH"},{"location":"python/database/#malumotlarni-ochirish","text":"\ud83d\udccc Ma\u2019lumotlarni o\u2018chirish uchun DELETE FROM buyrug\u2018idan foydalanamiz. # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvalidan name ustuni \"Ali\" bo\u2018lgan qatorni o\u2018chiramiz cur.execute(\"DELETE FROM students WHERE name = ?\", (\"Ali\",)) # O\u2018chirildi degan xabarni chiqaramiz print(\"Ma\u2019lumot o\u2018chirildi!\") # O\u2018zgarishlarni saqlaymiz conn.commit() # Bazaga ulanishni yopamiz conn.close()","title":"\u2705 MA'LUMOTLARNI O'CHIRISH"},{"location":"python/database/#xatoliklarni-ushlash","text":"\ud83d\udccc Ma\u2019lumotlar bazasi bilan ishlaganda xatoliklarni ushlash muhim. # try-except-finally blokida kod yozamiz \u2014 xatolik yuz berganda uni ushlab, boshqarish uchun try: # Bazaga ulanamiz conn = sqlite3.connect(\"students.db\") # Cursor obyekti yaratamiz cur = conn.cursor() # students jadvalidan barcha ustunlar va qatorlarni olamiz cur.execute(\"SELECT * FROM students\") # Natijalarni list sifatida saqlaymiz students = cur.fetchall() # Har bir ma'lumotni ekranga chiqaramiz for student in students: print(student) # Agar sqlite3 bilan bog\u2018liq xatolik yuz bersa, uni ushlaymiz va xabar chiqaramiz except sqlite3.Error as e: print(\"Xatolik yuz berdi:\", e) # Nihoyat, kod tugagach (xato bo\u2018lsa ham yoki bo\u2018lmasa ham) bazaga ulanishni yopamiz finally: conn.close()","title":"\u2705 XATOLIKLARNI USHLASH"},{"location":"python/database/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/database/#1-topshiriq","text":"\"library.db\" nomli SQLite bazasini yarating. \"books\" nomli jadval yarating ( id , title , author , year ). - id INTEGER PRIMARY KEY AUTOINCREMENT - title , author , year NOT NULL","title":"\u2705 1-topshiriq:"},{"location":"python/database/#2-topshiriq","text":"\"books\" jadvaliga quyidagi ma\u2019lumotlarni kiriting ( executemany() funksiyasidan foydalaning): | id | title | author | year | |-----|--------------------|---------------|-------| | 1 | Python Basics | John Smith | 2020 | | 2 | SQL for Beginners | Alice Brown | 2018 | | 3 | Data Science Guide | Michael Clark | 2021 |","title":"\u2705 2-topshiriq:"},{"location":"python/database/#3-topshiriq","text":"\"books\" jadvalidagi barcha kitoblarni ekranga chiqaring. Natija id , title , author , year formatida bo\u2018lsin.","title":"\u2705 3-topshiriq:"},{"location":"python/database/#4-topshiriq","text":"Foydalanuvchidan muallif nomini so\u2018rang. Shu muallif tomonidan yozilgan barcha kitoblarni chiqaring. Agar kitob topilmasa, \"Bu muallifning kitoblari yo'q\" deb chiqaring.","title":"\u2705 4-topshiriq:"},{"location":"python/database/#5-topshiriq","text":"\"SQL for Beginners\" kitobining chiqish yilini 2019 ga o\u2018zgartiring. Yangilangan ma\u2019lumotni ekranga chiqaring.","title":"\u2705 5-topshiriq:"},{"location":"python/database/#6-topshiriq","text":"\"books\" jadvalidan chiqish yili eng kichik bo\u2018lgan kitobni toping (eng eski kitob).","title":"\u2705 6-topshiriq:"},{"location":"python/database/#7-topshiriq","text":"\"books\" jadvalidan 2020 yildan keyin chiqqan kitoblarni chiqarish kodini yozing.","title":"\u2705 7-topshiriq:"},{"location":"python/database/#8-topshiriq","text":"\"Data Science Guide\" kitobini \"books\" jadvalidan o\u2018chiring. O\u2018chirilganidan keyin jadvaldagi barcha kitoblarni ekranga chiqaring.","title":"\u2705 8-topshiriq:"},{"location":"python/database/#9-topshiriq","text":"\"university.db\" bazasini yarating va \"students\" jadvalini yarating: - id INTEGER PRIMARY KEY AUTOINCREMENT - name TEXT NOT NULL - age INTEGER NOT NULL - faculty TEXT NOT NULL","title":"\u2705 9-topshiriq:"},{"location":"python/database/#10-topshiriq","text":"\"students\" jadvaliga kamida 5 ta talaba haqida ma\u2019lumot kiriting.","title":"\u2705 10-topshiriq:"},{"location":"python/database/#11-topshiriq","text":"Foydalanuvchidan fakultet nomini so\u2018rang va shu fakultetdagi talabalarni chiqaring.","title":"\u2705 11-topshiriq:"},{"location":"python/database/#12-topshiriq","text":"\"students\" jadvalidan eng yosh talabani toping.","title":"\u2705 12-topshiriq:"},{"location":"python/database/#13-topshiriq","text":"\"name\" ismli talabaning yoshini 21 ga o\u2018zgartiring.","title":"\u2705 13-topshiriq:"},{"location":"python/database/#14-topshiriq","text":"\"students\" jadvalidagi har bir fakultet bo\u2018yicha nechta talaba borligini hisoblang.","title":"\u2705 14-topshiriq:"},{"location":"python/database/#15-topshiriq","text":"\"students\" jadvalidan eng ko\u2018p talabaga ega bo\u2018lgan fakultetni aniqlang.","title":"\u2705 15-topshiriq:"},{"location":"python/dictionaries/","text":"\ud83e\udde9 7-DARS DICTIONARY \u2705 DICTIONARY NIMA? \ud83d\udccc Python dasturlash tilida dictionary \u2014 bu kalit-qiymat (key-value) juftliklarini saqlovchi ma\u2019lumotlar turidir. Har bir kalit yagona bo\u2018ladi va unga mos qiymat bo\u2018ladi. Dictionary ma\u2019lumotlar {} qavslar ichida yoziladi va har bir kalit bilan qiymat : bilan ajratiladi. Bu ma'lumot turi ma\u2019lumotlarni tartibli saqlash, oson topish va boshqarish uchun ishlatiladi. \u2705 DICTIONARY YARATISH \u2747\ufe0f BO'SH DICTIONARY YARATISH # Bo'sh dictionary yaratish user_info = {} \u2747\ufe0f E'LEMENTLAR BILAN DICTIONARY YARATISH # Kalit-qiymatlar bilan dictionary yaratish user_info = { 'name': 'Alice', # Foydalanuvchining ismi 'age': 30, # Foydalanuvchining yoshi 'city': 'New York' # Foydalanuvchining shahri } \u2705 DICTIONARYGA E'LEMENT QO'SHISH \ud83d\udccc Dictionaryga e'lement qo'shish uchun o'zgaruvchi nomidan kn [] qavs ochib ichiga keyni beramiz, undan keyin qo'shmoqchi bo'lgan value yani qiymatni beramiz. # Bo'sh dictionary yaratilyapti student_info = {} # Dictionary ga yangi kalit-qiymat juftligi qo\u2018shilmoqda: ism student_info[\"name\"] = \"Umid\" # Dictionary ga yangi kalit-qiymat juftligi qo\u2018shilmoqda: yosh student_info[\"age\"] = 20 # Dictionary ga yangi kalit-qiymat juftligi qo\u2018shilmoqda: kurs student_info[\"course\"] = \"Python Programming\" # Dictionary ga yangi kalit-qiymat juftligi qo\u2018shilmoqda: talabalik holati student_info[\"is_student\"] = True # Natijani ekranga chiqarish print(student_info) \u2705 E'LEMENTLARNI YANGILASH # Talaba haqida ma'lumotlarni saqlovchi dictionary yaratilmoqda student_profile = { \"full_name\": \"Azizbek Tursunov\", \"age\": 19, \"faculty\": \"Computer Science\", \"is_active\": True } # \"age\" kalitiga yangi yosh qiymati berilmoqda (19 dan 20 ga yangilanmoqda) student_profile[\"age\"] = 20 # \"faculty\" kalitidagi qiymat o\u2018zgartirilmoqda (Computer Science dan Data Science ga) student_profile[\"faculty\"] = \"Data Science\" # \"is_active\" kalitidagi qiymat yangilanmoqda (True dan False ga) student_profile[\"is_active\"] = False # Natija ekranga chiqarilmoqda print(student_profile) \u2705 E'LEMENT O'CHIRISH \u2747\ufe0f DEL \ud83d\udccc Lug'at ichidagi e'lementlarni o'chirish uchun del funksiyasidan foydalanamiz. # Kitob haqida ma'lumotlar saqlanayotgan dictionary yaratilmoqda book_info = { \"title\": \"Python Basics\", \"author\": \"John Smith\", \"year\": 2021, \"price\": 150000 } # \"price\" kalitidagi element dictionary dan o\u2018chirilmoqda del book_info[\"price\"] # Natija ekranga chiqarilmoqda print(book_info) \u2747\ufe0f POP \ud83d\udccc Lug'atdagi e'lementlarni o'chirish uchun .pop() metodidan ham foydalansak bo'ladi. # Telefon ma'lumotlari saqlanayotgan dictionary yaratilmoqda phone_details = { \"brand\": \"Samsung\", \"model\": \"Galaxy S21\", \"storage\": \"128GB\", \"price\": 900 } # \"storage\" kalitli element .pop() orqali o\u2018chirilmoqda va qiymati o'zgaruvchiga saqlanmoqda removed_value = phone_details.pop(\"storage\") # O\u2018chirilgan qiymat ekranga chiqarilmoqda print(\"Removed:\", removed_value) # Yangilangan dictionary ekranga chiqarilmoqda print(phone_details) \u2705 E'LEMENTLARGA MUROJAT QILISH \u2747\ufe0f KEYS \ud83d\udccc Kalitlarni olish. # Foydalanuvchi haqida ma'lumot saqlanmoqda user_info = { \"name\": \"Alice\", \"city\": \"New York\" } # Barcha kalitlar (key) alohida olinmoqda keys = user_info.keys() # Kalitlar ekranga chiqarilmoqda print(keys) \u2747\ufe0f VALUES \ud83d\udccc Qiymatlarni olish. # Foydalanuvchi haqida ma'lumot saqlanmoqda user_info = { \"name\": \"Alice\", \"city\": \"New York\" } # Barcha qiymatlar (value) alohida olinmoqda values = user_info.values() # Qiymatlar ekranga chiqarilmoqda print(values) \u2747\ufe0f ITEMS \ud83d\udccc Kalit-qiymat juftliklarini olish: # Foydalanuvchi haqida ma'lumot saqlanmoqda user_info = { \"name\": \"Alice\", \"city\": \"New York\" } # Barcha kalit-qiymat juftliklari alohida olinmoqda items = user_info.items() # Juftliklar ekranga chiqarilmoqda print(items) \u2705 FOYDALI METODLAR \u2747\ufe0f GET \ud83d\udccc Kalit bo'yicha qiymatni oladi. Kalit mavjud bo'lmasa, None qaytaradi. # Avtomobil haqida ma'lumotlar saqlanmoqda car_info = { \"brand\": \"Chevrolet\", \"model\": \"Malibu\", \"year\": 2022 } # \"model\" kaliti orqali qiymat olinmoqda, agar mavjud bo\u2018lsa \u2014 shu qiymat qaytadi car_model = car_info.get(\"model\", \"Not Found\") print(\"Model:\", car_model) # Natija: Malibu # \"color\" degan kalit mavjud emas, shuning uchun \"Not Found\" qiymati qaytadi car_color = car_info.get(\"color\", \"Not Found\") print(\"Color:\", car_color) # Natija: Not Found \u2747\ufe0f UPDATE \ud83d\udccc Dictionaryga yangi ma'lumot qo'shish yoki yangilash uchun ishlatiladi. # Talaba haqida dastlabki ma'lumotlar saqlanmoqda student_info = { \"name\": \"Diyor\", \"age\": 18, \"course\": \"Python\" } # update() metodi yordamida yangi ma'lumotlar qo\u2018shilmoqda yoki mavjudlari yangilanmoqda student_info.update({ \"age\": 19, # age mavjud edi \u2014 yangilanmoqda \"course\": \"Django\", # course mavjud edi \u2014 yangilanmoqda \"is_active\": True # yangi kalit \u2014 qo\u2018shilmoqda }) # Natijani ekranga chiqarish print(student_info) \u2747\ufe0f POPINTEM \ud83d\udccc Dictionarydan oxirgi qo\u2018shilgan kalit-qiymat juftligini olib tashlaydi va o\u2018sha juftlikni qaytaradi. # Mehmon haqida ma'lumotlar saqlanmoqda guest_info = { \"name\": \"Javlon\", \"room\": 305, \"nights\": 3 } # Oxirgi qo\u2018shilgan kalit-qiymat juftligi dictionary dan o\u2018chirilmoqda removed_item = guest_info.popitem() # O\u2018chirilgan juftlik (tuple shaklida) ekranga chiqarilmoqda print(\"Removed:\", removed_item) # Yangilangan dictionary ekranga chiqarilmoqda print(\"Updated:\", guest_info) \u2747\ufe0f SETDEFAULT \ud83d\udccc Kalit mavjud bo'lmasa, qiymat qo'shadi va qaytaradi. # Foydalanuvchi haqida boshlang\u2018ich ma\u2019lumotlar user_info = { \"username\": \"umiddev\", \"email\": \"umid@example.com\" } # \"email\" kaliti mavjud bo\u2018lgani uchun mavjud qiymatni qaytaradi email = user_info.setdefault(\"email\", \"default@example.com\") print(\"Email:\", email) # \"phone\" kaliti yo\u2018q edi, shuning uchun u yaratilib, berilgan qiymat qo\u2018shiladi phone = user_info.setdefault(\"phone\", \"+998901234567\") print(\"Phone:\", phone) # Yangilangan dictionary ekranga chiqarilmoqda print(\"Updated user_info:\", user_info) \u2705 AMALIYOT \u2705 1-topshiriq: Bo\u2018sh dictionary yarating va unga quyidagi kalit-qiymatlarni qo\u2018shing: - \"name\" : \"John\" - \"age\" : 25 - \"city\" : \"Tashkent\" So\u2018ng dictionaryni ekranga chiqaring. \u2705 2-topshiriq: Quyidagi dictionary berilgan: person = {\"name\": \"Ali\", \"age\": 30, \"job\": \"Engineer\"} Undagi \"age\" qiymatini 31 ga yangilang va dictionaryni chop eting. \u2705 3-topshiriq: Yuqoridagi person dictionarydan \"job\" elementini del yordamida o\u2018chiring. Keyin dictionaryni ekranga chiqarib ko\u2018ring. \u2705 4-topshiriq: Quyidagi dictionarydan .pop() metodi yordamida \"model\" kalitli elementni olib tashlang: car = {\"brand\": \"BMW\", \"model\": \"X5\", \"year\": 2020} O\u2018chirilgan qiymatni va yangilangan dictionaryni ekranga chiqaring. \u2705 5-topshiriq: Bo\u2018sh dictionary yarating va setdefault() yordamida quyidagi elementlarni qo\u2018shing: - \"username\" : \"coder123\" - \"email\" : \"coder@example.com\" Agar \"email\" mavjud bo\u2018lsa, uni yangilamasin. \u2705 6-topshiriq: Quyidagi dictionarydan .popitem() yordamida oxirgi elementni o\u2018chirib tashlang: movie = {\"title\": \"Inception\", \"director\": \"Nolan\", \"year\": 2010} O\u2018chirilgan element va yangilangan dictionaryni chop eting. \u2705 7-topshiriq: Quyidagi dictionary berilgan: student = {\"name\": \"Ziyoda\", \"course\": \"Python\", \"age\": 21} update() yordamida quyidagicha o\u2018zgartiring: - \"course\" : \"Django\" - \"is_active\" : True So\u2018ng natijani chop eting. \u2705 8-topshiriq: Quyidagi dictionarydan get() yordamida \"email\" va \"phone\" qiymatlarini ajrating: user = {\"username\": \"umiddev\", \"email\": \"umid@example.com\"} Agar \"phone\" mavjud bo\u2018lmasa, \"No number\" qiymatini qaytaring. \u2705 9-topshiriq: Quyidagi dictionaryda keys() , values() , items() metodlaridan foydalanib ularni alohida chop eting: laptop = {\"brand\": \"Lenovo\", \"ram\": \"16GB\", \"ssd\": \"512GB\"} \u2705 10-topshiriq: Quyidagi dictionary berilgan: book = {\"title\": \"Python 101\", \"author\": \"Alex\", \"pages\": 300} Agar \"pages\" kaliti mavjud bo\u2018lsa \u2014 yangilang, mavjud bo\u2018lmasa \u2014 250 qiymatini qo\u2018shing. \u2705 11-topshiriq: Quyidagi dictionaryda \"price\" mavjudligini tekshirib ko\u2018ring va mavjud bo\u2018lsa \u2014 del yordamida o\u2018chirib tashlang: product = {\"name\": \"Mouse\", \"brand\": \"Logitech\", \"price\": 150000} \u2705 12-topshiriq: Quyidagi ikkita dictionaryni update() yordamida birlashtiring: a = {\"a\": 1, \"b\": 2} b = {\"b\": 3, \"c\": 4} Natijada a dictionaryni yangilang va chop eting. \u2705 13-topshiriq: Quyidagi dictionaryga \"skills\" degan yangi kalit qo\u2018shing va qiymat sifatida [\"Python\", \"SQL\"] ro\u2018yxatini bering. \u2705 14-topshiriq: Quyidagi dictionaryda \"status\" kaliti mavjud emas. setdefault() yordamida \"active\" qiymatini qo\u2018shing: account = {\"username\": \"admin\"} \u2705 15-topshiriq: Quyidagi dictionarydagi barcha kalit va qiymatlarni alohida ro\u2018yxatlarga ajrating: info = {\"x\": 10, \"y\": 20, \"z\": 30} Kalitlar keys_list nomli ro\u2018yxatga, qiymatlar esa values_list nomli ro\u2018yxatga saqlansin.","title":"Dictionaries"},{"location":"python/dictionaries/#7-dars-dictionary","text":"","title":"\ud83e\udde9 7-DARS DICTIONARY"},{"location":"python/dictionaries/#dictionary-nima","text":"\ud83d\udccc Python dasturlash tilida dictionary \u2014 bu kalit-qiymat (key-value) juftliklarini saqlovchi ma\u2019lumotlar turidir. Har bir kalit yagona bo\u2018ladi va unga mos qiymat bo\u2018ladi. Dictionary ma\u2019lumotlar {} qavslar ichida yoziladi va har bir kalit bilan qiymat : bilan ajratiladi. Bu ma'lumot turi ma\u2019lumotlarni tartibli saqlash, oson topish va boshqarish uchun ishlatiladi.","title":"\u2705 DICTIONARY NIMA?"},{"location":"python/dictionaries/#dictionary-yaratish","text":"","title":"\u2705 DICTIONARY YARATISH"},{"location":"python/dictionaries/#bosh-dictionary-yaratish","text":"# Bo'sh dictionary yaratish user_info = {}","title":"\u2747\ufe0f BO'SH DICTIONARY YARATISH"},{"location":"python/dictionaries/#elementlar-bilan-dictionary-yaratish","text":"# Kalit-qiymatlar bilan dictionary yaratish user_info = { 'name': 'Alice', # Foydalanuvchining ismi 'age': 30, # Foydalanuvchining yoshi 'city': 'New York' # Foydalanuvchining shahri }","title":"\u2747\ufe0f E'LEMENTLAR BILAN DICTIONARY YARATISH"},{"location":"python/dictionaries/#dictionaryga-element-qoshish","text":"\ud83d\udccc Dictionaryga e'lement qo'shish uchun o'zgaruvchi nomidan kn [] qavs ochib ichiga keyni beramiz, undan keyin qo'shmoqchi bo'lgan value yani qiymatni beramiz. # Bo'sh dictionary yaratilyapti student_info = {} # Dictionary ga yangi kalit-qiymat juftligi qo\u2018shilmoqda: ism student_info[\"name\"] = \"Umid\" # Dictionary ga yangi kalit-qiymat juftligi qo\u2018shilmoqda: yosh student_info[\"age\"] = 20 # Dictionary ga yangi kalit-qiymat juftligi qo\u2018shilmoqda: kurs student_info[\"course\"] = \"Python Programming\" # Dictionary ga yangi kalit-qiymat juftligi qo\u2018shilmoqda: talabalik holati student_info[\"is_student\"] = True # Natijani ekranga chiqarish print(student_info)","title":"\u2705 DICTIONARYGA E'LEMENT QO'SHISH"},{"location":"python/dictionaries/#elementlarni-yangilash","text":"# Talaba haqida ma'lumotlarni saqlovchi dictionary yaratilmoqda student_profile = { \"full_name\": \"Azizbek Tursunov\", \"age\": 19, \"faculty\": \"Computer Science\", \"is_active\": True } # \"age\" kalitiga yangi yosh qiymati berilmoqda (19 dan 20 ga yangilanmoqda) student_profile[\"age\"] = 20 # \"faculty\" kalitidagi qiymat o\u2018zgartirilmoqda (Computer Science dan Data Science ga) student_profile[\"faculty\"] = \"Data Science\" # \"is_active\" kalitidagi qiymat yangilanmoqda (True dan False ga) student_profile[\"is_active\"] = False # Natija ekranga chiqarilmoqda print(student_profile)","title":"\u2705 E'LEMENTLARNI YANGILASH"},{"location":"python/dictionaries/#element-ochirish","text":"","title":"\u2705 E'LEMENT O'CHIRISH"},{"location":"python/dictionaries/#del","text":"\ud83d\udccc Lug'at ichidagi e'lementlarni o'chirish uchun del funksiyasidan foydalanamiz. # Kitob haqida ma'lumotlar saqlanayotgan dictionary yaratilmoqda book_info = { \"title\": \"Python Basics\", \"author\": \"John Smith\", \"year\": 2021, \"price\": 150000 } # \"price\" kalitidagi element dictionary dan o\u2018chirilmoqda del book_info[\"price\"] # Natija ekranga chiqarilmoqda print(book_info)","title":"\u2747\ufe0f DEL"},{"location":"python/dictionaries/#pop","text":"\ud83d\udccc Lug'atdagi e'lementlarni o'chirish uchun .pop() metodidan ham foydalansak bo'ladi. # Telefon ma'lumotlari saqlanayotgan dictionary yaratilmoqda phone_details = { \"brand\": \"Samsung\", \"model\": \"Galaxy S21\", \"storage\": \"128GB\", \"price\": 900 } # \"storage\" kalitli element .pop() orqali o\u2018chirilmoqda va qiymati o'zgaruvchiga saqlanmoqda removed_value = phone_details.pop(\"storage\") # O\u2018chirilgan qiymat ekranga chiqarilmoqda print(\"Removed:\", removed_value) # Yangilangan dictionary ekranga chiqarilmoqda print(phone_details)","title":"\u2747\ufe0f POP"},{"location":"python/dictionaries/#elementlarga-murojat-qilish","text":"","title":"\u2705 E'LEMENTLARGA MUROJAT QILISH"},{"location":"python/dictionaries/#keys","text":"\ud83d\udccc Kalitlarni olish. # Foydalanuvchi haqida ma'lumot saqlanmoqda user_info = { \"name\": \"Alice\", \"city\": \"New York\" } # Barcha kalitlar (key) alohida olinmoqda keys = user_info.keys() # Kalitlar ekranga chiqarilmoqda print(keys)","title":"\u2747\ufe0f KEYS"},{"location":"python/dictionaries/#values","text":"\ud83d\udccc Qiymatlarni olish. # Foydalanuvchi haqida ma'lumot saqlanmoqda user_info = { \"name\": \"Alice\", \"city\": \"New York\" } # Barcha qiymatlar (value) alohida olinmoqda values = user_info.values() # Qiymatlar ekranga chiqarilmoqda print(values)","title":"\u2747\ufe0f VALUES"},{"location":"python/dictionaries/#items","text":"\ud83d\udccc Kalit-qiymat juftliklarini olish: # Foydalanuvchi haqida ma'lumot saqlanmoqda user_info = { \"name\": \"Alice\", \"city\": \"New York\" } # Barcha kalit-qiymat juftliklari alohida olinmoqda items = user_info.items() # Juftliklar ekranga chiqarilmoqda print(items)","title":"\u2747\ufe0f ITEMS"},{"location":"python/dictionaries/#foydali-metodlar","text":"","title":"\u2705 FOYDALI METODLAR"},{"location":"python/dictionaries/#get","text":"\ud83d\udccc Kalit bo'yicha qiymatni oladi. Kalit mavjud bo'lmasa, None qaytaradi. # Avtomobil haqida ma'lumotlar saqlanmoqda car_info = { \"brand\": \"Chevrolet\", \"model\": \"Malibu\", \"year\": 2022 } # \"model\" kaliti orqali qiymat olinmoqda, agar mavjud bo\u2018lsa \u2014 shu qiymat qaytadi car_model = car_info.get(\"model\", \"Not Found\") print(\"Model:\", car_model) # Natija: Malibu # \"color\" degan kalit mavjud emas, shuning uchun \"Not Found\" qiymati qaytadi car_color = car_info.get(\"color\", \"Not Found\") print(\"Color:\", car_color) # Natija: Not Found","title":"\u2747\ufe0f GET"},{"location":"python/dictionaries/#update","text":"\ud83d\udccc Dictionaryga yangi ma'lumot qo'shish yoki yangilash uchun ishlatiladi. # Talaba haqida dastlabki ma'lumotlar saqlanmoqda student_info = { \"name\": \"Diyor\", \"age\": 18, \"course\": \"Python\" } # update() metodi yordamida yangi ma'lumotlar qo\u2018shilmoqda yoki mavjudlari yangilanmoqda student_info.update({ \"age\": 19, # age mavjud edi \u2014 yangilanmoqda \"course\": \"Django\", # course mavjud edi \u2014 yangilanmoqda \"is_active\": True # yangi kalit \u2014 qo\u2018shilmoqda }) # Natijani ekranga chiqarish print(student_info)","title":"\u2747\ufe0f UPDATE"},{"location":"python/dictionaries/#popintem","text":"\ud83d\udccc Dictionarydan oxirgi qo\u2018shilgan kalit-qiymat juftligini olib tashlaydi va o\u2018sha juftlikni qaytaradi. # Mehmon haqida ma'lumotlar saqlanmoqda guest_info = { \"name\": \"Javlon\", \"room\": 305, \"nights\": 3 } # Oxirgi qo\u2018shilgan kalit-qiymat juftligi dictionary dan o\u2018chirilmoqda removed_item = guest_info.popitem() # O\u2018chirilgan juftlik (tuple shaklida) ekranga chiqarilmoqda print(\"Removed:\", removed_item) # Yangilangan dictionary ekranga chiqarilmoqda print(\"Updated:\", guest_info)","title":"\u2747\ufe0f POPINTEM"},{"location":"python/dictionaries/#setdefault","text":"\ud83d\udccc Kalit mavjud bo'lmasa, qiymat qo'shadi va qaytaradi. # Foydalanuvchi haqida boshlang\u2018ich ma\u2019lumotlar user_info = { \"username\": \"umiddev\", \"email\": \"umid@example.com\" } # \"email\" kaliti mavjud bo\u2018lgani uchun mavjud qiymatni qaytaradi email = user_info.setdefault(\"email\", \"default@example.com\") print(\"Email:\", email) # \"phone\" kaliti yo\u2018q edi, shuning uchun u yaratilib, berilgan qiymat qo\u2018shiladi phone = user_info.setdefault(\"phone\", \"+998901234567\") print(\"Phone:\", phone) # Yangilangan dictionary ekranga chiqarilmoqda print(\"Updated user_info:\", user_info)","title":"\u2747\ufe0f SETDEFAULT"},{"location":"python/dictionaries/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/dictionaries/#1-topshiriq","text":"Bo\u2018sh dictionary yarating va unga quyidagi kalit-qiymatlarni qo\u2018shing: - \"name\" : \"John\" - \"age\" : 25 - \"city\" : \"Tashkent\" So\u2018ng dictionaryni ekranga chiqaring.","title":"\u2705 1-topshiriq:"},{"location":"python/dictionaries/#2-topshiriq","text":"Quyidagi dictionary berilgan: person = {\"name\": \"Ali\", \"age\": 30, \"job\": \"Engineer\"} Undagi \"age\" qiymatini 31 ga yangilang va dictionaryni chop eting.","title":"\u2705 2-topshiriq:"},{"location":"python/dictionaries/#3-topshiriq","text":"Yuqoridagi person dictionarydan \"job\" elementini del yordamida o\u2018chiring. Keyin dictionaryni ekranga chiqarib ko\u2018ring.","title":"\u2705 3-topshiriq:"},{"location":"python/dictionaries/#4-topshiriq","text":"Quyidagi dictionarydan .pop() metodi yordamida \"model\" kalitli elementni olib tashlang: car = {\"brand\": \"BMW\", \"model\": \"X5\", \"year\": 2020} O\u2018chirilgan qiymatni va yangilangan dictionaryni ekranga chiqaring.","title":"\u2705 4-topshiriq:"},{"location":"python/dictionaries/#5-topshiriq","text":"Bo\u2018sh dictionary yarating va setdefault() yordamida quyidagi elementlarni qo\u2018shing: - \"username\" : \"coder123\" - \"email\" : \"coder@example.com\" Agar \"email\" mavjud bo\u2018lsa, uni yangilamasin.","title":"\u2705 5-topshiriq:"},{"location":"python/dictionaries/#6-topshiriq","text":"Quyidagi dictionarydan .popitem() yordamida oxirgi elementni o\u2018chirib tashlang: movie = {\"title\": \"Inception\", \"director\": \"Nolan\", \"year\": 2010} O\u2018chirilgan element va yangilangan dictionaryni chop eting.","title":"\u2705 6-topshiriq:"},{"location":"python/dictionaries/#7-topshiriq","text":"Quyidagi dictionary berilgan: student = {\"name\": \"Ziyoda\", \"course\": \"Python\", \"age\": 21} update() yordamida quyidagicha o\u2018zgartiring: - \"course\" : \"Django\" - \"is_active\" : True So\u2018ng natijani chop eting.","title":"\u2705 7-topshiriq:"},{"location":"python/dictionaries/#8-topshiriq","text":"Quyidagi dictionarydan get() yordamida \"email\" va \"phone\" qiymatlarini ajrating: user = {\"username\": \"umiddev\", \"email\": \"umid@example.com\"} Agar \"phone\" mavjud bo\u2018lmasa, \"No number\" qiymatini qaytaring.","title":"\u2705 8-topshiriq:"},{"location":"python/dictionaries/#9-topshiriq","text":"Quyidagi dictionaryda keys() , values() , items() metodlaridan foydalanib ularni alohida chop eting: laptop = {\"brand\": \"Lenovo\", \"ram\": \"16GB\", \"ssd\": \"512GB\"}","title":"\u2705 9-topshiriq:"},{"location":"python/dictionaries/#10-topshiriq","text":"Quyidagi dictionary berilgan: book = {\"title\": \"Python 101\", \"author\": \"Alex\", \"pages\": 300} Agar \"pages\" kaliti mavjud bo\u2018lsa \u2014 yangilang, mavjud bo\u2018lmasa \u2014 250 qiymatini qo\u2018shing.","title":"\u2705 10-topshiriq:"},{"location":"python/dictionaries/#11-topshiriq","text":"Quyidagi dictionaryda \"price\" mavjudligini tekshirib ko\u2018ring va mavjud bo\u2018lsa \u2014 del yordamida o\u2018chirib tashlang: product = {\"name\": \"Mouse\", \"brand\": \"Logitech\", \"price\": 150000}","title":"\u2705 11-topshiriq:"},{"location":"python/dictionaries/#12-topshiriq","text":"Quyidagi ikkita dictionaryni update() yordamida birlashtiring: a = {\"a\": 1, \"b\": 2} b = {\"b\": 3, \"c\": 4} Natijada a dictionaryni yangilang va chop eting.","title":"\u2705 12-topshiriq:"},{"location":"python/dictionaries/#13-topshiriq","text":"Quyidagi dictionaryga \"skills\" degan yangi kalit qo\u2018shing va qiymat sifatida [\"Python\", \"SQL\"] ro\u2018yxatini bering.","title":"\u2705 13-topshiriq:"},{"location":"python/dictionaries/#14-topshiriq","text":"Quyidagi dictionaryda \"status\" kaliti mavjud emas. setdefault() yordamida \"active\" qiymatini qo\u2018shing: account = {\"username\": \"admin\"}","title":"\u2705 14-topshiriq:"},{"location":"python/dictionaries/#15-topshiriq","text":"Quyidagi dictionarydagi barcha kalit va qiymatlarni alohida ro\u2018yxatlarga ajrating: info = {\"x\": 10, \"y\": 20, \"z\": 30} Kalitlar keys_list nomli ro\u2018yxatga, qiymatlar esa values_list nomli ro\u2018yxatga saqlansin.","title":"\u2705 15-topshiriq:"},{"location":"python/exception-handling/","text":"\ud83e\udde9 12-DARS EXCEPTION HANDLING [!NOTE] Eslatma: Pythonda istisno holatlarni boshqarish dasturda yuzaga keladigan xatoliklarni to'g'ri boshqarish va dasturimizni barqaror ishlashini ta'minlash uchun muhim hisoblanadi. Bu try , except , else , va finally bloklari orqali amalga oshiriladi. \u2705 EXCEPTION HANDLING HAQIDA UMUMIY TUSHUNCHA \ud83d\udccc Dastur bajarilishi davomida foydalanuvchidan noto\u2018g\u2018ri ma'lumot kiritilishi, fayl topilmasligi, nolga bo\u2018lish holati yoki boshqa xatoliklar yuz berishi mumkin. Exception Handling orqali bu xatoliklar dastur to\u2018xtab qolmasdan, foydalanuvchiga tushunarli tarzda xabar berib, dasturni davom ettirish imkonini beradi. \u2705 EXCEPTION HANDLING SINTAKSISI try: # Xato chiqishi mumkin bo'lgan kod except XatoNomi: # Xato yuz bersa ishlaydigan kod else: # Xato chiqmasa ishlaydigan kod finally: # Har doim ishlaydigan kod \u2705 try, except \ud83d\udccc try blokida xatolik chiqishi mumkin bo\u2018lgan kod yoziladi. except blokida aniq xatolik turi bilan uni ushlab qolamiz. try: # Foydalanuvchidan son so\u2018raymiz va butun songa o\u2018girib olamiz son = int(input(\"Biror son kiriting: \")) # 10 ni kiritilgan songa bo\u2018lamiz natija = 10 / son # Hisoblangan natijani chiqaramiz print(f\"Natija: {natija}\") except ZeroDivisionError: # Agar son 0 bo\u2018lsa, bo\u2018lish amali xatoga olib keladi va bu xabar chiqadi print(\"Xatolik: Nolga bo'lish mumkin emas!\") except ValueError: # Agar son emas, noto\u2018g\u2018ri qiymat kiritsa, bu xato yuz beradi va bu xabar chiqadi print(\"Xatolik: Iltimos, butun son kiriting!\") \u2705 else \ud83d\udccc Agar try blokida xatolik yuz bermasa, else bloki ishga tushadi. Bu blokda xatoliklar bo'lmasa bajarilishi kerak bo'lgan kodlar yoziladi. try: # Foydalanuvchidan son so\u2018raymiz va butun songa o\u2018girib olamiz son = int(input(\"Biror son kiriting: \")) # 10 ni kiritilgan songa bo\u2018lamiz natija = 10 / son except ZeroDivisionError: # Agar son 0 bo\u2018lsa, bu xatolik chiqadi print(\"Xatolik: Nolga bo'lish mumkin emas!\") except ValueError: # Agar son emas, noto\u2018g\u2018ri qiymat kiritsa, bu xatolik chiqadi print(\"Xatolik: Iltimos, butun son kiriting!\") else: # Agar xatolik bo\u2018lmasa, natijani chiqaramiz print(f\"Natija: {natija}\") \u2705 finally \ud83d\udccc finally bloki har qanday holatda ham, xatolik yuz bergan yoki bermagan bo'lsa ham, bajariladi. Bu blok, masalan, resurslarni tozalash yoki fayllarni yopish uchun ishlatilishi mumkin. try: # Foydalanuvchidan son so\u2018raymiz va butun songa o\u2018girib olamiz son = int(input(\"Biror son kiriting: \")) # 10 ni kiritilgan songa bo\u2018lamiz natija = 10 / son except Exception as e: # Har qanday xatolik yuz bersa, xato haqida ma\u2019lumot chiqaramiz print(f\"Xatolik: {e}\") finally: # Bu blok har doim, xato bo\u2018lsa ham, bo\u2018lmasa ham ishlaydi print(\"Dastur yakunlandi.\") \u2705 XATONI NOMI BILAN CHIQARISH \ud83d\udccc Ba'zi hollarda, sodir bo'lgan xatoni dasturiy tilda yozib chiqish kerak bo'lishi mumkin. Bunda as kalit so'zi orqali xato ob'ektiga nom berish mumkin: try: # \"malumot.txt\" faylini ochamiz file = open(\"malumot.txt\") # Fayldagi barcha ma'lumotlarni o\u2018qiymiz data = file.read() # O\u2018qilgan ma'lumotlarni ekranga chiqaramiz print(data) except FileNotFoundError as xato: # Agar fayl mavjud bo\u2018lmasa, xato xabari chiqariladi print(f\"Xatolik: {xato}\") \u2705 BIR NECHTA XATOLARNI BITTA except DA USHLASH \ud83d\udccc Bir nechta xatolarni bitta except blokida ushlash mumkin. try: # Foydalanuvchidan son so\u2018raymiz va uni butun songa o\u2018giramiz x = int(input(\"Son kiriting: \")) # 10 ni kiritilgan songa bo\u2018lamiz y = 10 / x # Agar foydalanuvchi son o\u2018rniga matn kiritsa (ValueError), # yoki 0 kiritsa (ZeroDivisionError), bu except bloki ishga tushadi except (ValueError, ZeroDivisionError) as x: # Xatolik haqida foydalanuvchiga xabar beramiz print(f\"Xatolik: {x}\") \u2705 MAXSUS XATOLIK YARATISH (raise) [!NOTE] Pythonda raise \u2014 bu sun'iy (ya'ni o\u2018zimiz xohlagan paytda) xatolik chaqirish uchun ishlatiladi. Ayniqsa, foydalanuvchi noto\u2018g\u2018ri ma'lumot kiritsa, unga aniq xatolik berish uchun foydalidir. # Manfiy son kiritilsa xatolik (ValueError) chiqaradigan funksiya def tekshir(son): # Agar son manfiy bo\u2018lsa, xatolik chiqaramiz if son < 0: raise ValueError(\"Manfiy son kiritish mumkin emas!\") # Aks holda, sonni qaytaramiz return son try: # Funksiyani manfiy son bilan chaqiramiz (bu xatoga olib keladi) tekshir(-5) except ValueError as x: # Agar ValueError yuz bersa, xatolik haqida xabar chiqaramiz print(f\"Xatolik: {x}\") \u2705 AMALIYOT \u2705 1-topshiriq: Foydalanuvchidan ikkita son oling va birinchisini ikkinchisiga bo\u2018ling. Nolga bo\u2018lishdan himoyalangan holda exception handling bilan dastur tuzing. \u2705 2-topshiriq: Foydalanuvchidan matn ko\u2018rinishida qiymat oling va uni int yoki float ga aylantiring. Agar foydalanuvchi harf kiritsa, xatolik chiqsin. \u2705 3-topshiriq: Foydalanuvchi ikkita son va bitta operator kiritsin ( + , - , * , / ). Operator noto\u2018g\u2018ri bo\u2018lsa, xatolik chiqsin. \u2705 4-topshiriq: Foydalanuvchi son kiritadi. Agar son manfiy bo\u2018lsa, raise orqali ValueError chiqarilsin: \"Manfiy son kiritish mumkin emas!\" \u2705 5-topshiriq: Berilgan ro\u2018yxatdan ( list ) indeks orqali element oling. Agar noto\u2018g\u2018ri indeks kiritilsa, IndexError chiqsin. \u2705 6-topshiriq: Foydalanuvchi lug\u2018atdan key bo\u2018yicha ma\u2019lumot olishga harakat qiladi. Agar key mavjud bo\u2018lmasa, KeyError chiqsin. \u2705 7-topshiriq: Foydalanuvchi parol kiritadi. Agar parol bo\u2018sh bo\u2018lsa, raise ValueError bilan xatolik chiqarilsin. \u2705 8-topshiriq: Foydalanuvchi son kiritadi va uni int ga aylantirib chiqarasiz. finally blokida \"Dastur tugadi\" degan matn chiqsin. \u2705 9-topshiriq: Foydalanuvchidan son kiriting va 10 ni ushbu songa bo\u2018ling. ValueError yoki ZeroDivisionError yuz bersa, bitta except bilan ushlang. \u2705 10-topshiriq: Funksiya yarating: son kiritsa va u 100 dan katta bo\u2018lsa, raise ValueError(\"100 dan katta son kiritish mumkin emas\") chiqsin. \u2705 11-topshiriq: Foydalanuvchi haqiqiy son kiritsin. Agar son butun bo\u2018lsa, raise ValueError(\"Faqat haqiqiy son kiriting\") chiqsin. \u2705 12-topshiriq: Fayl ochishga harakat qiling. Fayl mavjud bo\u2018lmasa, xatolik xabarini chiqaring (FileNotFoundError). \u2705 13-topshiriq: Biror list yarating va foydalanuvchidan indeks so\u2018rang. Indeks noto\u2018g\u2018ri bo\u2018lsa, foydalanuvchiga tushunarli xabar chiqaring. \u2705 14-topshiriq: Foydalanuvchidan yoshini so\u2018raydigan funksiya yozing. Agar foydalanuvchi manfiy yoki 120 dan katta yosh kiritsa, raise ValueError chiqsin. \u2705 15-topshiriq: Foydalanuvchidan ikkita raqamli string so\u2018rang va ularni son sifatida qo\u2018shing. Agar harflar kiritsa, xatolikdan foydalanuvchiga ogohlantirish chiqaring.","title":"Exception Handling"},{"location":"python/exception-handling/#12-dars-exception-handling","text":"[!NOTE] Eslatma: Pythonda istisno holatlarni boshqarish dasturda yuzaga keladigan xatoliklarni to'g'ri boshqarish va dasturimizni barqaror ishlashini ta'minlash uchun muhim hisoblanadi. Bu try , except , else , va finally bloklari orqali amalga oshiriladi.","title":"\ud83e\udde9 12-DARS EXCEPTION HANDLING"},{"location":"python/exception-handling/#exception-handling-haqida-umumiy-tushuncha","text":"\ud83d\udccc Dastur bajarilishi davomida foydalanuvchidan noto\u2018g\u2018ri ma'lumot kiritilishi, fayl topilmasligi, nolga bo\u2018lish holati yoki boshqa xatoliklar yuz berishi mumkin. Exception Handling orqali bu xatoliklar dastur to\u2018xtab qolmasdan, foydalanuvchiga tushunarli tarzda xabar berib, dasturni davom ettirish imkonini beradi.","title":"\u2705 EXCEPTION HANDLING HAQIDA UMUMIY TUSHUNCHA"},{"location":"python/exception-handling/#exception-handling-sintaksisi","text":"try: # Xato chiqishi mumkin bo'lgan kod except XatoNomi: # Xato yuz bersa ishlaydigan kod else: # Xato chiqmasa ishlaydigan kod finally: # Har doim ishlaydigan kod","title":"\u2705 EXCEPTION HANDLING SINTAKSISI"},{"location":"python/exception-handling/#try-except","text":"\ud83d\udccc try blokida xatolik chiqishi mumkin bo\u2018lgan kod yoziladi. except blokida aniq xatolik turi bilan uni ushlab qolamiz. try: # Foydalanuvchidan son so\u2018raymiz va butun songa o\u2018girib olamiz son = int(input(\"Biror son kiriting: \")) # 10 ni kiritilgan songa bo\u2018lamiz natija = 10 / son # Hisoblangan natijani chiqaramiz print(f\"Natija: {natija}\") except ZeroDivisionError: # Agar son 0 bo\u2018lsa, bo\u2018lish amali xatoga olib keladi va bu xabar chiqadi print(\"Xatolik: Nolga bo'lish mumkin emas!\") except ValueError: # Agar son emas, noto\u2018g\u2018ri qiymat kiritsa, bu xato yuz beradi va bu xabar chiqadi print(\"Xatolik: Iltimos, butun son kiriting!\")","title":"\u2705 try, except"},{"location":"python/exception-handling/#else","text":"\ud83d\udccc Agar try blokida xatolik yuz bermasa, else bloki ishga tushadi. Bu blokda xatoliklar bo'lmasa bajarilishi kerak bo'lgan kodlar yoziladi. try: # Foydalanuvchidan son so\u2018raymiz va butun songa o\u2018girib olamiz son = int(input(\"Biror son kiriting: \")) # 10 ni kiritilgan songa bo\u2018lamiz natija = 10 / son except ZeroDivisionError: # Agar son 0 bo\u2018lsa, bu xatolik chiqadi print(\"Xatolik: Nolga bo'lish mumkin emas!\") except ValueError: # Agar son emas, noto\u2018g\u2018ri qiymat kiritsa, bu xatolik chiqadi print(\"Xatolik: Iltimos, butun son kiriting!\") else: # Agar xatolik bo\u2018lmasa, natijani chiqaramiz print(f\"Natija: {natija}\")","title":"\u2705 else"},{"location":"python/exception-handling/#finally","text":"\ud83d\udccc finally bloki har qanday holatda ham, xatolik yuz bergan yoki bermagan bo'lsa ham, bajariladi. Bu blok, masalan, resurslarni tozalash yoki fayllarni yopish uchun ishlatilishi mumkin. try: # Foydalanuvchidan son so\u2018raymiz va butun songa o\u2018girib olamiz son = int(input(\"Biror son kiriting: \")) # 10 ni kiritilgan songa bo\u2018lamiz natija = 10 / son except Exception as e: # Har qanday xatolik yuz bersa, xato haqida ma\u2019lumot chiqaramiz print(f\"Xatolik: {e}\") finally: # Bu blok har doim, xato bo\u2018lsa ham, bo\u2018lmasa ham ishlaydi print(\"Dastur yakunlandi.\")","title":"\u2705 finally"},{"location":"python/exception-handling/#xatoni-nomi-bilan-chiqarish","text":"\ud83d\udccc Ba'zi hollarda, sodir bo'lgan xatoni dasturiy tilda yozib chiqish kerak bo'lishi mumkin. Bunda as kalit so'zi orqali xato ob'ektiga nom berish mumkin: try: # \"malumot.txt\" faylini ochamiz file = open(\"malumot.txt\") # Fayldagi barcha ma'lumotlarni o\u2018qiymiz data = file.read() # O\u2018qilgan ma'lumotlarni ekranga chiqaramiz print(data) except FileNotFoundError as xato: # Agar fayl mavjud bo\u2018lmasa, xato xabari chiqariladi print(f\"Xatolik: {xato}\")","title":"\u2705 XATONI NOMI BILAN CHIQARISH"},{"location":"python/exception-handling/#bir-nechta-xatolarni-bitta-except-da-ushlash","text":"\ud83d\udccc Bir nechta xatolarni bitta except blokida ushlash mumkin. try: # Foydalanuvchidan son so\u2018raymiz va uni butun songa o\u2018giramiz x = int(input(\"Son kiriting: \")) # 10 ni kiritilgan songa bo\u2018lamiz y = 10 / x # Agar foydalanuvchi son o\u2018rniga matn kiritsa (ValueError), # yoki 0 kiritsa (ZeroDivisionError), bu except bloki ishga tushadi except (ValueError, ZeroDivisionError) as x: # Xatolik haqida foydalanuvchiga xabar beramiz print(f\"Xatolik: {x}\")","title":"\u2705 BIR NECHTA XATOLARNI BITTA except DA USHLASH"},{"location":"python/exception-handling/#maxsus-xatolik-yaratish-raise","text":"[!NOTE] Pythonda raise \u2014 bu sun'iy (ya'ni o\u2018zimiz xohlagan paytda) xatolik chaqirish uchun ishlatiladi. Ayniqsa, foydalanuvchi noto\u2018g\u2018ri ma'lumot kiritsa, unga aniq xatolik berish uchun foydalidir. # Manfiy son kiritilsa xatolik (ValueError) chiqaradigan funksiya def tekshir(son): # Agar son manfiy bo\u2018lsa, xatolik chiqaramiz if son < 0: raise ValueError(\"Manfiy son kiritish mumkin emas!\") # Aks holda, sonni qaytaramiz return son try: # Funksiyani manfiy son bilan chaqiramiz (bu xatoga olib keladi) tekshir(-5) except ValueError as x: # Agar ValueError yuz bersa, xatolik haqida xabar chiqaramiz print(f\"Xatolik: {x}\")","title":"\u2705 MAXSUS XATOLIK YARATISH (raise)"},{"location":"python/exception-handling/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/exception-handling/#1-topshiriq","text":"Foydalanuvchidan ikkita son oling va birinchisini ikkinchisiga bo\u2018ling. Nolga bo\u2018lishdan himoyalangan holda exception handling bilan dastur tuzing.","title":"\u2705 1-topshiriq:"},{"location":"python/exception-handling/#2-topshiriq","text":"Foydalanuvchidan matn ko\u2018rinishida qiymat oling va uni int yoki float ga aylantiring. Agar foydalanuvchi harf kiritsa, xatolik chiqsin.","title":"\u2705 2-topshiriq:"},{"location":"python/exception-handling/#3-topshiriq","text":"Foydalanuvchi ikkita son va bitta operator kiritsin ( + , - , * , / ). Operator noto\u2018g\u2018ri bo\u2018lsa, xatolik chiqsin.","title":"\u2705 3-topshiriq:"},{"location":"python/exception-handling/#4-topshiriq","text":"Foydalanuvchi son kiritadi. Agar son manfiy bo\u2018lsa, raise orqali ValueError chiqarilsin: \"Manfiy son kiritish mumkin emas!\"","title":"\u2705 4-topshiriq:"},{"location":"python/exception-handling/#5-topshiriq","text":"Berilgan ro\u2018yxatdan ( list ) indeks orqali element oling. Agar noto\u2018g\u2018ri indeks kiritilsa, IndexError chiqsin.","title":"\u2705 5-topshiriq:"},{"location":"python/exception-handling/#6-topshiriq","text":"Foydalanuvchi lug\u2018atdan key bo\u2018yicha ma\u2019lumot olishga harakat qiladi. Agar key mavjud bo\u2018lmasa, KeyError chiqsin.","title":"\u2705 6-topshiriq:"},{"location":"python/exception-handling/#7-topshiriq","text":"Foydalanuvchi parol kiritadi. Agar parol bo\u2018sh bo\u2018lsa, raise ValueError bilan xatolik chiqarilsin.","title":"\u2705 7-topshiriq:"},{"location":"python/exception-handling/#8-topshiriq","text":"Foydalanuvchi son kiritadi va uni int ga aylantirib chiqarasiz. finally blokida \"Dastur tugadi\" degan matn chiqsin.","title":"\u2705 8-topshiriq:"},{"location":"python/exception-handling/#9-topshiriq","text":"Foydalanuvchidan son kiriting va 10 ni ushbu songa bo\u2018ling. ValueError yoki ZeroDivisionError yuz bersa, bitta except bilan ushlang.","title":"\u2705 9-topshiriq:"},{"location":"python/exception-handling/#10-topshiriq","text":"Funksiya yarating: son kiritsa va u 100 dan katta bo\u2018lsa, raise ValueError(\"100 dan katta son kiritish mumkin emas\") chiqsin.","title":"\u2705 10-topshiriq:"},{"location":"python/exception-handling/#11-topshiriq","text":"Foydalanuvchi haqiqiy son kiritsin. Agar son butun bo\u2018lsa, raise ValueError(\"Faqat haqiqiy son kiriting\") chiqsin.","title":"\u2705 11-topshiriq:"},{"location":"python/exception-handling/#12-topshiriq","text":"Fayl ochishga harakat qiling. Fayl mavjud bo\u2018lmasa, xatolik xabarini chiqaring (FileNotFoundError).","title":"\u2705 12-topshiriq:"},{"location":"python/exception-handling/#13-topshiriq","text":"Biror list yarating va foydalanuvchidan indeks so\u2018rang. Indeks noto\u2018g\u2018ri bo\u2018lsa, foydalanuvchiga tushunarli xabar chiqaring.","title":"\u2705 13-topshiriq:"},{"location":"python/exception-handling/#14-topshiriq","text":"Foydalanuvchidan yoshini so\u2018raydigan funksiya yozing. Agar foydalanuvchi manfiy yoki 120 dan katta yosh kiritsa, raise ValueError chiqsin.","title":"\u2705 14-topshiriq:"},{"location":"python/exception-handling/#15-topshiriq","text":"Foydalanuvchidan ikkita raqamli string so\u2018rang va ularni son sifatida qo\u2018shing. Agar harflar kiritsa, xatolikdan foydalanuvchiga ogohlantirish chiqaring.","title":"\u2705 15-topshiriq:"},{"location":"python/file-handling/","text":"\ud83e\udde9 14-DARS FILE HANDLING \ud83d\udccc Fayl \u2014 bu kompyuterda ma'lumotlar saqlanadigan obyekt. U matn, rasm, ovoz yoki dasturiy kod bo\u2018lishi mumkin. Biz dasturda aynan matnli fayllar bilan ko\u2018p ishlaymiz, masalan: .txt, .csv, .json fayllar. \u2753 FAYL NIMA UCHUN KERAK? \ud83d\udcdd Ma'lumotlarni saqlash \u2014 Dastur tugagandan keyin ham ma'lumot yo\u2018qolmasligi uchun. \ud83d\udd01 Qayta ishlash \u2014 Avval yozilgan ma'lumotlarni o\u2018qib, tahlil qilish yoki o\u2018zgartirish. \ud83d\udce4 Boshqa dasturlar bilan almashish \u2014 Fayllar orqali boshqa dasturlar bilan axborot almashiladi. \ud83d\udcda Katta hajmdagi ma'lumotlar \u2014 Ma'lumot bazasidan oldin oddiy fayllarda saqlanadi (masalan, .csv fayllar). \u2705 FAYLNI OCHISH \ud83d\udccc Faylni ochish uchun open() funksiyasidan foydalaniladi. Bu funksiya fayl nomini va rejimini qabul qiladi. open() funksiyasida ikkinchi parametr sifatida fayl rejimini ko'rsatishingiz mumkin: \u2705 FAYL REJIMLARI \ud83d\udccc r \u2013 Faylni o'qish uchun ochish. Fayl mavjud bo'lishi kerak. \ud83d\udccc w \u2013 Faylga yozish uchun ochish. Agar fayl mavjud bo'lmasa, yangi fayl yaratadi. Mavjud fayl bo'lsa, ma'lumotlarni o'chirib yuboradi. \ud83d\udccc a \u2013 Faylga qo'shish uchun ochish. Mavjud faylga yangi ma'lumot qo'shadi, agar fayl mavjud bo'lmasa, yangi fayl yaratadi. \ud83d\udccc x \u2013 Faylni faqat yangi fayl yaratish uchun ochadi. Agar fayl allaqachon mavjud bo'lsa, xato chiqaradi. # Faylni o'qish uchun ochish f = open(\"file.txt\", \"r\") # Faylga yozish uchun ochish f = open(\"file.txt\", \"w\") # Faylga qo'shish uchun ochish f = open(\"file.txt\", \"a\") # Fayl mavjud emasligini tekshirib, yaratish f = open(\"file.txt\", \"x\") \u2705 FAYLNI O'QISH \ud83d\udccc Fayl ichidagi ma'lumotlarni o'qish uchun bir necha usullar mavjud: - read() \u2013 Faylni to'liq o'qiydi. - readline() \u2013 Fayldan bir qatorni o'qiydi. - readlines() \u2013 Fayldagi barcha qatorlarni ro'yxat sifatida o'qiydi. f = open(\"file.txt\", \"r\") # Barcha ma'lumotni o'qish content = f.read() print(content) # Bir qatorni o'qish line = f.readline() print(line) # Barcha qatorlarni ro'yxatga o'qish lines = f.readlines() print(lines) f.close() \u2705 FAYLGA YOZISH \ud83d\udccc Faylga yozish uchun write() yoki writelines() metodlaridan foydalaniladi: - write() \u2013 Faylga matn yozadi. - writelines() \u2013 Ro'yxatdagi barcha qatorlarni faylga yozadi. # Faylga ma'lumot yozish # \"file.txt\" nomli faylni yozish (\"w\") rejimida ochyapti f = open(\"file.txt\", \"w\") # Faylga \"Hello, Python!\" matnini yozadi va yangi qatordan boshlaydi f.write(\"Hello, Python!\\n\") # Faylga ikkinchi qatorda matn yozadi f.write(\"This is a second line.\\n\") # Faylni yopadi, bu majburiy \u2014 ma'lumotlar saqlanadi va fayl yopiladi f.close() # Ro'yxatni faylga yozish # Yoziladigan har bir element yangi qatordan iborat bo\u2018lgan ro'yxat lines = [\"First line\\n\", \"Second line\\n\", \"Third line\\n\"] # \"file.txt\" nomli faylni yana yozish rejimida ochyapti (eski ma'lumot o\u2018chiriladi) f = open(\"file.txt\", \"w\") # Ro'yxatdagi barcha elementlarni faylga ketma-ket yozadi f.writelines(lines) # Faylni yopadi f.close() \u2705 FAYLNI YOPISH \ud83d\udccc Fayl bilan ish tugagandan so'ng, uni yopish kerak. Faylni yopish uchun close() metodidan foydalaniladi. f = open(\"file.txt\", \"r\") # Fayldan o'qish jarayoni f.close() # Faylni yopish [!NOTE] Yana bir usul \u2013 faylni with bloki yordamida ochish, bunda fayl avtomatik ravishda yopiladi: with open(\"file.txt\", \"r\") as f: content = f.read() print(content) # Bu usulda faylni yopish shart emas, fayl avtomatik ravishda yopiladi. \u2705 FAYLNI YOPMASA NIMA BO'LADI? \u2705 1. MA'LUMOTLAR FAYLGA YOZILMASLIGI MUMKIN (YOKI KECHIKIB YOZILISHI) \ud83d\udccc Python faylga yozayotgan paytda ma'lumotlarni dastlab xotira buferida saqlaydi. Faylni yopsangizgina bu ma'lumotlar diskka to\u2018liq yoziladi. # \"data.txt\" nomli faylni yozish (\"w\") rejimida ochadi (agar fayl bo'lmasa, yangi yaratadi) f = open(\"data.txt\", \"w\") # Faylga \"Bu matn faylga yoziladi.\" matnini yozadi f.write(\"Bu matn faylga yoziladi.\") # Faylni yopish yo\u2018q, shuning uchun yozilgan ma'lumot faylga saqlanmasligi yoki fayl ochiq qolishi mumkin # f.close() qatori bo\u2018lmasa, ma'lumotlar operatsion tizimning fayl keshida qolishi ehtimoli bor \u2705 2. FAYL BOSHQALAR UCHUN BAND BO\u2018LIB QOLADI \ud83d\udccc Agar siz faylni yopmasangiz, u operatsion tizim tomonidan \"ochiq\" deb hisoblanadi va boshqa dasturlar (yoki boshqa kod qismlari) uni o\u2018qiy olmaydi yoki tahrirlay olmaydi. \u2705 3. XOTIRA RESURSLARI ORTIQCHA BAND BO\u2018LADI \ud83d\udccc Har bir ochilgan fayl tizimda resurs (file descriptor) sifatida band qilinadi. Fayllar yopiqlmasa, bu resurslar ortadi va dastur sekinlashishi yoki xatoliklar chiqishi mumkin. \u2705 4. MA'LUMOTLAR BUZILISHI YOKI YO\u2018QOLISHI MUMKIN \ud83d\udccc Agar yozish davomida fayl yopilmasa va dastur to\u2018satdan to\u2018xtasa, yozilgan ma'lumotlar saqlanmasligi yoki fayl buzilishi mumkin. \u2705 FAYL REJIMLARI t \u2013 Matn rejimi. Fayllarni matn sifatida ochadi. Bu rejim r va w bilan birga ishlatiladi. Masalan, rt yoki wt . b \u2013 Ikkilik ( binary ) rejimi. Fayllarni ikkilik rejimda ochadi. Masalan, rb yoki wb . # Ikkilik faylni o'qish with open(\"image.png\", \"rb\") as img: data = img.read() print(data) # Ikkilik faylga yozish with open(\"output.bin\", \"wb\") as bin_file: bin_file.write(b\"Binary data\") \u2705 FAYLLAR BILAN BOG'LIQ BAZI FUNKSIYALAR os.remove() \u2013 Faylni o'chirish. os.rename() \u2013 Fayl nomini o'zgartirish. os.path.exists() \u2013 Fayl mavjudligini tekshirish. # OS (Operating System) moduli \u2014 fayllar bilan ishlash, o\u2018chirish, nomini o\u2018zgartirish uchun kerak import os # \"file.txt\" nomli faylni o\u2018chiradi # Agar bu fayl mavjud bo\u2018lmasa, xatolik (FileNotFoundError) yuz beradi os.remove(\"file.txt\") # \"old_name.txt\" nomli faylni \"new_name.txt\" deb o\u2018zgartiradi # Agar \"old_name.txt\" mavjud bo\u2018lmasa, yoki allaqachon \"new_name.txt\" mavjud bo\u2018lsa, xatolik beradi os.rename(\"old_name.txt\", \"new_name.txt\") # Fayl mavjudligini tekshiradi # Agar \"file.txt\" mavjud bo\u2018lsa, \"File exists\" chiqadi, bo\u2018lmasa \"File not found\" if os.path.exists(\"file.txt\"): print(\"File exists\") else: print(\"File not found\") \u2705 AMALIYOT \u2705 1-topshiriq: example.txt faylini ochib, uning ichidagi matnni to\u2018liq o\u2018qing va ekranga chiqaring. \u2705 2-topshiriq: info.txt nomli yangi fayl yarating va foydalanuvchidan ism , familiya va yosh so\u2018rab, faylga yozing. \u2705 3-topshiriq: numbers.txt nomli faylga 1 dan 10 gacha bo\u2018lgan sonlarni har birini yangi qatordan yozing. \u2705 4-topshiriq: numbers.txt faylini o\u2018qing va har bir qatordagi sonni ikkiga ko\u2018paytirib ekranga chiqaring. \u2705 5-topshiriq: append_example.txt fayliga har safar dasturni ishga tushirganingizda \"New line\" yozuvi qo\u2018shilsin. \u2705 6-topshiriq: Foydalanuvchidan 3 ta gap yozdirib oling va ularni sentences.txt fayliga yozing. \u2705 7-topshiriq: sentences.txt faylidan faqat birinchi qatorni o\u2018qib chiqaring va chop eting. \u2705 8-topshiriq: lines.txt faylida 5 ta qatordan iborat matn bor deb tasavvur qiling. Har bir qatordagi belgilar sonini chiqaring. \u2705 9-topshiriq: data.txt fayli mavjud bo\u2018lsa, uni o\u2018chiring. Mavjud emasligini tekshirib, foydalanuvchiga bildiring. \u2705 10-topshiriq: old.txt faylini new.txt deb o\u2018zgartiring. Fayl mavjud emas bo\u2018lsa, \u201cFayl topilmadi\u201d deb chiqaring. \u2705 11-topshiriq: users.txt faylida foydalanuvchilarning ismlari bo\u2018lsin. Fayldan ro\u2018yxatni o\u2018qib, har bir ismni Hello, <ism>! shaklida ekranga chiqaring. \u2705 12-topshiriq: text.txt fayliga inglizcha 3 gap yozing. So\u2018ng ushbu faylni o\u2018qib, har bir gapdagi so\u2018zlar sonini hisoblang. \u2705 13-topshiriq: Rasmlar uchun photo.jpg faylini rb (binary read) rejimida oching va fayl hajmini (baytlarda) aniqlang. \u2705 14-topshiriq: items.txt faylidan barcha qatorlarni ro\u2018yxatga o\u2018qing, ushbu ro\u2018yxatni output.txt fayliga nusxa ko\u2018chiring.","title":"File Handling"},{"location":"python/file-handling/#14-dars-file-handling","text":"\ud83d\udccc Fayl \u2014 bu kompyuterda ma'lumotlar saqlanadigan obyekt. U matn, rasm, ovoz yoki dasturiy kod bo\u2018lishi mumkin. Biz dasturda aynan matnli fayllar bilan ko\u2018p ishlaymiz, masalan: .txt, .csv, .json fayllar.","title":"\ud83e\udde9 14-DARS FILE HANDLING"},{"location":"python/file-handling/#fayl-nima-uchun-kerak","text":"\ud83d\udcdd Ma'lumotlarni saqlash \u2014 Dastur tugagandan keyin ham ma'lumot yo\u2018qolmasligi uchun. \ud83d\udd01 Qayta ishlash \u2014 Avval yozilgan ma'lumotlarni o\u2018qib, tahlil qilish yoki o\u2018zgartirish. \ud83d\udce4 Boshqa dasturlar bilan almashish \u2014 Fayllar orqali boshqa dasturlar bilan axborot almashiladi. \ud83d\udcda Katta hajmdagi ma'lumotlar \u2014 Ma'lumot bazasidan oldin oddiy fayllarda saqlanadi (masalan, .csv fayllar).","title":"\u2753 FAYL NIMA UCHUN KERAK?"},{"location":"python/file-handling/#faylni-ochish","text":"\ud83d\udccc Faylni ochish uchun open() funksiyasidan foydalaniladi. Bu funksiya fayl nomini va rejimini qabul qiladi. open() funksiyasida ikkinchi parametr sifatida fayl rejimini ko'rsatishingiz mumkin:","title":"\u2705 FAYLNI OCHISH"},{"location":"python/file-handling/#fayl-rejimlari","text":"\ud83d\udccc r \u2013 Faylni o'qish uchun ochish. Fayl mavjud bo'lishi kerak. \ud83d\udccc w \u2013 Faylga yozish uchun ochish. Agar fayl mavjud bo'lmasa, yangi fayl yaratadi. Mavjud fayl bo'lsa, ma'lumotlarni o'chirib yuboradi. \ud83d\udccc a \u2013 Faylga qo'shish uchun ochish. Mavjud faylga yangi ma'lumot qo'shadi, agar fayl mavjud bo'lmasa, yangi fayl yaratadi. \ud83d\udccc x \u2013 Faylni faqat yangi fayl yaratish uchun ochadi. Agar fayl allaqachon mavjud bo'lsa, xato chiqaradi. # Faylni o'qish uchun ochish f = open(\"file.txt\", \"r\") # Faylga yozish uchun ochish f = open(\"file.txt\", \"w\") # Faylga qo'shish uchun ochish f = open(\"file.txt\", \"a\") # Fayl mavjud emasligini tekshirib, yaratish f = open(\"file.txt\", \"x\")","title":"\u2705 FAYL REJIMLARI"},{"location":"python/file-handling/#faylni-oqish","text":"\ud83d\udccc Fayl ichidagi ma'lumotlarni o'qish uchun bir necha usullar mavjud: - read() \u2013 Faylni to'liq o'qiydi. - readline() \u2013 Fayldan bir qatorni o'qiydi. - readlines() \u2013 Fayldagi barcha qatorlarni ro'yxat sifatida o'qiydi. f = open(\"file.txt\", \"r\") # Barcha ma'lumotni o'qish content = f.read() print(content) # Bir qatorni o'qish line = f.readline() print(line) # Barcha qatorlarni ro'yxatga o'qish lines = f.readlines() print(lines) f.close()","title":"\u2705 FAYLNI O'QISH"},{"location":"python/file-handling/#faylga-yozish","text":"\ud83d\udccc Faylga yozish uchun write() yoki writelines() metodlaridan foydalaniladi: - write() \u2013 Faylga matn yozadi. - writelines() \u2013 Ro'yxatdagi barcha qatorlarni faylga yozadi. # Faylga ma'lumot yozish # \"file.txt\" nomli faylni yozish (\"w\") rejimida ochyapti f = open(\"file.txt\", \"w\") # Faylga \"Hello, Python!\" matnini yozadi va yangi qatordan boshlaydi f.write(\"Hello, Python!\\n\") # Faylga ikkinchi qatorda matn yozadi f.write(\"This is a second line.\\n\") # Faylni yopadi, bu majburiy \u2014 ma'lumotlar saqlanadi va fayl yopiladi f.close() # Ro'yxatni faylga yozish # Yoziladigan har bir element yangi qatordan iborat bo\u2018lgan ro'yxat lines = [\"First line\\n\", \"Second line\\n\", \"Third line\\n\"] # \"file.txt\" nomli faylni yana yozish rejimida ochyapti (eski ma'lumot o\u2018chiriladi) f = open(\"file.txt\", \"w\") # Ro'yxatdagi barcha elementlarni faylga ketma-ket yozadi f.writelines(lines) # Faylni yopadi f.close()","title":"\u2705 FAYLGA YOZISH"},{"location":"python/file-handling/#faylni-yopish","text":"\ud83d\udccc Fayl bilan ish tugagandan so'ng, uni yopish kerak. Faylni yopish uchun close() metodidan foydalaniladi. f = open(\"file.txt\", \"r\") # Fayldan o'qish jarayoni f.close() # Faylni yopish [!NOTE] Yana bir usul \u2013 faylni with bloki yordamida ochish, bunda fayl avtomatik ravishda yopiladi: with open(\"file.txt\", \"r\") as f: content = f.read() print(content) # Bu usulda faylni yopish shart emas, fayl avtomatik ravishda yopiladi.","title":"\u2705 FAYLNI YOPISH"},{"location":"python/file-handling/#faylni-yopmasa-nima-boladi","text":"","title":"\u2705 FAYLNI YOPMASA NIMA BO'LADI?"},{"location":"python/file-handling/#1-malumotlar-faylga-yozilmasligi-mumkin-yoki-kechikib-yozilishi","text":"\ud83d\udccc Python faylga yozayotgan paytda ma'lumotlarni dastlab xotira buferida saqlaydi. Faylni yopsangizgina bu ma'lumotlar diskka to\u2018liq yoziladi. # \"data.txt\" nomli faylni yozish (\"w\") rejimida ochadi (agar fayl bo'lmasa, yangi yaratadi) f = open(\"data.txt\", \"w\") # Faylga \"Bu matn faylga yoziladi.\" matnini yozadi f.write(\"Bu matn faylga yoziladi.\") # Faylni yopish yo\u2018q, shuning uchun yozilgan ma'lumot faylga saqlanmasligi yoki fayl ochiq qolishi mumkin # f.close() qatori bo\u2018lmasa, ma'lumotlar operatsion tizimning fayl keshida qolishi ehtimoli bor","title":"\u2705 1. MA'LUMOTLAR FAYLGA YOZILMASLIGI MUMKIN (YOKI KECHIKIB YOZILISHI)"},{"location":"python/file-handling/#2-fayl-boshqalar-uchun-band-bolib-qoladi","text":"\ud83d\udccc Agar siz faylni yopmasangiz, u operatsion tizim tomonidan \"ochiq\" deb hisoblanadi va boshqa dasturlar (yoki boshqa kod qismlari) uni o\u2018qiy olmaydi yoki tahrirlay olmaydi.","title":"\u2705 2. FAYL BOSHQALAR UCHUN BAND BO\u2018LIB QOLADI"},{"location":"python/file-handling/#3-xotira-resurslari-ortiqcha-band-boladi","text":"\ud83d\udccc Har bir ochilgan fayl tizimda resurs (file descriptor) sifatida band qilinadi. Fayllar yopiqlmasa, bu resurslar ortadi va dastur sekinlashishi yoki xatoliklar chiqishi mumkin.","title":"\u2705 3. XOTIRA RESURSLARI ORTIQCHA BAND BO\u2018LADI"},{"location":"python/file-handling/#4-malumotlar-buzilishi-yoki-yoqolishi-mumkin","text":"\ud83d\udccc Agar yozish davomida fayl yopilmasa va dastur to\u2018satdan to\u2018xtasa, yozilgan ma'lumotlar saqlanmasligi yoki fayl buzilishi mumkin.","title":"\u2705 4. MA'LUMOTLAR BUZILISHI YOKI YO\u2018QOLISHI MUMKIN"},{"location":"python/file-handling/#fayl-rejimlari_1","text":"t \u2013 Matn rejimi. Fayllarni matn sifatida ochadi. Bu rejim r va w bilan birga ishlatiladi. Masalan, rt yoki wt . b \u2013 Ikkilik ( binary ) rejimi. Fayllarni ikkilik rejimda ochadi. Masalan, rb yoki wb . # Ikkilik faylni o'qish with open(\"image.png\", \"rb\") as img: data = img.read() print(data) # Ikkilik faylga yozish with open(\"output.bin\", \"wb\") as bin_file: bin_file.write(b\"Binary data\")","title":"\u2705 FAYL REJIMLARI"},{"location":"python/file-handling/#fayllar-bilan-bogliq-bazi-funksiyalar","text":"os.remove() \u2013 Faylni o'chirish. os.rename() \u2013 Fayl nomini o'zgartirish. os.path.exists() \u2013 Fayl mavjudligini tekshirish. # OS (Operating System) moduli \u2014 fayllar bilan ishlash, o\u2018chirish, nomini o\u2018zgartirish uchun kerak import os # \"file.txt\" nomli faylni o\u2018chiradi # Agar bu fayl mavjud bo\u2018lmasa, xatolik (FileNotFoundError) yuz beradi os.remove(\"file.txt\") # \"old_name.txt\" nomli faylni \"new_name.txt\" deb o\u2018zgartiradi # Agar \"old_name.txt\" mavjud bo\u2018lmasa, yoki allaqachon \"new_name.txt\" mavjud bo\u2018lsa, xatolik beradi os.rename(\"old_name.txt\", \"new_name.txt\") # Fayl mavjudligini tekshiradi # Agar \"file.txt\" mavjud bo\u2018lsa, \"File exists\" chiqadi, bo\u2018lmasa \"File not found\" if os.path.exists(\"file.txt\"): print(\"File exists\") else: print(\"File not found\")","title":"\u2705 FAYLLAR BILAN BOG'LIQ BAZI FUNKSIYALAR"},{"location":"python/file-handling/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/file-handling/#1-topshiriq","text":"example.txt faylini ochib, uning ichidagi matnni to\u2018liq o\u2018qing va ekranga chiqaring.","title":"\u2705 1-topshiriq:"},{"location":"python/file-handling/#2-topshiriq","text":"info.txt nomli yangi fayl yarating va foydalanuvchidan ism , familiya va yosh so\u2018rab, faylga yozing.","title":"\u2705 2-topshiriq:"},{"location":"python/file-handling/#3-topshiriq","text":"numbers.txt nomli faylga 1 dan 10 gacha bo\u2018lgan sonlarni har birini yangi qatordan yozing.","title":"\u2705 3-topshiriq:"},{"location":"python/file-handling/#4-topshiriq","text":"numbers.txt faylini o\u2018qing va har bir qatordagi sonni ikkiga ko\u2018paytirib ekranga chiqaring.","title":"\u2705 4-topshiriq:"},{"location":"python/file-handling/#5-topshiriq","text":"append_example.txt fayliga har safar dasturni ishga tushirganingizda \"New line\" yozuvi qo\u2018shilsin.","title":"\u2705 5-topshiriq:"},{"location":"python/file-handling/#6-topshiriq","text":"Foydalanuvchidan 3 ta gap yozdirib oling va ularni sentences.txt fayliga yozing.","title":"\u2705 6-topshiriq:"},{"location":"python/file-handling/#7-topshiriq","text":"sentences.txt faylidan faqat birinchi qatorni o\u2018qib chiqaring va chop eting.","title":"\u2705 7-topshiriq:"},{"location":"python/file-handling/#8-topshiriq","text":"lines.txt faylida 5 ta qatordan iborat matn bor deb tasavvur qiling. Har bir qatordagi belgilar sonini chiqaring.","title":"\u2705 8-topshiriq:"},{"location":"python/file-handling/#9-topshiriq","text":"data.txt fayli mavjud bo\u2018lsa, uni o\u2018chiring. Mavjud emasligini tekshirib, foydalanuvchiga bildiring.","title":"\u2705 9-topshiriq:"},{"location":"python/file-handling/#10-topshiriq","text":"old.txt faylini new.txt deb o\u2018zgartiring. Fayl mavjud emas bo\u2018lsa, \u201cFayl topilmadi\u201d deb chiqaring.","title":"\u2705 10-topshiriq:"},{"location":"python/file-handling/#11-topshiriq","text":"users.txt faylida foydalanuvchilarning ismlari bo\u2018lsin. Fayldan ro\u2018yxatni o\u2018qib, har bir ismni Hello, <ism>! shaklida ekranga chiqaring.","title":"\u2705 11-topshiriq:"},{"location":"python/file-handling/#12-topshiriq","text":"text.txt fayliga inglizcha 3 gap yozing. So\u2018ng ushbu faylni o\u2018qib, har bir gapdagi so\u2018zlar sonini hisoblang.","title":"\u2705 12-topshiriq:"},{"location":"python/file-handling/#13-topshiriq","text":"Rasmlar uchun photo.jpg faylini rb (binary read) rejimida oching va fayl hajmini (baytlarda) aniqlang.","title":"\u2705 13-topshiriq:"},{"location":"python/file-handling/#14-topshiriq","text":"items.txt faylidan barcha qatorlarni ro\u2018yxatga o\u2018qing, ushbu ro\u2018yxatni output.txt fayliga nusxa ko\u2018chiring.","title":"\u2705 14-topshiriq:"},{"location":"python/for-loop/","text":"\ud83e\udde9 9-DARS FOR LOOP \ud83d\udccc for \u2013 bu tsikl operatori , ya\u2019ni takrorlovchi kod . Agar sizda bir nechta qiymatlar bo\u2018lsa (masalan, ro\u2018yxat, sonlar, harflar), for tsikli ularni birma-bir olib, har biriga bir xil amalni bajarish uchun ishlatiladi. # 'salom' degan matnli o'zgaruvchi yaratildi soz = \"salom\" # soz o'zgaruvchisidagi har bir harf bo'yicha yuramiz for harf in soz: # Har bir harfni alohida qilib ekranga chiqaramiz print(harf) \u2705 LISTLAR BILAN ISHLASH \ud83d\udccc Ro'yxatlar eng keng tarqalgan takrorlanadigan obyektlardan biri hisoblanadi. \ud83c\udfaf Buyurtmalar ro\u2018yxatini ekranga chiqarish # Buyurtma qilingan mahsulotlar ro'yxati orders = [\"bread\", \"milk\", \"eggs\", \"cheese\"] # Har bir mahsulot bo'yicha yurib chiqamiz for item in orders: # Mahsulot nomini ekranga chiqaramiz print(f\"Ordered item: {item}\") \ud83c\udfaf Narxlar ro'yxati bilan umumiy xarajatni hisoblash # Har bir mahsulot narxi (dollar) prices = [2.5, 1.0, 3.2, 4.8] # Umumiy summa uchun o'zgaruvchi total_cost = 0 # Har bir narx ustida yuramiz for price in prices: # Narxni umumiy summaga qo'shamiz total_cost += price # Umumiy narxni ekranga chiqaramiz print(f\"Total cost: ${total_cost}\") \ud83c\udfaf Email ro'yxatidan foydalanuvchilarga xabar yuborish (simulyatsiya) # Email manzillar ro'yxati emails = [\"ali@example.com\", \"vali@example.com\", \"sara@example.com\"] # Har bir foydalanuvchiga xabar yuboramiz (simulyatsiya) for email in emails: # Xabar yuborilganini bildiruvchi matn print(f\"Sending email to: {email}\") \ud83c\udfaf Login bo\u2018lgan foydalanuvchilarni filtrlash # Foydalanuvchilar va ularning login statusi (True - tizimga kirgan) users = [ {\"username\": \"admin\", \"logged_in\": True}, {\"username\": \"john\", \"logged_in\": False}, {\"username\": \"alice\", \"logged_in\": True}, ] # Faqat login bo'lgan foydalanuvchilarni chiqaramiz for user in users: if user[\"logged_in\"]: print(f\"{user['username']} is currently online.\") \ud83c\udfaf Mahsulot narxlarini chegirma bilan yangilash # Mahsulotlar va ularning narxlari ro'yxati products = [ {\"name\": \"laptop\", \"price\": 1000}, {\"name\": \"keyboard\", \"price\": 100}, {\"name\": \"mouse\", \"price\": 50}, ] # Har bir mahsulotga 10% chegirma beramiz for product in products: # Chegirma miqdorini hisoblaymiz discount = product[\"price\"] * 0.1 # Narxni yangilaymiz product[\"price\"] -= discount # Natijani chiqaramiz print(\"Discounted products:\") for product in products: print(f\"{product['name']}: ${product['price']}\") \ud83c\udfaf Foydalanuvchi ismlarini bosh harf bilan yozib chiqish # Foydalanuvchilar ismlari ro'yxati (kichik harflarda) usernames = [\"ali\", \"sara\", \"bekzod\", \"nigora\"] # Har bir ismni bosh harf bilan yangilaymiz for i in range(len(usernames)): # `.capitalize()` birinchi harfni katta qiladi usernames[i] = usernames[i].capitalize() # Natijani chiqaramiz print(\"Capitalized usernames:\", usernames) \ud83c\udfaf Sonlar ro'yxatidan faqat toq sonlarni ajratib olish # Sonlar ro'yxati numbers = [4, 7, 12, 9, 15, 2, 8] # Faqat toq sonlar uchun yangi ro'yxat odd_numbers = [] # Har bir sonni tekshiramiz for number in numbers: if number % 2 != 0: # Toq bo'lsa yangi ro'yxatga qo'shamiz odd_numbers.append(number) # Natijani chiqaramiz print(\"Odd numbers:\", odd_numbers) \u2705 RANGE \ud83d\udccc Python dasturlash tilida range() funksiyasi ketma-ket sonlar qatorini yaratish uchun ishlatiladi. Bu funksiya odatda for loop bilan birga ishlatiladi va bizga ma\u2019lum bir sonlar oralig\u2018ida takrorlash (aylanib chiqish) imkonini beradi. \ud83c\udfaf Oddiy range() ishlatilishi # 0 dan 4 gacha (5 kirmaydi) for i in range(5): print(i) \ud83c\udfaf Belgilangan oraliqdagi qiymatlar # 3 dan 8 gacha bo'lgan sonlarni chiqaramiz for i in range(3, 9): print(i) \ud83c\udfaf Step bilan yurish # 0 dan 10 gacha bo'lgan juft sonlarni chiqaramiz (2 qadam bilan) for index in range(0, 11, 2): print(index) \ud83c\udfaf Orqaga qarab sanash # 10 dan 1 gacha orqaga qarab for i in range(10, 0, -1): print(i) \ud83c\udfaf Har bir foydalanuvchiga ID berish # 3 ta foydalanuvchi nomi users = [\"Ali\", \"Vali\", \"Sardor\"] # Foydalanuvchilarga ID raqam berish (1 dan boshlab) for i in range(len(users)): print(f\"User ID: {i+1} - Name: {users[i]}\") \u2705 DICTIONARY BILAN ISHLASH \ud83c\udfaf Foydalanuvchi profillari ro\u2018yxati # Bir nechta foydalanuvchilarning profillari users = [ {\"username\": \"ali\", \"email\": \"ali@example.com\", \"is_active\": True}, {\"username\": \"sara\", \"email\": \"sara@example.com\", \"is_active\": False}, {\"username\": \"diyor\", \"email\": \"diyor@example.com\", \"is_active\": True}, ] # Faqat aktiv foydalanuvchilarni chiqaramiz for user in users: if user[\"is_active\"]: print(f\"{user['username']} (email: {user['email']}) is active.\") \ud83c\udfaf Savatdagi mahsulotlar va umumiy narxni hisoblash # Xarid savatidagi mahsulotlar cart = [ {\"name\": \"laptop\", \"price\": 850.0, \"quantity\": 1}, {\"name\": \"mouse\", \"price\": 25.0, \"quantity\": 2}, {\"name\": \"keyboard\", \"price\": 45.0, \"quantity\": 1}, ] # Umumiy narxni hisoblaymiz total = 0 for item in cart: total += item[\"price\"] * item[\"quantity\"] print(f\"Umumiy summa: ${total}\") \ud83c\udfaf Talabalar baholari bo\u2018yicha statistika # Talabalar va ularning baholari grades = { \"Ali\": 87, \"Sardor\": 92, \"Nigora\": 78, \"Lola\": 85 } # O\u2018rtacha bahoni hisoblaymiz average = sum(grades.values()) / len(grades) print(f\"O\u2018rtacha baho: {average}\") \ud83c\udfaf Chegirma tizimi (promo code) # Promo kodlar va ularning chegirmalari (%) promo_codes = { \"SALE10\": 10, \"WELCOME15\": 15, \"VIP20\": 20 } code = input(\"Promo kodni kiriting: \").upper() # Kodni tekshirib chegirma beramiz if code in promo_codes: print(f\"Sizga {promo_codes[code]}% chegirma berildi!\") else: print(\"Noto\u2018g\u2018ri promo kod!\") \ud83c\udfaf API javobini tahlil qilish (dictionary ko\u2018rinishida) # API dan kelgan javob response = { \"status\": \"success\", \"data\": { \"id\": 102, \"title\": \"New blog post\", \"author\": \"Umid\", \"views\": 1234 } } # Ma'lumotni tahlil qilish if response[\"status\"] == \"success\": blog = response[\"data\"] print(f\"Post: {blog['title']} (Author: {blog['author']}) \u2014 {blog['views']} views\") else: print(\"Xatolik yuz berdi.\") \u2705 SETS BILAN ISHLASH \ud83c\udfaf Foydalanuvchi kirgan sahifalarni yagona ro\u2018yxatga olish # Sahifalar bo'yicha foydalanuvchi harakati (ba'zilari takrorlangan) visited_pages = [\"home\", \"about\", \"contact\", \"home\", \"products\", \"contact\"] # Takrorlangan sahifalarni set orqali avtomatik chiqarib tashlaymiz unique_pages = set(visited_pages) print(\"Foydalanuvchi kirgan noyob sahifalar:\") for page in unique_pages: print(page) \ud83c\udfaf Email ro'yxatlaridagi dublikatlarni olib tashlash # Ro'yxatda takrorlanuvchi email manzillar bor emails = [ \"ali@example.com\", \"sara@example.com\", \"ali@example.com\", \"jamshid@example.com\", \"sara@example.com\" ] # set yordamida faqat noyob email manzillarni olamiz unique_emails = set(emails) print(\"Yagona email manzillar:\") for email in unique_emails: print(email) \ud83c\udfaf Ikkita foydalanuvchi orasidagi umumiy do\u2018stlarni topish # Foydalanuvchilarning do'stlari friends_1 = {\"Ali\", \"Sara\", \"Lola\", \"Bekzod\"} friends_2 = {\"Lola\", \"Sardor\", \"Ali\", \"Diyor\"} # Umumiy do'stlar: kesishma (intersection) common_friends = friends_1 & friends_2 print(\"Umumiy do'stlar:\") print(common_friends) \ud83c\udfaf Ro\u2018yxatdan o\u2018tgan foydalanuvchilar va online foydalanuvchilar orasidagi farq # Ro'yxatdan o\u2018tgan foydalanuvchilar registered_users = {\"ali\", \"sara\", \"diyor\", \"nigora\"} # Hozir online bo'lgan foydalanuvchilar online_users = {\"ali\", \"sardor\"} # Faqat ro'yxatdan o\u2018tgan, lekin online bo'lmaganlar offline_users = registered_users - online_users print(\"Hozir offline foydalanuvchilar:\") print(offline_users) \u2705 TUPLE BILAN ISHLASH \ud83c\udfaf Oddiy tuple ustidan for tsik # Koordinatalar (o'zgarmas qiymatlar) coordinates = (10, 20, 30) # Har bir koordinatani chiqarish for coordinate in coordinates: print(coordinate) \ud83c\udfaf Mahsulotlar ro\u2018yxati tupleda (ID, nomi, narxi) # Har bir mahsulot: (id, nomi, narxi) products = ( (1, \"Laptop\", 1200), (2, \"Mouse\", 30), (3, \"Keyboard\", 50), ) # Mahsulotlar haqida to\u2018liq ma\u2019lumot chiqaramiz for product_id, name, price in products: print(f\"ID: {product_id}, Nomi: {name}, Narxi: ${price}\") \u2705 NESTED LOOPS \ud83c\udfaf 2D ro'yxat (matritsa) elementlarini ko\u2018rsatish matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] for row in matrix: for element in row: print(element, end=\" \") print() # Qator oxirida yangi qatorga o'tish \ud83d\udccc Python dasturlash tilida print() funksiyasi biror narsani ekranga chiqargandan so\u2018ng avtomatik tarzda yangi qatorga o\u2018tadi. Bu yangi qator belgisi \\n deb ataladi. Ammo ba\u2019zida har bir chiqishdan keyin yangi qatorga o\u2018tmasdan, boshqa belgi (masalan, bo\u2018sh joy yoki vergul) qo\u2018yishni xohlaysiz. Shu holatda print() funksiyasida end parametri ishlatiladi. \ud83c\udfaf Foydalanuvchilar va ularning telefon raqamlari # Har bir foydalanuvchining bir nechta telefon raqami bor users = { \"Ali\": [\"+998901112233\", \"+998912223344\"], \"Sara\": [\"+998933445566\"], \"Diyor\": [\"+998935551234\", \"+998998887766\"] } # Har bir foydalanuvchi va raqamlarini chiqaramiz for name, phones in users.items(): print(f\"{name}ning raqamlari:\") for phone in phones: print(f\" - {phone}\") \ud83c\udfaf Kategoriya va mahsulotlar # Mahsulotlar toifalar bo'yicha guruhlangan categories = { \"Elektronika\": [\"Telefon\", \"Noutbuk\", \"Smart soat\"], \"Kiyim\": [\"Ko\u2018ylak\", \"Shim\", \"Poyabzal\"], \"Oziq-ovqat\": [\"Non\", \"Sut\", \"Yog\u2018\"] } # Har bir kategoriya va mahsulotlarini chiqaramiz for category, items in categories.items(): print(f\"{category}:\") for item in items: print(f\" - {item}\") \ud83c\udfaf Sayt menyusini chiqarish (asosiy bo\u2018lim + ichki bo\u2018limlar) # Sayt menyusi menu = { \"Bosh sahifa\": [], \"Kurslar\": [\"Python\", \"Django\", \"Flask\"], \"Aloqa\": [\"Biz haqimizda\", \"Bog\u2018lanish\"] } # Menyuni chiqaramiz for main_menu, submenus in menu.items(): print(main_menu) for submenu in submenus: print(f\" - {submenu}\") \u2705 FOR ELSE \ud83d\udccc Python dasturlash tilida for...else bu \u2014 for tsikli bilan birga ishlatiladigan maxsus konstruktsiya bo\u2018lib, u orqali loop muvaffaqiyatli tugaganidan keyin else qismi bajariladi. \ud83c\udfaf Foydalanuvchi ro\u2018yxatida admin borligini tekshirish users = [\"ali\", \"sara\", \"lola\", \"jamshid\"] for user in users: if user == \"admin\": print(\"Admin foydalanuvchi topildi.\") break else: print(\"Admin foydalanuvchi ro'yxatda yo'q.\") \ud83c\udfaf Parol to\u2018g\u2018riligini tekshirish # Parollar bazasi correct_passwords = [\"pass123\", \"admin456\", \"qwerty789\"] user_input = \"admin456\" for password in correct_passwords: if user_input == password: print(\"Parol to'g'ri.\") break else: print(\"Parol noto'g'ri.\") \u2705 BREAK \ud83d\udccc break operatori loopni to'xtatadi. Bu operator for yoki while loopda ishlatilishi mumkin. break loopning bajarilishini to'xtatadi va loopdan chiqadi, hatto loop to'liq tugamagan bo'lsa ham. \ud83c\udfaf Ma\u2019lumotlar bazasidan kerakli foydalanuvchini topish # Foydalanuvchilar ro'yxatini lug'atlar ko'rinishida yaratdik users = [ {\"id\": 1, \"name\": \"Ali\"}, {\"id\": 2, \"name\": \"Sara\"}, {\"id\": 3, \"name\": \"Diyor\"} ] # Qidirilayotgan foydalanuvchining ID raqamini belgiladik searched_id = 2 # users ro'yxatidagi har bir element (ya'ni foydalanuvchi) bo'yicha yuramiz for user in users: # Agar foydalanuvchining 'id' qiymati qidirilayotgan id ga teng bo'lsa if user[\"id\"] == searched_id: # Foydalanuvchi topilganini ekranga chiqaramiz print(f\"Foydalanuvchi topildi: {user['name']}\") # Qolgan elementlarni tekshirishning hojati yo'q, loop ni to'xtatamiz break \ud83c\udfaf API javobidan kerakli postni topish # Postlar listini yaratdik, har bir post dictionary ko'rinishida berilgan posts = [ {\"id\": 1, \"title\": \"Salom\"}, {\"id\": 2, \"title\": \"Python haqida\"}, {\"id\": 3, \"title\": \"Xayr\"} ] # Qidirilayotgan postning sarlavhasini belgiladik search_title = \"Python haqida\" # posts listdagi har bir post bo'yicha yuramiz for post in posts: # Agar postning 'title' qiymati qidirilayotgan sarlavhaga teng bo'lsa if post[\"title\"] == search_title: # Post topilganini ekranga chiqaramiz print(\"Post topildi:\", post) # Endi qolgan postlarni tekshirishning hojati yo'q, loop ni to'xtatamiz break \ud83c\udfaf for + else bilan birga break ishlatish # Shaharlar nomlari yozilgan ro'yxat yaratildi cities = [\"Toshkent\", \"Samarqand\", \"Buxoro\", \"Xiva\"] # Qidirilayotgan shahar nomi belgilanmoqda search = \"Andijon\" # cities ro'yxatidagi har bir shahar ustida yurib chiqamiz for city in cities: # Agar ro'yxatdagi shahar nomi qidirilayotgan nomga teng bo\u2018lsa if city == search: # Ekranga topilganligi haqida xabar chiqaramiz print(\"Shahar topildi!\") # Endi boshqa shaharlarni tekshirish shart emas, loop to\u2018xtatiladi break # Agar loop oxirigacha borib chiqqan bo\u2018lsa va break ishlamagan bo\u2018lsa else: # Demak shahar ro'yxatda yo\u2018q, degan xabar chiqariladi print(\"Shahar ro'yxatda yo'q.\") \u2705 CONTINUE \ud83d\udccc Python dasturlash tilida continue operatori tsikl ichida ishlatiladigan boshqaruvchi buyruq bo\u2018lib, u ishga tushganda tsikldagi shu takrorlanishning qolgan qismini o\u2018tkazib yuboradi va keyingi takrorlanishga (iteration) o\u2018tadi. # Sonlardan iborat ro'yxat yaratildi sonlar = [1, 2, 3, 4, 5] # sonlar ro'yxatidagi har bir son bo'yicha yuramiz for son in sonlar: # Agar hozirgi son 2 ga bo\u2018linganda qoldiq 0 bo\u2018lsa, ya\u2019ni juft bo\u2018lsa if son % 2 == 0: # Bu sonni tashlab o\u2018tamiz va loop keyingi son bilan davom etadi continue # Agar son toq bo\u2018lsa (ya\u2019ni yuqoridagi shart bajarilmagan bo\u2018lsa), uni chiqaramiz print(son) \ud83c\udfaf Faqat musbat sonlarni chiqarish # Musbat va manfiy sonlardan iborat ro'yxat yaratildi sonlar = [-1, 2, -3, 4, -5] # sonlar ro'yxatidagi har bir son bo'yicha yuramiz for son in sonlar: # Agar hozirgi son 0 dan kichik bo\u2018lsa, ya\u2019ni manfiy bo\u2018lsa if son < 0: # Manfiy sonni chiqarib o\u2018tib ketamiz, ya\u2019ni pastdagi qator bajarilmaydi continue # Faqat musbat sonlar (0 va undan katta) shu yerda ekranga chiqariladi print(son) \ud83c\udfaf Faqat juft indeksli mevalarni chiqarish # Mevalardan iborat ro'yxat yaratildi mevalar = ['olma', 'banan', 'apelsin', 'anjir'] # range() funksiyasi orqali indekslar bo'yicha 0 dan len(mevalar) gacha yuramiz for i in range(len(mevalar)): # Agar hozirgi indeks toq bo\u2018lsa (ya'ni 1, 3, ...) if i % 2 != 0: # Bu indeksdagi elementni o\u2018tkazib yuboramiz va loop davom etadi continue # Faqat juft indeks (0, 2, ...) dagi mevalar ekranga chiqariladi print(mevalar[i]) \u2705 PASS \ud83d\udccc Python dasturlash tilida pass operatori \u2014 bu hech qanday amal bajarmaydigan buyruq. Ya\u2019ni, u bo\u2018sh kod blokini vaqtincha to\u2018ldirish uchun ishlatiladi. # 0 dan 4 gacha bo\u2018lgan sonlar ustida aylanuvchi for tsikli for son in range(5): # Agar son 3 ga teng bo\u2018lsa if son == 3: pass # Hech qanday amal bajarmaymiz, faqat kod sintaksisini saqlab qolamiz else: print(son) # Aks holda, sonni ekranga chiqaramiz \ud83c\udfaf Kod hali yozilmagan, lekin struktura tayyor bo\u2018lishi kerak def validate_user_input(): # Bu funksiya foydalanuvchi kiritgan ma'lumotni tekshiradi pass # Keyinroq bu yerga tekshirish kodi yoziladi \ud83c\udfaf Bo\u2018sh class yaratish class PaymentSystem: pass # Bu class keyin to\u2018ldiriladi \ud83c\udfaf Exception (xatolik)ni vaqtincha e'tiborga olmaslik try: x = 10 / 0 except ZeroDivisionError: pass # Hozircha xatoni ko\u2018rsatmaymiz, faqat chetlab o\u2018tamiz \ud83c\udfaf Bo\u2018sh if yoki for bloklarida sintaksis xatosidan saqlanish users = [\"admin\", \"user\", \"guest\"] for user in users: if user == \"admin\": pass # Hozircha admin uchun alohida ish yo\u2018q else: print(f\"{user} uchun oddiy xush kelibsiz\") \u2705 AMALIYOT \u2705 1-topshiriq: Foydalanuvchi kiritgan natural son uchun 1 dan shu songacha bo\u2018lgan sonlar yig\u2018indisini for loop orqali hisoblang. \u2705 2-topshiriq: Quyidagi ro\u2018yxatda nechta elementda eng kamida 2 ta unli harf borligini aniqlang: words = [\"apple\", \"sky\", \"queue\", \"book\", \"cry\"] \u2705 3-topshiriq: Ro\u2018yxatda eng katta va eng kichik sonning farqini toping: numbers = [7, 12, -3, 8, 0, 15] \u2705 4-topshiriq: Foydalanuvchi 10 ta son kiritadi. For loop orqali faqat musbat va toq sonlarni yangi ro\u2018yxatga yozing. \u2705 5-topshiriq: Quyidagi ro\u2018yxatdagi har bir so\u2018zning birinchi va oxirgi harfini birlashtirib yangi ro\u2018yxat hosil qiling: words = [\"python\", \"apple\", \"code\", \"loop\"] # natija: [\"pn\", \"ae\", \"ce\", \"lp\"] \u2705 6-topshiriq: Ro\u2018yxatdan faqat 3 ga va 5 ga bo\u2018linadigan sonlarni ajratib, ularning o\u2018rtacha qiymatini hisoblang: nums = [5, 9, 15, 20, 22, 30, 35] \u2705 7-topshiriq: Foydalanuvchi matn kiritadi. Matndagi raqamlarni topib, ularni son sifatida yig\u2018indisini hisoblang. Masalan: \"salom12dunyo3\" => natija: 15 \u2705 8-topshiriq: Berilgan ro\u2018yxatdan elementlarning indekslari juft bo\u2018lganlarini alohida ro\u2018yxatga chiqarib bering: fruits = [\"olma\", \"banan\", \"gilos\", \"anor\", \"nok\", \"shaftoli\"] \u2705 9-topshiriq: Ro\u2018yxatda ketma-ket 2 marta uchraydigan elementlarni aniqlang: items = [1, 2, 2, 3, 4, 4, 4, 5] # natija: 2, 4 \u2705 10-topshiriq: Foydalanuvchi kiritgan matndan faqat bosh harflarni ajratib, bitta string qilib chiqaring. Masalan: \"Salom DunYo\" => \"SDY\" \u2705 11-topshiriq: Quyidagi ro\u2018yxatdan palindrom (teskari o\u2018qilganda ham bir xil) so\u2018zlarni ajratib chiqaring: words = [\"anna\", \"python\", \"level\", \"loop\", \"radar\"] \u2705 12-topshiriq: for loop yordamida 100 dan kichik Fibonacci sonlarini ro\u2018yxatga yig\u2018ing. \u2705 13-topshiriq: Ro\u2018yxatda nechta elementda harflar soni raqamlar sonidan ko\u2018p ekanini hisoblang: elements = [\"abc123\", \"hello\", \"42\", \"py2025\", \"test\"] \u2705 14-topshiriq: Ro\u2018yxatdagi sonlardan har birining raqamlari yig\u2018indisini hisoblab, yangi ro\u2018yxatga joylang: nums = [12, 305, 47, 88] # natija: [3, 8, 11, 16] \u2705 15-topshiriq: Ro\u2018yxatdagi elementlardan faqat birinchi harfi har doim katta, qolganlari kichik bo\u2018lgan yangi ro\u2018yxat yarating: names = [\"aNVAR\", \"mUROD\", \"dILSHOD\"] # natija: [\"Anvar\", \"Murod\", \"Dilshod\"]","title":"For Loop"},{"location":"python/for-loop/#9-dars-for-loop","text":"\ud83d\udccc for \u2013 bu tsikl operatori , ya\u2019ni takrorlovchi kod . Agar sizda bir nechta qiymatlar bo\u2018lsa (masalan, ro\u2018yxat, sonlar, harflar), for tsikli ularni birma-bir olib, har biriga bir xil amalni bajarish uchun ishlatiladi. # 'salom' degan matnli o'zgaruvchi yaratildi soz = \"salom\" # soz o'zgaruvchisidagi har bir harf bo'yicha yuramiz for harf in soz: # Har bir harfni alohida qilib ekranga chiqaramiz print(harf)","title":"\ud83e\udde9 9-DARS FOR LOOP"},{"location":"python/for-loop/#listlar-bilan-ishlash","text":"\ud83d\udccc Ro'yxatlar eng keng tarqalgan takrorlanadigan obyektlardan biri hisoblanadi. \ud83c\udfaf Buyurtmalar ro\u2018yxatini ekranga chiqarish # Buyurtma qilingan mahsulotlar ro'yxati orders = [\"bread\", \"milk\", \"eggs\", \"cheese\"] # Har bir mahsulot bo'yicha yurib chiqamiz for item in orders: # Mahsulot nomini ekranga chiqaramiz print(f\"Ordered item: {item}\") \ud83c\udfaf Narxlar ro'yxati bilan umumiy xarajatni hisoblash # Har bir mahsulot narxi (dollar) prices = [2.5, 1.0, 3.2, 4.8] # Umumiy summa uchun o'zgaruvchi total_cost = 0 # Har bir narx ustida yuramiz for price in prices: # Narxni umumiy summaga qo'shamiz total_cost += price # Umumiy narxni ekranga chiqaramiz print(f\"Total cost: ${total_cost}\") \ud83c\udfaf Email ro'yxatidan foydalanuvchilarga xabar yuborish (simulyatsiya) # Email manzillar ro'yxati emails = [\"ali@example.com\", \"vali@example.com\", \"sara@example.com\"] # Har bir foydalanuvchiga xabar yuboramiz (simulyatsiya) for email in emails: # Xabar yuborilganini bildiruvchi matn print(f\"Sending email to: {email}\") \ud83c\udfaf Login bo\u2018lgan foydalanuvchilarni filtrlash # Foydalanuvchilar va ularning login statusi (True - tizimga kirgan) users = [ {\"username\": \"admin\", \"logged_in\": True}, {\"username\": \"john\", \"logged_in\": False}, {\"username\": \"alice\", \"logged_in\": True}, ] # Faqat login bo'lgan foydalanuvchilarni chiqaramiz for user in users: if user[\"logged_in\"]: print(f\"{user['username']} is currently online.\") \ud83c\udfaf Mahsulot narxlarini chegirma bilan yangilash # Mahsulotlar va ularning narxlari ro'yxati products = [ {\"name\": \"laptop\", \"price\": 1000}, {\"name\": \"keyboard\", \"price\": 100}, {\"name\": \"mouse\", \"price\": 50}, ] # Har bir mahsulotga 10% chegirma beramiz for product in products: # Chegirma miqdorini hisoblaymiz discount = product[\"price\"] * 0.1 # Narxni yangilaymiz product[\"price\"] -= discount # Natijani chiqaramiz print(\"Discounted products:\") for product in products: print(f\"{product['name']}: ${product['price']}\") \ud83c\udfaf Foydalanuvchi ismlarini bosh harf bilan yozib chiqish # Foydalanuvchilar ismlari ro'yxati (kichik harflarda) usernames = [\"ali\", \"sara\", \"bekzod\", \"nigora\"] # Har bir ismni bosh harf bilan yangilaymiz for i in range(len(usernames)): # `.capitalize()` birinchi harfni katta qiladi usernames[i] = usernames[i].capitalize() # Natijani chiqaramiz print(\"Capitalized usernames:\", usernames) \ud83c\udfaf Sonlar ro'yxatidan faqat toq sonlarni ajratib olish # Sonlar ro'yxati numbers = [4, 7, 12, 9, 15, 2, 8] # Faqat toq sonlar uchun yangi ro'yxat odd_numbers = [] # Har bir sonni tekshiramiz for number in numbers: if number % 2 != 0: # Toq bo'lsa yangi ro'yxatga qo'shamiz odd_numbers.append(number) # Natijani chiqaramiz print(\"Odd numbers:\", odd_numbers)","title":"\u2705 LISTLAR BILAN ISHLASH"},{"location":"python/for-loop/#range","text":"\ud83d\udccc Python dasturlash tilida range() funksiyasi ketma-ket sonlar qatorini yaratish uchun ishlatiladi. Bu funksiya odatda for loop bilan birga ishlatiladi va bizga ma\u2019lum bir sonlar oralig\u2018ida takrorlash (aylanib chiqish) imkonini beradi. \ud83c\udfaf Oddiy range() ishlatilishi # 0 dan 4 gacha (5 kirmaydi) for i in range(5): print(i) \ud83c\udfaf Belgilangan oraliqdagi qiymatlar # 3 dan 8 gacha bo'lgan sonlarni chiqaramiz for i in range(3, 9): print(i) \ud83c\udfaf Step bilan yurish # 0 dan 10 gacha bo'lgan juft sonlarni chiqaramiz (2 qadam bilan) for index in range(0, 11, 2): print(index) \ud83c\udfaf Orqaga qarab sanash # 10 dan 1 gacha orqaga qarab for i in range(10, 0, -1): print(i) \ud83c\udfaf Har bir foydalanuvchiga ID berish # 3 ta foydalanuvchi nomi users = [\"Ali\", \"Vali\", \"Sardor\"] # Foydalanuvchilarga ID raqam berish (1 dan boshlab) for i in range(len(users)): print(f\"User ID: {i+1} - Name: {users[i]}\")","title":"\u2705 RANGE"},{"location":"python/for-loop/#dictionary-bilan-ishlash","text":"\ud83c\udfaf Foydalanuvchi profillari ro\u2018yxati # Bir nechta foydalanuvchilarning profillari users = [ {\"username\": \"ali\", \"email\": \"ali@example.com\", \"is_active\": True}, {\"username\": \"sara\", \"email\": \"sara@example.com\", \"is_active\": False}, {\"username\": \"diyor\", \"email\": \"diyor@example.com\", \"is_active\": True}, ] # Faqat aktiv foydalanuvchilarni chiqaramiz for user in users: if user[\"is_active\"]: print(f\"{user['username']} (email: {user['email']}) is active.\") \ud83c\udfaf Savatdagi mahsulotlar va umumiy narxni hisoblash # Xarid savatidagi mahsulotlar cart = [ {\"name\": \"laptop\", \"price\": 850.0, \"quantity\": 1}, {\"name\": \"mouse\", \"price\": 25.0, \"quantity\": 2}, {\"name\": \"keyboard\", \"price\": 45.0, \"quantity\": 1}, ] # Umumiy narxni hisoblaymiz total = 0 for item in cart: total += item[\"price\"] * item[\"quantity\"] print(f\"Umumiy summa: ${total}\") \ud83c\udfaf Talabalar baholari bo\u2018yicha statistika # Talabalar va ularning baholari grades = { \"Ali\": 87, \"Sardor\": 92, \"Nigora\": 78, \"Lola\": 85 } # O\u2018rtacha bahoni hisoblaymiz average = sum(grades.values()) / len(grades) print(f\"O\u2018rtacha baho: {average}\") \ud83c\udfaf Chegirma tizimi (promo code) # Promo kodlar va ularning chegirmalari (%) promo_codes = { \"SALE10\": 10, \"WELCOME15\": 15, \"VIP20\": 20 } code = input(\"Promo kodni kiriting: \").upper() # Kodni tekshirib chegirma beramiz if code in promo_codes: print(f\"Sizga {promo_codes[code]}% chegirma berildi!\") else: print(\"Noto\u2018g\u2018ri promo kod!\") \ud83c\udfaf API javobini tahlil qilish (dictionary ko\u2018rinishida) # API dan kelgan javob response = { \"status\": \"success\", \"data\": { \"id\": 102, \"title\": \"New blog post\", \"author\": \"Umid\", \"views\": 1234 } } # Ma'lumotni tahlil qilish if response[\"status\"] == \"success\": blog = response[\"data\"] print(f\"Post: {blog['title']} (Author: {blog['author']}) \u2014 {blog['views']} views\") else: print(\"Xatolik yuz berdi.\")","title":"\u2705 DICTIONARY BILAN ISHLASH"},{"location":"python/for-loop/#sets-bilan-ishlash","text":"\ud83c\udfaf Foydalanuvchi kirgan sahifalarni yagona ro\u2018yxatga olish # Sahifalar bo'yicha foydalanuvchi harakati (ba'zilari takrorlangan) visited_pages = [\"home\", \"about\", \"contact\", \"home\", \"products\", \"contact\"] # Takrorlangan sahifalarni set orqali avtomatik chiqarib tashlaymiz unique_pages = set(visited_pages) print(\"Foydalanuvchi kirgan noyob sahifalar:\") for page in unique_pages: print(page) \ud83c\udfaf Email ro'yxatlaridagi dublikatlarni olib tashlash # Ro'yxatda takrorlanuvchi email manzillar bor emails = [ \"ali@example.com\", \"sara@example.com\", \"ali@example.com\", \"jamshid@example.com\", \"sara@example.com\" ] # set yordamida faqat noyob email manzillarni olamiz unique_emails = set(emails) print(\"Yagona email manzillar:\") for email in unique_emails: print(email) \ud83c\udfaf Ikkita foydalanuvchi orasidagi umumiy do\u2018stlarni topish # Foydalanuvchilarning do'stlari friends_1 = {\"Ali\", \"Sara\", \"Lola\", \"Bekzod\"} friends_2 = {\"Lola\", \"Sardor\", \"Ali\", \"Diyor\"} # Umumiy do'stlar: kesishma (intersection) common_friends = friends_1 & friends_2 print(\"Umumiy do'stlar:\") print(common_friends) \ud83c\udfaf Ro\u2018yxatdan o\u2018tgan foydalanuvchilar va online foydalanuvchilar orasidagi farq # Ro'yxatdan o\u2018tgan foydalanuvchilar registered_users = {\"ali\", \"sara\", \"diyor\", \"nigora\"} # Hozir online bo'lgan foydalanuvchilar online_users = {\"ali\", \"sardor\"} # Faqat ro'yxatdan o\u2018tgan, lekin online bo'lmaganlar offline_users = registered_users - online_users print(\"Hozir offline foydalanuvchilar:\") print(offline_users)","title":"\u2705 SETS BILAN ISHLASH"},{"location":"python/for-loop/#tuple-bilan-ishlash","text":"\ud83c\udfaf Oddiy tuple ustidan for tsik # Koordinatalar (o'zgarmas qiymatlar) coordinates = (10, 20, 30) # Har bir koordinatani chiqarish for coordinate in coordinates: print(coordinate) \ud83c\udfaf Mahsulotlar ro\u2018yxati tupleda (ID, nomi, narxi) # Har bir mahsulot: (id, nomi, narxi) products = ( (1, \"Laptop\", 1200), (2, \"Mouse\", 30), (3, \"Keyboard\", 50), ) # Mahsulotlar haqida to\u2018liq ma\u2019lumot chiqaramiz for product_id, name, price in products: print(f\"ID: {product_id}, Nomi: {name}, Narxi: ${price}\")","title":"\u2705 TUPLE BILAN ISHLASH"},{"location":"python/for-loop/#nested-loops","text":"\ud83c\udfaf 2D ro'yxat (matritsa) elementlarini ko\u2018rsatish matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] for row in matrix: for element in row: print(element, end=\" \") print() # Qator oxirida yangi qatorga o'tish \ud83d\udccc Python dasturlash tilida print() funksiyasi biror narsani ekranga chiqargandan so\u2018ng avtomatik tarzda yangi qatorga o\u2018tadi. Bu yangi qator belgisi \\n deb ataladi. Ammo ba\u2019zida har bir chiqishdan keyin yangi qatorga o\u2018tmasdan, boshqa belgi (masalan, bo\u2018sh joy yoki vergul) qo\u2018yishni xohlaysiz. Shu holatda print() funksiyasida end parametri ishlatiladi. \ud83c\udfaf Foydalanuvchilar va ularning telefon raqamlari # Har bir foydalanuvchining bir nechta telefon raqami bor users = { \"Ali\": [\"+998901112233\", \"+998912223344\"], \"Sara\": [\"+998933445566\"], \"Diyor\": [\"+998935551234\", \"+998998887766\"] } # Har bir foydalanuvchi va raqamlarini chiqaramiz for name, phones in users.items(): print(f\"{name}ning raqamlari:\") for phone in phones: print(f\" - {phone}\") \ud83c\udfaf Kategoriya va mahsulotlar # Mahsulotlar toifalar bo'yicha guruhlangan categories = { \"Elektronika\": [\"Telefon\", \"Noutbuk\", \"Smart soat\"], \"Kiyim\": [\"Ko\u2018ylak\", \"Shim\", \"Poyabzal\"], \"Oziq-ovqat\": [\"Non\", \"Sut\", \"Yog\u2018\"] } # Har bir kategoriya va mahsulotlarini chiqaramiz for category, items in categories.items(): print(f\"{category}:\") for item in items: print(f\" - {item}\") \ud83c\udfaf Sayt menyusini chiqarish (asosiy bo\u2018lim + ichki bo\u2018limlar) # Sayt menyusi menu = { \"Bosh sahifa\": [], \"Kurslar\": [\"Python\", \"Django\", \"Flask\"], \"Aloqa\": [\"Biz haqimizda\", \"Bog\u2018lanish\"] } # Menyuni chiqaramiz for main_menu, submenus in menu.items(): print(main_menu) for submenu in submenus: print(f\" - {submenu}\")","title":"\u2705 NESTED LOOPS"},{"location":"python/for-loop/#for-else","text":"\ud83d\udccc Python dasturlash tilida for...else bu \u2014 for tsikli bilan birga ishlatiladigan maxsus konstruktsiya bo\u2018lib, u orqali loop muvaffaqiyatli tugaganidan keyin else qismi bajariladi. \ud83c\udfaf Foydalanuvchi ro\u2018yxatida admin borligini tekshirish users = [\"ali\", \"sara\", \"lola\", \"jamshid\"] for user in users: if user == \"admin\": print(\"Admin foydalanuvchi topildi.\") break else: print(\"Admin foydalanuvchi ro'yxatda yo'q.\") \ud83c\udfaf Parol to\u2018g\u2018riligini tekshirish # Parollar bazasi correct_passwords = [\"pass123\", \"admin456\", \"qwerty789\"] user_input = \"admin456\" for password in correct_passwords: if user_input == password: print(\"Parol to'g'ri.\") break else: print(\"Parol noto'g'ri.\")","title":"\u2705 FOR ELSE"},{"location":"python/for-loop/#break","text":"\ud83d\udccc break operatori loopni to'xtatadi. Bu operator for yoki while loopda ishlatilishi mumkin. break loopning bajarilishini to'xtatadi va loopdan chiqadi, hatto loop to'liq tugamagan bo'lsa ham. \ud83c\udfaf Ma\u2019lumotlar bazasidan kerakli foydalanuvchini topish # Foydalanuvchilar ro'yxatini lug'atlar ko'rinishida yaratdik users = [ {\"id\": 1, \"name\": \"Ali\"}, {\"id\": 2, \"name\": \"Sara\"}, {\"id\": 3, \"name\": \"Diyor\"} ] # Qidirilayotgan foydalanuvchining ID raqamini belgiladik searched_id = 2 # users ro'yxatidagi har bir element (ya'ni foydalanuvchi) bo'yicha yuramiz for user in users: # Agar foydalanuvchining 'id' qiymati qidirilayotgan id ga teng bo'lsa if user[\"id\"] == searched_id: # Foydalanuvchi topilganini ekranga chiqaramiz print(f\"Foydalanuvchi topildi: {user['name']}\") # Qolgan elementlarni tekshirishning hojati yo'q, loop ni to'xtatamiz break \ud83c\udfaf API javobidan kerakli postni topish # Postlar listini yaratdik, har bir post dictionary ko'rinishida berilgan posts = [ {\"id\": 1, \"title\": \"Salom\"}, {\"id\": 2, \"title\": \"Python haqida\"}, {\"id\": 3, \"title\": \"Xayr\"} ] # Qidirilayotgan postning sarlavhasini belgiladik search_title = \"Python haqida\" # posts listdagi har bir post bo'yicha yuramiz for post in posts: # Agar postning 'title' qiymati qidirilayotgan sarlavhaga teng bo'lsa if post[\"title\"] == search_title: # Post topilganini ekranga chiqaramiz print(\"Post topildi:\", post) # Endi qolgan postlarni tekshirishning hojati yo'q, loop ni to'xtatamiz break \ud83c\udfaf for + else bilan birga break ishlatish # Shaharlar nomlari yozilgan ro'yxat yaratildi cities = [\"Toshkent\", \"Samarqand\", \"Buxoro\", \"Xiva\"] # Qidirilayotgan shahar nomi belgilanmoqda search = \"Andijon\" # cities ro'yxatidagi har bir shahar ustida yurib chiqamiz for city in cities: # Agar ro'yxatdagi shahar nomi qidirilayotgan nomga teng bo\u2018lsa if city == search: # Ekranga topilganligi haqida xabar chiqaramiz print(\"Shahar topildi!\") # Endi boshqa shaharlarni tekshirish shart emas, loop to\u2018xtatiladi break # Agar loop oxirigacha borib chiqqan bo\u2018lsa va break ishlamagan bo\u2018lsa else: # Demak shahar ro'yxatda yo\u2018q, degan xabar chiqariladi print(\"Shahar ro'yxatda yo'q.\")","title":"\u2705 BREAK"},{"location":"python/for-loop/#continue","text":"\ud83d\udccc Python dasturlash tilida continue operatori tsikl ichida ishlatiladigan boshqaruvchi buyruq bo\u2018lib, u ishga tushganda tsikldagi shu takrorlanishning qolgan qismini o\u2018tkazib yuboradi va keyingi takrorlanishga (iteration) o\u2018tadi. # Sonlardan iborat ro'yxat yaratildi sonlar = [1, 2, 3, 4, 5] # sonlar ro'yxatidagi har bir son bo'yicha yuramiz for son in sonlar: # Agar hozirgi son 2 ga bo\u2018linganda qoldiq 0 bo\u2018lsa, ya\u2019ni juft bo\u2018lsa if son % 2 == 0: # Bu sonni tashlab o\u2018tamiz va loop keyingi son bilan davom etadi continue # Agar son toq bo\u2018lsa (ya\u2019ni yuqoridagi shart bajarilmagan bo\u2018lsa), uni chiqaramiz print(son) \ud83c\udfaf Faqat musbat sonlarni chiqarish # Musbat va manfiy sonlardan iborat ro'yxat yaratildi sonlar = [-1, 2, -3, 4, -5] # sonlar ro'yxatidagi har bir son bo'yicha yuramiz for son in sonlar: # Agar hozirgi son 0 dan kichik bo\u2018lsa, ya\u2019ni manfiy bo\u2018lsa if son < 0: # Manfiy sonni chiqarib o\u2018tib ketamiz, ya\u2019ni pastdagi qator bajarilmaydi continue # Faqat musbat sonlar (0 va undan katta) shu yerda ekranga chiqariladi print(son) \ud83c\udfaf Faqat juft indeksli mevalarni chiqarish # Mevalardan iborat ro'yxat yaratildi mevalar = ['olma', 'banan', 'apelsin', 'anjir'] # range() funksiyasi orqali indekslar bo'yicha 0 dan len(mevalar) gacha yuramiz for i in range(len(mevalar)): # Agar hozirgi indeks toq bo\u2018lsa (ya'ni 1, 3, ...) if i % 2 != 0: # Bu indeksdagi elementni o\u2018tkazib yuboramiz va loop davom etadi continue # Faqat juft indeks (0, 2, ...) dagi mevalar ekranga chiqariladi print(mevalar[i])","title":"\u2705 CONTINUE"},{"location":"python/for-loop/#pass","text":"\ud83d\udccc Python dasturlash tilida pass operatori \u2014 bu hech qanday amal bajarmaydigan buyruq. Ya\u2019ni, u bo\u2018sh kod blokini vaqtincha to\u2018ldirish uchun ishlatiladi. # 0 dan 4 gacha bo\u2018lgan sonlar ustida aylanuvchi for tsikli for son in range(5): # Agar son 3 ga teng bo\u2018lsa if son == 3: pass # Hech qanday amal bajarmaymiz, faqat kod sintaksisini saqlab qolamiz else: print(son) # Aks holda, sonni ekranga chiqaramiz \ud83c\udfaf Kod hali yozilmagan, lekin struktura tayyor bo\u2018lishi kerak def validate_user_input(): # Bu funksiya foydalanuvchi kiritgan ma'lumotni tekshiradi pass # Keyinroq bu yerga tekshirish kodi yoziladi \ud83c\udfaf Bo\u2018sh class yaratish class PaymentSystem: pass # Bu class keyin to\u2018ldiriladi \ud83c\udfaf Exception (xatolik)ni vaqtincha e'tiborga olmaslik try: x = 10 / 0 except ZeroDivisionError: pass # Hozircha xatoni ko\u2018rsatmaymiz, faqat chetlab o\u2018tamiz \ud83c\udfaf Bo\u2018sh if yoki for bloklarida sintaksis xatosidan saqlanish users = [\"admin\", \"user\", \"guest\"] for user in users: if user == \"admin\": pass # Hozircha admin uchun alohida ish yo\u2018q else: print(f\"{user} uchun oddiy xush kelibsiz\")","title":"\u2705 PASS"},{"location":"python/for-loop/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/for-loop/#1-topshiriq","text":"Foydalanuvchi kiritgan natural son uchun 1 dan shu songacha bo\u2018lgan sonlar yig\u2018indisini for loop orqali hisoblang.","title":"\u2705 1-topshiriq:"},{"location":"python/for-loop/#2-topshiriq","text":"Quyidagi ro\u2018yxatda nechta elementda eng kamida 2 ta unli harf borligini aniqlang: words = [\"apple\", \"sky\", \"queue\", \"book\", \"cry\"]","title":"\u2705 2-topshiriq:"},{"location":"python/for-loop/#3-topshiriq","text":"Ro\u2018yxatda eng katta va eng kichik sonning farqini toping: numbers = [7, 12, -3, 8, 0, 15]","title":"\u2705 3-topshiriq:"},{"location":"python/for-loop/#4-topshiriq","text":"Foydalanuvchi 10 ta son kiritadi. For loop orqali faqat musbat va toq sonlarni yangi ro\u2018yxatga yozing.","title":"\u2705 4-topshiriq:"},{"location":"python/for-loop/#5-topshiriq","text":"Quyidagi ro\u2018yxatdagi har bir so\u2018zning birinchi va oxirgi harfini birlashtirib yangi ro\u2018yxat hosil qiling: words = [\"python\", \"apple\", \"code\", \"loop\"] # natija: [\"pn\", \"ae\", \"ce\", \"lp\"]","title":"\u2705 5-topshiriq:"},{"location":"python/for-loop/#6-topshiriq","text":"Ro\u2018yxatdan faqat 3 ga va 5 ga bo\u2018linadigan sonlarni ajratib, ularning o\u2018rtacha qiymatini hisoblang: nums = [5, 9, 15, 20, 22, 30, 35]","title":"\u2705 6-topshiriq:"},{"location":"python/for-loop/#7-topshiriq","text":"Foydalanuvchi matn kiritadi. Matndagi raqamlarni topib, ularni son sifatida yig\u2018indisini hisoblang. Masalan: \"salom12dunyo3\" => natija: 15","title":"\u2705 7-topshiriq:"},{"location":"python/for-loop/#8-topshiriq","text":"Berilgan ro\u2018yxatdan elementlarning indekslari juft bo\u2018lganlarini alohida ro\u2018yxatga chiqarib bering: fruits = [\"olma\", \"banan\", \"gilos\", \"anor\", \"nok\", \"shaftoli\"]","title":"\u2705 8-topshiriq:"},{"location":"python/for-loop/#9-topshiriq","text":"Ro\u2018yxatda ketma-ket 2 marta uchraydigan elementlarni aniqlang: items = [1, 2, 2, 3, 4, 4, 4, 5] # natija: 2, 4","title":"\u2705 9-topshiriq:"},{"location":"python/for-loop/#10-topshiriq","text":"Foydalanuvchi kiritgan matndan faqat bosh harflarni ajratib, bitta string qilib chiqaring. Masalan: \"Salom DunYo\" => \"SDY\"","title":"\u2705 10-topshiriq:"},{"location":"python/for-loop/#11-topshiriq","text":"Quyidagi ro\u2018yxatdan palindrom (teskari o\u2018qilganda ham bir xil) so\u2018zlarni ajratib chiqaring: words = [\"anna\", \"python\", \"level\", \"loop\", \"radar\"]","title":"\u2705 11-topshiriq:"},{"location":"python/for-loop/#12-topshiriq","text":"for loop yordamida 100 dan kichik Fibonacci sonlarini ro\u2018yxatga yig\u2018ing.","title":"\u2705 12-topshiriq:"},{"location":"python/for-loop/#13-topshiriq","text":"Ro\u2018yxatda nechta elementda harflar soni raqamlar sonidan ko\u2018p ekanini hisoblang: elements = [\"abc123\", \"hello\", \"42\", \"py2025\", \"test\"]","title":"\u2705 13-topshiriq:"},{"location":"python/for-loop/#14-topshiriq","text":"Ro\u2018yxatdagi sonlardan har birining raqamlari yig\u2018indisini hisoblab, yangi ro\u2018yxatga joylang: nums = [12, 305, 47, 88] # natija: [3, 8, 11, 16]","title":"\u2705 14-topshiriq:"},{"location":"python/for-loop/#15-topshiriq","text":"Ro\u2018yxatdagi elementlardan faqat birinchi harfi har doim katta, qolganlari kichik bo\u2018lgan yangi ro\u2018yxat yarating: names = [\"aNVAR\", \"mUROD\", \"dILSHOD\"] # natija: [\"Anvar\", \"Murod\", \"Dilshod\"]","title":"\u2705 15-topshiriq:"},{"location":"python/functions/","text":"\ud83e\udde9 11-DARS FUNCTIONS \ud83d\udccc Python dasturlash tilida funksiya bu \u2014 kodni bir joyda yozib, ko\u2018p joylarda chaqirish, kodni tartibli va qisqa qilish uchun qulay vositadir. Funksiya yordamida kodni modullashtirish va takrorlanadigan qismni soddalashtirish mumkin. \u2705 FUNKSIYA YARATISH (DEF) def greet(): # Oddiy funksiya: salomlashish print(\"Hello, world!\") \u2705 CALLING A FUNCTION (FUNKSIYANI CHAQIRISH) \ud83d\udccc Pythonda yozilgan funksiyani ishlatish uchun uni chaqirish kerak bo\u2018ladi. Buning uchun faqat funksiyaning nomi va qavslar () yoziladi. # Bu yerda biz greet() degan nomli funksiya yaratdik def greet(): # Funksiya ichida \"Hello, world!\" degan matnni chiqaradigan buyruq bor print(\"Hello, world!\") # Bu yerda esa yuqorida yaratilgan greet() funksiyasini chaqiryapmiz greet() \u2705 PARAMETERS AND ARGUMENTS (PARAMETRLAR VA ARGUMENTLAR) \ud83d\udccc Parametr \u2013 bu funksiya yaratilyotganda yoziladigan o\u2018zgaruvchilar bo\u2018lib, ular funksiyaga ma\u2019lumot qabul qilish uchun ishlatiladi. # Funksiya yaratilyapti, u 2 ta parametr oladi: a va b def add(a, b): # a va b sonlar qo\u2018shilib, natija qaytariladi return a + b # Funksiyani chaqiryapmiz, 2 va 3 argument sifatida uzatilyapti result = add(2, 3) # Natijani chiqaramiz print(result) # Natija: 5 \ud83c\udfaf Tasavvur qilaylik, siz foydalanuvchi ma\u2019lumotlarini qabul qilib, uni ro\u2018yxatga qo\u2018shishingiz kerak. # Bo\u2018sh foydalanuvchilar ro\u2018yxati users = [] # Funksiya foydalanuvchi ma\u2019lumotlarini qabul qiladi def add_user(name, age): # name va age \u2013 bu parametrlar user = { \"name\": name, \"age\": age } users.append(user) # user ma\u2019lumoti ro\u2018yxatga qo\u2018shiladi # Funksiyani chaqiramiz, foydalanuvchi ma\u2019lumotlarini argument sifatida beramiz add_user(\"Ali\", 25) add_user(\"Laylo\", 22) # Natijada users ro\u2018yxatida 2 ta foydalanuvchi bo\u2018ladi print(users) \ud83d\udccc Argument \u2013 bu funksiyani chaqirayotganingizda beriladigan real qiymat . Parametrga haqiqiy qiymat uzatish uchun ishlatiladi. # Funksiya yaratildi. Parametr: ism def salom_ber(ism): print(f\"Salom, {ism}!\") # Funksiyani chaqirdik, argument sifatida \"Umid\" uzatildi salom_ber(\"Umid\") \ud83c\udfaf Sizda email jo\u2018natuvchi tizim bor va siz to , subject , body argumentlarini berib, email jo\u2018natasiz. # Email jo\u2018natish funksiyasi def send_email(to, subject, body): print(f\"To: {to}\") print(f\"Subject: {subject}\") print(f\"Body: {body}\") print(\"Email muvaffaqiyatli yuborildi!\") # Real loyiha \u2013 argumentlar bilan chaqirilmoqda send_email( to=\"user@example.com\", # Argument: kimga yuboriladi subject=\"Xush kelibsiz!\", # Argument: sarlavha body=\"Siz muvaffaqiyatli ro\u2018yxatdan o\u2018tdingiz.\" # Argument: matn ) \u2705 DEFAULT PARAMETERS (STANDART PARAMETRLAR) \ud83d\udccc Standart parametr \u2014 bu funksiyada oldindan belgilangan qiymatga ega bo\u2018lgan parametr. Agar funksiyani chaqirishda bu parametr uchun argument berilmasa, u default qiymatni ishlatadi. # Funksiya yaratildi, exponent parametri uchun default qiymat 2 def power(base, exponent=2): # base son exponent darajaga ko\u2018tariladi return base ** exponent # Faqat bitta argument berdik \u2013 base = 3, exponent 2 deb olinadi (default) print(power(3)) # Natija: 9 (3^2) # Ikkala argumentni ham berdik \u2013 base = 3, exponent = 3 print(power(3, 3)) # Natija: 27 (3^3) \ud83c\udfaf Sizda parol yaratish funksiyasi bor. Unga uzunlik (length) parametri beriladi, lekin foydalanuvchi kiritmasa, standart qiymat sifatida 8 belgilanadi. import random import string # Parol yaratish funksiyasi: uzunlik uchun standart qiymat 8 def generate_password(length=8): belgilar = string.ascii_letters + string.digits parol = ''.join(random.choice(belgilar) for _ in range(length)) return parol # Default uzunlik bilan chaqirish print(generate_password()) # Masalan: a7B3kL2q # Uzunlikni o\u2018zimiz beramiz print(generate_password(12)) # Masalan: jD93kLm8Tz2Q \u2705 RETURN (QIYMAT QAYTARISH) \ud83d\udccc return \u2014 bu funksiya natijasini (qiymatini) tashqariga qaytarish uchun ishlatiladi. Bu qiymatni keyin saqlash, chiqarish yoki boshqa hisob-kitoblarda ishlatish mumkin. # Funksiya: x va y ni ko\u2018paytiradi def multiply(x, y): return x * y # Natija return orqali qaytariladi # multiply(4, 5) = 20, bu qiymat product o\u2018zgaruvchisiga saqlanadi product = multiply(4, 5) # Natijani ekranga chiqaramiz print(product) # 20 \ud83c\udfaf Siz onlayn do\u2018konda mahsulotga 15% QQS solig\u2018i qo\u2018shilgan yakuniy narxni hisoblashni xohlaysiz. # Funksiya: mahsulot narxiga 15% soliq qo\u2018shadi def hisobla_qqs(narx): qqs = narx * 0.15 umumiy = narx + qqs return umumiy # Yakuniy narx qaytariladi # 100 000 so\u2018mlik mahsulot uchun yakuniy narx yakuniy_narx = hisobla_qqs(100000) print(f\"Yakuniy narx (QQS bilan): {yakuniy_narx} so'm\") \u2705 VOID FUNCTION (HECH NIMA QAYTARMAYDIGAN FUNKSIYALAR) \ud83d\udccc Void function \u2013 bu funksiya natija (qiymat) qaytarmaydi, faqat biror amalni bajaradi, masalan: ekranga chiqarish, faylga yozish, yoki ma\u2019lumot bazasiga yozish. # Funksiya: foydalanuvchini kutib oladi def print_welcome(name): print(f\"Welcome, {name}!\") # Faqat chop etadi, hech nima qaytarmaydi # Funksiyani chaqiramiz print_welcome(\"Ali\") \ud83c\udfaf Sizda har bir foydalanuvchi tizimga kirganda logga yozib boradigan funksiya kerak. Bu funksiya hech narsa qaytarmaydi \u2014 faqat faylga yozadi. # Foydalanuvchini log fayliga yozish funksiyasi def log_user_login(username): with open(\"log.txt\", \"a\") as fayl: fayl.write(f\"{username} tizimga kirdi.\\n\") # Funksiyani chaqirish log_user_login(\"Ali\") log_user_login(\"Laylo\") \u2705 VALUE-RETURNING FUNCTION (QIYMAT QAYTARADIGAN FUNKSIYALAR) \ud83d\udccc Qiymat qaytaradigan funksiya \u2014 bu funksiya return operatori yordamida natijani (qiymatni) qaytaradi. # Funksiya: ikki sonning kattasini aniqlaydi def get_maximum(a, b): if a > b: return a # Agar a katta bo\u2018lsa, a ni qaytar else: return b # Aks holda b ni qaytar # Funksiyani chaqiramiz, 7 va 10 ni argument sifatida uzatamiz max_number = get_maximum(7, 10) # Natijani chiqaramiz print(max_number) # 10 \ud83c\udfaf Siz onlayn do\u2018kon qilayapsiz va sizga mahsulotlar ichidan eng qimmatini topuvchi funksiya kerak. # Funksiya: 2 ta mahsulot narxidan eng kattasini qaytaradi def get_expensive(price1, price2): if price1 > price2: return price1 else: return price2 # Misol uchun 2 ta mahsulot narxi narx1 = 850_000 narx2 = 990_000 # Funksiyani chaqiramiz va natijani saqlaymiz eng_qimmat = get_expensive(narx1, narx2) print(f\"Eng qimmat mahsulot narxi: {eng_qimmat} so'm\") \u2705 FUNKSIYAGA RO\u2018YXAT (LIST) UZATISH \ud83d\udccc Pythonda funksiya yaratganda parametr sifatida ro\u2018yxat (list) berishimiz mumkin. Bu funksiyaga bir nechta qiymatni birdan uzatish imkonini beradi. # Funksiya: ro\u2018yxatdagi elementlarni ekranga chiqaradi def print_list(items): # Har bir element ustida aylanish (for loop) for item in items: print(item) # Ro\u2018yxat yaratamiz fruits = [\"apple\", \"banana\", \"cherry\"] # Funksiyaga ro\u2018yxatni argument sifatida uzatamiz print_list(fruits) \ud83c\udfaf Sizda Telegram bot bor va siz bir nechta foydalanuvchilarga avtomatik xabar yubormoqchisiz. Har bir foydalanuvchining ismi ro\u2018yxatda berilgan. # Funksiya: har bir foydalanuvchiga xush kelibsiz xabari yuboradi def send_welcome(users): for user in users: print(f\"Assalomu alaykum, {user}!\") # Foydalanuvchilar ro\u2018yxati user_list = [\"Ali\", \"Laylo\", \"Javohir\"] # Funksiyani chaqiramiz send_welcome(user_list) \u2705 *ARGS \ud83d\udccc *args \u2013 bu funksiya istalgancha sonli argument qabul qilishi uchun ishlatiladi. U * belgisi bilan yoziladi, va Python uni tuple sifatida saqlaydi. # Funksiya: istalgancha son qabul qilib, ularning yig\u2018indisini qaytaradi def total_sum(*args): # args bu tuple ko\u2018rinishidagi o\u2018zgaruvchi return sum(args) # Funksiyaga 5 ta son uzatdik print(total_sum(1, 2, 3, 4, 5)) # Natija: 15 \ud83c\udfaf Sizda savatdagi mahsulotlar narxini avtomatik hisoblaydigan funksiya bor. # Funksiya: mahsulot narxlarini qabul qilib, umumiy summani hisoblaydi def hisobla_savat(*narxlar): umumiy = sum(narxlar) return umumiy # Mahsulotlar: non 8000, sut 12000, guruch 25000, choy 15000 print(hisobla_savat(8000, 12000, 25000, 15000)) # Natija: 60000 \u2705 **KWARGS \ud83d\udccc kwargs \u2014 bu funksiyaga kalit-qiymat juftliklari ko\u2018rinishida istalgancha argument yuborish imkonini beradi. U lug\u2018at (dictionary) sifatida qabul qilinadi: key: value # Funksiya: foydalanuvchi profilidagi har bir kalit-qiymatni chiqaradi def print_profile(**kwargs): # kwargs \u2014 dictionary, .items() bilan kalit-qiymatlarni ajratamiz for key, value in kwargs.items(): print(f\"{key}: {value}\") # Funksiyani chaqiramiz, kalit-qiymat juftliklari bilan print_profile(name=\"Bob\", age=30, profession=\"Engineer\") \ud83c\udfaf Sizda foydalanuvchini ma\u2019lumotlar bazasiga yozish funksiyasi bor. Har bir foydalanuvchi har xil ma\u2019lumot yuborishi mumkin: faqat ism , yoki ism + yoshi , yoki hammasi. def save_user(**info): print(\"Yangi foydalanuvchi ma'lumotlari:\") for key, value in info.items(): print(f\"{key}: {value}\") print(\"\u2705 Saqlandi\\n\") # Turli foydalanuvchilar turlicha ma'lumot yuboradi save_user(name=\"Ali\", age=25) save_user(name=\"Laylo\", phone=\"998901234567\", email=\"laylo@mail.com\") \u2705 LAMBDA FUNKSIYALAR \ud83d\udccc lambda \u2014 bu bir qatorli va tez yoziladigan funksiyalardir. Odatdagi def funksiyalarga o\u2018xshaydi, lekin juda sodda va qisqa ko\u2018rinishda yoziladi. Lambda funksiyalar odatda bir martalik, oddiy amallar uchun ishlatiladi (masalan: hisoblash, filtrlash, saralash). # 1. Sonni kvadratga ko\u2018tarish (x ** 2) square = lambda x: x ** 2 print(square(6)) # 36 # 2. Ikkita sonni qo\u2018shish (x + y) add = lambda x, y: x + y print(add(3, 4)) # 7 \ud83c\udfaf Sizda bir nechta foydalanuvchi bor, ularni yosh bo\u2018yicha tartiblash kerak. Bunda lambda funksiyadan foydalanish mumkin. # Foydalanuvchilar (lug\u2018atlar ro\u2018yxati) users = [ {\"name\": \"Ali\", \"age\": 25}, {\"name\": \"Laylo\", \"age\": 20}, {\"name\": \"Javohir\", \"age\": 30}, ] # Yosh bo\u2018yicha tartiblash (lambda yordamida) sorted_users = sorted(users, key=lambda user: user[\"age\"]) # Natijani chiqaramiz for user in sorted_users: print(f\"{user['name']} - {user['age']} yosh\") \u2705 NESTED FUNCTIONS \ud83d\udccc Nested function \u2014 bu bir funksiyaning ichida boshqa funksiya yaratish demakdir. Ichki funksiya (inner) faqat tashqi funksiya (outer) ichida mavjud bo\u2018ladi va tashqaridan chaqirib bo\u2018lmaydi. Bu usul kodni modullashtirish, xavfsizroq saqlash va faqat kerakli joyda ishlatish uchun qulay. def outer(x): # Tashqi funksiya def inner(y): # Ichki funksiya return y + 2 # Ichki funksiya 2 ni qo\u2018shadi return inner(x) * 2 # Inner natijasi 2 ga ko\u2018paytiriladi result = outer(5) # (5 + 2) * 2 = 14 print(result) # 14 \ud83c\udfaf Siz foydalanuvchiga xush kelibsiz xabarini turli tillarda chiqarishni xohlaysiz. def greeting(language): def get_message(name): if language == \"uz\": return f\"Salom, {name}!\" elif language == \"en\": return f\"Hello, {name}!\" elif language == \"ru\": return f\"\u041f\u0440\u0438\u0432\u0435\u0442, {name}!\" else: return f\"Hi, {name}!\" return get_message # Ichki funksiyani qaytaramiz # O\u2018zbekcha salomlashuv funksiyasi salomlash_uz = greeting(\"uz\") print(salomlash_uz(\"Umid\")) # Salom, Umid! # Inglizcha salomlashuv funksiyasi salomlash_en = greeting(\"en\") print(salomlash_en(\"Umid\")) # Hello, Umid! \u2705 RECURSIVE FUNCTIONS \ud83d\udccc Rekursiv funksiya \u2014 bu o\u2018zini o\u2018zi ichida chaqiradigan funksiya. Bu usul, odatda takroriy (recursive) muammolarni hal qilish uchun ishlatiladi \u2014 masalan: faktorial, Fibonachchi, fayl strukturalari, daraxt ko\u2018rinishidagi ma\u2019lumotlar va hokazo. def factorial(n): # Bazaviy holat: n 0 bo\u2018lsa, 1 ni qaytar if n == 0: return 1 # Rekursiv chaqirish: n * factorial(n - 1) return n * factorial(n - 1) print(factorial(5)) # 120 \ud83c\udfaf Kompyuterdagi papkalar ichida yana papkalar bo\u2018lishi mumkin. Har bir darajadagi fayllarni hisoblash uchun rekursiya ishlatiladi (o\u2018rnatilgan os moduli orqali). import os def count_files(folder_path): total = 0 for item in os.listdir(folder_path): full_path = os.path.join(folder_path, item) if os.path.isdir(full_path): total += count_files(full_path) # Ichki papkani tekshirish else: total += 1 # Fayl topildi return total # Misol uchun: \"/home/umid/hujjatlar\" print(count_files(\"/home/umid/hujjatlar\")) \u2705 TYPE ANNOTATION \u2013 TURINI KO\u2018RSATISH \ud83d\udccc Type annotation \u2014 bu o\u2018zgaruvchilar, parametrlar va return (natija) uchun ma\u2019lumot turini ko\u2018rsatish usulidir. Bu yordamida kod ancha tushunarli bo\u2018ladi, xatolarni aniqlash osonlashadi, IDE (VS Code, PyCharm) avtomatik tekshirish qiladi. def add_numbers(a: int, b: int) -> int: # a va b butun sonlar sifatida olinadi, natija ham int bo\u2018ladi return a + b result: int = add_numbers(10, 20) print(result) # 30 \ud83c\udfaf Siz API orqali yangi foydalanuvchi yaratadigan funksiya yozmoqchisiz. Ushbu foydalanuvchining ismi, yoshi va faollik holati (True yoki False) bo\u2018lishi kerak. def create_user(name: str, age: int, active: bool) -> dict: return { \"name\": name, \"age\": age, \"active\": active } user_info: dict = create_user(\"Umid\", 25, True) print(user_info) \u2705 DOCSTRING \ud83d\udccc Docstring (documentation string) \u2014 bu funksiya, klass yoki modul nima qilishini tavsiflab beruvchi matn. U funksiyaning birinchi qatorida uchta qo\u2018shtirnoq (\"\"\") bilan yoziladi. Maqsad: Funksiya qanday ishlaydi, qanday parametrlar oladi, va nima qaytaradi \u2014 bularni tushuntirish. def multiply(a: int, b: int) -> int: \"\"\" Ikki sonni ko'paytiradi va natijani qaytaradi. :param a: birinchi son :param b: ikkinchi son :return: natija (int) \"\"\" return a * b print(multiply.__doc__) \u2705 HIGHER-ORDER FUNKSIYALAR \ud83d\udccc Higher-order function \u2014 bu boshqa funksiyani argument sifatida qabul qiladigan yoki funksiya sifatida natijada qaytaradigan funksiyadir. Pythonda funksiyalar ham \"obyekt\" bo\u2018lgani uchun, ularni o\u2018zgaruvchiga berish, funksiyaga uzatish, yoki qaytarish mumkin. # apply_twice funksiyasi boshqa funksiya (func) va qiymat (value) oladi def apply_twice(func, value): # func(value) chaqiriladi \u2192 natijasi yana func ga beriladi return func(func(value)) # increment funksiyasi bitta sonni 1 ga oshiradi def increment(x): return x + 1 # apply_twice funksiyasiga increment funksiyasi va 5 soni uzatilmoqda result = apply_twice(increment, 5) print(result) # 7 chiqadi, chunki: increment(increment(5)) \u2192 increment(6) \u2192 7 \u2705 DECORATORS \ud83d\udccc Dekorator \u2014 bu boshqa funksiyani o\u2018rab, unga qo\u2018shimcha imkoniyatlar qo\u2018shadigan higher-order funksiyadir. Asosiy funksiyani o\u2018zgartirmasdan unga funksional qo\u2018shish uchun ishlatiladi. def uppercase_decorator(func): # Ichki funksiyani yaratamiz def wrapper(): result = func() # Asosiy funksiyani chaqiramiz return result.upper() # Natijani katta harflarga o\u2018zgartiramiz return wrapper # wrapper funksiyasini qaytaramiz @uppercase_decorator def greet(): return \"hello\" print(greet()) # \"HELLO\" \ud83c\udfaf APIda foydalanuvchini tekshirish (auth) uchun dekorator # login_required \u2014 bu dekorator funksiyasi bo\u2018lib, boshqa funksiyani argument sifatida qabul qiladi def login_required(func): # Ichki wrapper funksiyasi \u2014 bu o\u2018ralgan yangi funksiya def wrapper(): # Qo\u2018shimcha amal: foydalanuvchining login holatini tekshirish imitatsiyasi print(\"\ud83d\udd10 Foydalanuvchi login bo\u2018lganligini tekshiryapmiz...\") # Asl funksiyani chaqiramiz (masalan: view_dashboard) return func() # wrapper funksiyasini qaytaramiz \u2014 ya\u2019ni dekoratsiya qilingan yangi funksiya return wrapper # Bu yerda view_dashboard funksiyasi login_required dekoratori bilan \"bezanmoqda\" # Ya'ni, view_dashboard = login_required(view_dashboard) @login_required def view_dashboard(): # Asl funksiyadagi ish: dashboard ochilishini bildiradi print(\"\ud83d\udcca Dashboard ochildi.\") # Endi bu chaqirilganda avval dekorator ishlaydi, keyin as \u2705 AMALIYOT \u2705 1-topshiriq: hello() nomli funksiya yozing, u chaqirilganda \"Assalomu alaykum!\" matnini chiqarsin. \u2705 2-topshiriq: to_square(x) funksiyasini yozing, u argument sifatida berilgan sonning kvadratini qaytarsin. \u2705 3-topshiriq: multiply(a, b) funksiyasini tuzing, u berilgan ikki sonning ko\u2018paytmasini qaytarsin. \u2705 4-topshiriq: say_hello(name) funksiyasiga ism argumenti berilganda, \"Salom, {ism}!\" ko\u2018rinishida xabar chiqaring. \u2705 5-topshiriq: power(base, exponent=2) funksiyasi uchun, exponent argumenti berilmasa, sonni kvadratga ko\u2018tarsin. \u2705 6-topshiriq: show_list(items) funksiyasiga ro\u2018yxat berilganda, har bir elementni yangi qatordan chiqarsin. \u2705 7-topshiriq: print_line() funksiyasi har chaqirilganda 40 ta \"-\" belgisi chiqarib bersin. \u2705 8-topshiriq: get_max(a, b) funksiyasi ikki sonning kattasini qaytarsin. \u2705 9-topshiriq: sum_all(*numbers) funksiyasi har qancha son qabul qilib, ularning yig\u2018indisini qaytarsin. \u2705 10-topshiriq: user_info(**kwargs) funksiyasi kalit-qiymat juftliklarini qabul qilib, har birini alohida qatordan ko\u2018rsatsin. \u2705 11-topshiriq: ages = [19, 21, 17, 25] ro\u2018yxatini lambda funksiyasi yordamida o\u2018sish tartibida sort qiling. \u2705 12-topshiriq: outer() nomli funksiya yarating, uning ichida inner() funksiyasi bo\u2018lsin va outer() chaqirilganda natija qaytarsin. \u2705 13-topshiriq: factorial(n) funksiyasini yozing, u n faktorialni hisoblab qaytarsin. \u2705 14-topshiriq: add_numbers(a: int, b: int) -> int funksiyasi yarating, natijasini chop eting. \u2705 15-topshiriq: subtract(a, b) funksiyasini yozing va unga tushuntiruvchi docstring yozing. Docstringni funksiyaning __doc__ atributi orqali chop eting.","title":"Functions"},{"location":"python/functions/#11-dars-functions","text":"\ud83d\udccc Python dasturlash tilida funksiya bu \u2014 kodni bir joyda yozib, ko\u2018p joylarda chaqirish, kodni tartibli va qisqa qilish uchun qulay vositadir. Funksiya yordamida kodni modullashtirish va takrorlanadigan qismni soddalashtirish mumkin.","title":"\ud83e\udde9 11-DARS FUNCTIONS"},{"location":"python/functions/#funksiya-yaratish-def","text":"def greet(): # Oddiy funksiya: salomlashish print(\"Hello, world!\")","title":"\u2705 FUNKSIYA YARATISH (DEF)"},{"location":"python/functions/#calling-a-function-funksiyani-chaqirish","text":"\ud83d\udccc Pythonda yozilgan funksiyani ishlatish uchun uni chaqirish kerak bo\u2018ladi. Buning uchun faqat funksiyaning nomi va qavslar () yoziladi. # Bu yerda biz greet() degan nomli funksiya yaratdik def greet(): # Funksiya ichida \"Hello, world!\" degan matnni chiqaradigan buyruq bor print(\"Hello, world!\") # Bu yerda esa yuqorida yaratilgan greet() funksiyasini chaqiryapmiz greet()","title":"\u2705 CALLING A FUNCTION (FUNKSIYANI CHAQIRISH)"},{"location":"python/functions/#parameters-and-arguments-parametrlar-va-argumentlar","text":"\ud83d\udccc Parametr \u2013 bu funksiya yaratilyotganda yoziladigan o\u2018zgaruvchilar bo\u2018lib, ular funksiyaga ma\u2019lumot qabul qilish uchun ishlatiladi. # Funksiya yaratilyapti, u 2 ta parametr oladi: a va b def add(a, b): # a va b sonlar qo\u2018shilib, natija qaytariladi return a + b # Funksiyani chaqiryapmiz, 2 va 3 argument sifatida uzatilyapti result = add(2, 3) # Natijani chiqaramiz print(result) # Natija: 5 \ud83c\udfaf Tasavvur qilaylik, siz foydalanuvchi ma\u2019lumotlarini qabul qilib, uni ro\u2018yxatga qo\u2018shishingiz kerak. # Bo\u2018sh foydalanuvchilar ro\u2018yxati users = [] # Funksiya foydalanuvchi ma\u2019lumotlarini qabul qiladi def add_user(name, age): # name va age \u2013 bu parametrlar user = { \"name\": name, \"age\": age } users.append(user) # user ma\u2019lumoti ro\u2018yxatga qo\u2018shiladi # Funksiyani chaqiramiz, foydalanuvchi ma\u2019lumotlarini argument sifatida beramiz add_user(\"Ali\", 25) add_user(\"Laylo\", 22) # Natijada users ro\u2018yxatida 2 ta foydalanuvchi bo\u2018ladi print(users) \ud83d\udccc Argument \u2013 bu funksiyani chaqirayotganingizda beriladigan real qiymat . Parametrga haqiqiy qiymat uzatish uchun ishlatiladi. # Funksiya yaratildi. Parametr: ism def salom_ber(ism): print(f\"Salom, {ism}!\") # Funksiyani chaqirdik, argument sifatida \"Umid\" uzatildi salom_ber(\"Umid\") \ud83c\udfaf Sizda email jo\u2018natuvchi tizim bor va siz to , subject , body argumentlarini berib, email jo\u2018natasiz. # Email jo\u2018natish funksiyasi def send_email(to, subject, body): print(f\"To: {to}\") print(f\"Subject: {subject}\") print(f\"Body: {body}\") print(\"Email muvaffaqiyatli yuborildi!\") # Real loyiha \u2013 argumentlar bilan chaqirilmoqda send_email( to=\"user@example.com\", # Argument: kimga yuboriladi subject=\"Xush kelibsiz!\", # Argument: sarlavha body=\"Siz muvaffaqiyatli ro\u2018yxatdan o\u2018tdingiz.\" # Argument: matn )","title":"\u2705 PARAMETERS AND ARGUMENTS (PARAMETRLAR VA ARGUMENTLAR)"},{"location":"python/functions/#default-parameters-standart-parametrlar","text":"\ud83d\udccc Standart parametr \u2014 bu funksiyada oldindan belgilangan qiymatga ega bo\u2018lgan parametr. Agar funksiyani chaqirishda bu parametr uchun argument berilmasa, u default qiymatni ishlatadi. # Funksiya yaratildi, exponent parametri uchun default qiymat 2 def power(base, exponent=2): # base son exponent darajaga ko\u2018tariladi return base ** exponent # Faqat bitta argument berdik \u2013 base = 3, exponent 2 deb olinadi (default) print(power(3)) # Natija: 9 (3^2) # Ikkala argumentni ham berdik \u2013 base = 3, exponent = 3 print(power(3, 3)) # Natija: 27 (3^3) \ud83c\udfaf Sizda parol yaratish funksiyasi bor. Unga uzunlik (length) parametri beriladi, lekin foydalanuvchi kiritmasa, standart qiymat sifatida 8 belgilanadi. import random import string # Parol yaratish funksiyasi: uzunlik uchun standart qiymat 8 def generate_password(length=8): belgilar = string.ascii_letters + string.digits parol = ''.join(random.choice(belgilar) for _ in range(length)) return parol # Default uzunlik bilan chaqirish print(generate_password()) # Masalan: a7B3kL2q # Uzunlikni o\u2018zimiz beramiz print(generate_password(12)) # Masalan: jD93kLm8Tz2Q","title":"\u2705 DEFAULT PARAMETERS (STANDART PARAMETRLAR)"},{"location":"python/functions/#return-qiymat-qaytarish","text":"\ud83d\udccc return \u2014 bu funksiya natijasini (qiymatini) tashqariga qaytarish uchun ishlatiladi. Bu qiymatni keyin saqlash, chiqarish yoki boshqa hisob-kitoblarda ishlatish mumkin. # Funksiya: x va y ni ko\u2018paytiradi def multiply(x, y): return x * y # Natija return orqali qaytariladi # multiply(4, 5) = 20, bu qiymat product o\u2018zgaruvchisiga saqlanadi product = multiply(4, 5) # Natijani ekranga chiqaramiz print(product) # 20 \ud83c\udfaf Siz onlayn do\u2018konda mahsulotga 15% QQS solig\u2018i qo\u2018shilgan yakuniy narxni hisoblashni xohlaysiz. # Funksiya: mahsulot narxiga 15% soliq qo\u2018shadi def hisobla_qqs(narx): qqs = narx * 0.15 umumiy = narx + qqs return umumiy # Yakuniy narx qaytariladi # 100 000 so\u2018mlik mahsulot uchun yakuniy narx yakuniy_narx = hisobla_qqs(100000) print(f\"Yakuniy narx (QQS bilan): {yakuniy_narx} so'm\")","title":"\u2705 RETURN (QIYMAT QAYTARISH)"},{"location":"python/functions/#void-function-hech-nima-qaytarmaydigan-funksiyalar","text":"\ud83d\udccc Void function \u2013 bu funksiya natija (qiymat) qaytarmaydi, faqat biror amalni bajaradi, masalan: ekranga chiqarish, faylga yozish, yoki ma\u2019lumot bazasiga yozish. # Funksiya: foydalanuvchini kutib oladi def print_welcome(name): print(f\"Welcome, {name}!\") # Faqat chop etadi, hech nima qaytarmaydi # Funksiyani chaqiramiz print_welcome(\"Ali\") \ud83c\udfaf Sizda har bir foydalanuvchi tizimga kirganda logga yozib boradigan funksiya kerak. Bu funksiya hech narsa qaytarmaydi \u2014 faqat faylga yozadi. # Foydalanuvchini log fayliga yozish funksiyasi def log_user_login(username): with open(\"log.txt\", \"a\") as fayl: fayl.write(f\"{username} tizimga kirdi.\\n\") # Funksiyani chaqirish log_user_login(\"Ali\") log_user_login(\"Laylo\")","title":"\u2705 VOID FUNCTION (HECH NIMA QAYTARMAYDIGAN FUNKSIYALAR)"},{"location":"python/functions/#value-returning-function-qiymat-qaytaradigan-funksiyalar","text":"\ud83d\udccc Qiymat qaytaradigan funksiya \u2014 bu funksiya return operatori yordamida natijani (qiymatni) qaytaradi. # Funksiya: ikki sonning kattasini aniqlaydi def get_maximum(a, b): if a > b: return a # Agar a katta bo\u2018lsa, a ni qaytar else: return b # Aks holda b ni qaytar # Funksiyani chaqiramiz, 7 va 10 ni argument sifatida uzatamiz max_number = get_maximum(7, 10) # Natijani chiqaramiz print(max_number) # 10 \ud83c\udfaf Siz onlayn do\u2018kon qilayapsiz va sizga mahsulotlar ichidan eng qimmatini topuvchi funksiya kerak. # Funksiya: 2 ta mahsulot narxidan eng kattasini qaytaradi def get_expensive(price1, price2): if price1 > price2: return price1 else: return price2 # Misol uchun 2 ta mahsulot narxi narx1 = 850_000 narx2 = 990_000 # Funksiyani chaqiramiz va natijani saqlaymiz eng_qimmat = get_expensive(narx1, narx2) print(f\"Eng qimmat mahsulot narxi: {eng_qimmat} so'm\")","title":"\u2705 VALUE-RETURNING FUNCTION (QIYMAT QAYTARADIGAN FUNKSIYALAR)"},{"location":"python/functions/#funksiyaga-royxat-list-uzatish","text":"\ud83d\udccc Pythonda funksiya yaratganda parametr sifatida ro\u2018yxat (list) berishimiz mumkin. Bu funksiyaga bir nechta qiymatni birdan uzatish imkonini beradi. # Funksiya: ro\u2018yxatdagi elementlarni ekranga chiqaradi def print_list(items): # Har bir element ustida aylanish (for loop) for item in items: print(item) # Ro\u2018yxat yaratamiz fruits = [\"apple\", \"banana\", \"cherry\"] # Funksiyaga ro\u2018yxatni argument sifatida uzatamiz print_list(fruits) \ud83c\udfaf Sizda Telegram bot bor va siz bir nechta foydalanuvchilarga avtomatik xabar yubormoqchisiz. Har bir foydalanuvchining ismi ro\u2018yxatda berilgan. # Funksiya: har bir foydalanuvchiga xush kelibsiz xabari yuboradi def send_welcome(users): for user in users: print(f\"Assalomu alaykum, {user}!\") # Foydalanuvchilar ro\u2018yxati user_list = [\"Ali\", \"Laylo\", \"Javohir\"] # Funksiyani chaqiramiz send_welcome(user_list)","title":"\u2705 FUNKSIYAGA RO\u2018YXAT (LIST) UZATISH"},{"location":"python/functions/#args","text":"\ud83d\udccc *args \u2013 bu funksiya istalgancha sonli argument qabul qilishi uchun ishlatiladi. U * belgisi bilan yoziladi, va Python uni tuple sifatida saqlaydi. # Funksiya: istalgancha son qabul qilib, ularning yig\u2018indisini qaytaradi def total_sum(*args): # args bu tuple ko\u2018rinishidagi o\u2018zgaruvchi return sum(args) # Funksiyaga 5 ta son uzatdik print(total_sum(1, 2, 3, 4, 5)) # Natija: 15 \ud83c\udfaf Sizda savatdagi mahsulotlar narxini avtomatik hisoblaydigan funksiya bor. # Funksiya: mahsulot narxlarini qabul qilib, umumiy summani hisoblaydi def hisobla_savat(*narxlar): umumiy = sum(narxlar) return umumiy # Mahsulotlar: non 8000, sut 12000, guruch 25000, choy 15000 print(hisobla_savat(8000, 12000, 25000, 15000)) # Natija: 60000","title":"\u2705 *ARGS"},{"location":"python/functions/#kwargs","text":"\ud83d\udccc kwargs \u2014 bu funksiyaga kalit-qiymat juftliklari ko\u2018rinishida istalgancha argument yuborish imkonini beradi. U lug\u2018at (dictionary) sifatida qabul qilinadi: key: value # Funksiya: foydalanuvchi profilidagi har bir kalit-qiymatni chiqaradi def print_profile(**kwargs): # kwargs \u2014 dictionary, .items() bilan kalit-qiymatlarni ajratamiz for key, value in kwargs.items(): print(f\"{key}: {value}\") # Funksiyani chaqiramiz, kalit-qiymat juftliklari bilan print_profile(name=\"Bob\", age=30, profession=\"Engineer\") \ud83c\udfaf Sizda foydalanuvchini ma\u2019lumotlar bazasiga yozish funksiyasi bor. Har bir foydalanuvchi har xil ma\u2019lumot yuborishi mumkin: faqat ism , yoki ism + yoshi , yoki hammasi. def save_user(**info): print(\"Yangi foydalanuvchi ma'lumotlari:\") for key, value in info.items(): print(f\"{key}: {value}\") print(\"\u2705 Saqlandi\\n\") # Turli foydalanuvchilar turlicha ma'lumot yuboradi save_user(name=\"Ali\", age=25) save_user(name=\"Laylo\", phone=\"998901234567\", email=\"laylo@mail.com\")","title":"\u2705 **KWARGS"},{"location":"python/functions/#lambda-funksiyalar","text":"\ud83d\udccc lambda \u2014 bu bir qatorli va tez yoziladigan funksiyalardir. Odatdagi def funksiyalarga o\u2018xshaydi, lekin juda sodda va qisqa ko\u2018rinishda yoziladi. Lambda funksiyalar odatda bir martalik, oddiy amallar uchun ishlatiladi (masalan: hisoblash, filtrlash, saralash). # 1. Sonni kvadratga ko\u2018tarish (x ** 2) square = lambda x: x ** 2 print(square(6)) # 36 # 2. Ikkita sonni qo\u2018shish (x + y) add = lambda x, y: x + y print(add(3, 4)) # 7 \ud83c\udfaf Sizda bir nechta foydalanuvchi bor, ularni yosh bo\u2018yicha tartiblash kerak. Bunda lambda funksiyadan foydalanish mumkin. # Foydalanuvchilar (lug\u2018atlar ro\u2018yxati) users = [ {\"name\": \"Ali\", \"age\": 25}, {\"name\": \"Laylo\", \"age\": 20}, {\"name\": \"Javohir\", \"age\": 30}, ] # Yosh bo\u2018yicha tartiblash (lambda yordamida) sorted_users = sorted(users, key=lambda user: user[\"age\"]) # Natijani chiqaramiz for user in sorted_users: print(f\"{user['name']} - {user['age']} yosh\")","title":"\u2705 LAMBDA FUNKSIYALAR"},{"location":"python/functions/#nested-functions","text":"\ud83d\udccc Nested function \u2014 bu bir funksiyaning ichida boshqa funksiya yaratish demakdir. Ichki funksiya (inner) faqat tashqi funksiya (outer) ichida mavjud bo\u2018ladi va tashqaridan chaqirib bo\u2018lmaydi. Bu usul kodni modullashtirish, xavfsizroq saqlash va faqat kerakli joyda ishlatish uchun qulay. def outer(x): # Tashqi funksiya def inner(y): # Ichki funksiya return y + 2 # Ichki funksiya 2 ni qo\u2018shadi return inner(x) * 2 # Inner natijasi 2 ga ko\u2018paytiriladi result = outer(5) # (5 + 2) * 2 = 14 print(result) # 14 \ud83c\udfaf Siz foydalanuvchiga xush kelibsiz xabarini turli tillarda chiqarishni xohlaysiz. def greeting(language): def get_message(name): if language == \"uz\": return f\"Salom, {name}!\" elif language == \"en\": return f\"Hello, {name}!\" elif language == \"ru\": return f\"\u041f\u0440\u0438\u0432\u0435\u0442, {name}!\" else: return f\"Hi, {name}!\" return get_message # Ichki funksiyani qaytaramiz # O\u2018zbekcha salomlashuv funksiyasi salomlash_uz = greeting(\"uz\") print(salomlash_uz(\"Umid\")) # Salom, Umid! # Inglizcha salomlashuv funksiyasi salomlash_en = greeting(\"en\") print(salomlash_en(\"Umid\")) # Hello, Umid!","title":"\u2705 NESTED FUNCTIONS"},{"location":"python/functions/#recursive-functions","text":"\ud83d\udccc Rekursiv funksiya \u2014 bu o\u2018zini o\u2018zi ichida chaqiradigan funksiya. Bu usul, odatda takroriy (recursive) muammolarni hal qilish uchun ishlatiladi \u2014 masalan: faktorial, Fibonachchi, fayl strukturalari, daraxt ko\u2018rinishidagi ma\u2019lumotlar va hokazo. def factorial(n): # Bazaviy holat: n 0 bo\u2018lsa, 1 ni qaytar if n == 0: return 1 # Rekursiv chaqirish: n * factorial(n - 1) return n * factorial(n - 1) print(factorial(5)) # 120 \ud83c\udfaf Kompyuterdagi papkalar ichida yana papkalar bo\u2018lishi mumkin. Har bir darajadagi fayllarni hisoblash uchun rekursiya ishlatiladi (o\u2018rnatilgan os moduli orqali). import os def count_files(folder_path): total = 0 for item in os.listdir(folder_path): full_path = os.path.join(folder_path, item) if os.path.isdir(full_path): total += count_files(full_path) # Ichki papkani tekshirish else: total += 1 # Fayl topildi return total # Misol uchun: \"/home/umid/hujjatlar\" print(count_files(\"/home/umid/hujjatlar\"))","title":"\u2705 RECURSIVE FUNCTIONS"},{"location":"python/functions/#type-annotation-turini-korsatish","text":"\ud83d\udccc Type annotation \u2014 bu o\u2018zgaruvchilar, parametrlar va return (natija) uchun ma\u2019lumot turini ko\u2018rsatish usulidir. Bu yordamida kod ancha tushunarli bo\u2018ladi, xatolarni aniqlash osonlashadi, IDE (VS Code, PyCharm) avtomatik tekshirish qiladi. def add_numbers(a: int, b: int) -> int: # a va b butun sonlar sifatida olinadi, natija ham int bo\u2018ladi return a + b result: int = add_numbers(10, 20) print(result) # 30 \ud83c\udfaf Siz API orqali yangi foydalanuvchi yaratadigan funksiya yozmoqchisiz. Ushbu foydalanuvchining ismi, yoshi va faollik holati (True yoki False) bo\u2018lishi kerak. def create_user(name: str, age: int, active: bool) -> dict: return { \"name\": name, \"age\": age, \"active\": active } user_info: dict = create_user(\"Umid\", 25, True) print(user_info)","title":"\u2705 TYPE ANNOTATION \u2013 TURINI KO\u2018RSATISH"},{"location":"python/functions/#docstring","text":"\ud83d\udccc Docstring (documentation string) \u2014 bu funksiya, klass yoki modul nima qilishini tavsiflab beruvchi matn. U funksiyaning birinchi qatorida uchta qo\u2018shtirnoq (\"\"\") bilan yoziladi. Maqsad: Funksiya qanday ishlaydi, qanday parametrlar oladi, va nima qaytaradi \u2014 bularni tushuntirish. def multiply(a: int, b: int) -> int: \"\"\" Ikki sonni ko'paytiradi va natijani qaytaradi. :param a: birinchi son :param b: ikkinchi son :return: natija (int) \"\"\" return a * b print(multiply.__doc__)","title":"\u2705 DOCSTRING"},{"location":"python/functions/#higher-order-funksiyalar","text":"\ud83d\udccc Higher-order function \u2014 bu boshqa funksiyani argument sifatida qabul qiladigan yoki funksiya sifatida natijada qaytaradigan funksiyadir. Pythonda funksiyalar ham \"obyekt\" bo\u2018lgani uchun, ularni o\u2018zgaruvchiga berish, funksiyaga uzatish, yoki qaytarish mumkin. # apply_twice funksiyasi boshqa funksiya (func) va qiymat (value) oladi def apply_twice(func, value): # func(value) chaqiriladi \u2192 natijasi yana func ga beriladi return func(func(value)) # increment funksiyasi bitta sonni 1 ga oshiradi def increment(x): return x + 1 # apply_twice funksiyasiga increment funksiyasi va 5 soni uzatilmoqda result = apply_twice(increment, 5) print(result) # 7 chiqadi, chunki: increment(increment(5)) \u2192 increment(6) \u2192 7","title":"\u2705 HIGHER-ORDER FUNKSIYALAR"},{"location":"python/functions/#decorators","text":"\ud83d\udccc Dekorator \u2014 bu boshqa funksiyani o\u2018rab, unga qo\u2018shimcha imkoniyatlar qo\u2018shadigan higher-order funksiyadir. Asosiy funksiyani o\u2018zgartirmasdan unga funksional qo\u2018shish uchun ishlatiladi. def uppercase_decorator(func): # Ichki funksiyani yaratamiz def wrapper(): result = func() # Asosiy funksiyani chaqiramiz return result.upper() # Natijani katta harflarga o\u2018zgartiramiz return wrapper # wrapper funksiyasini qaytaramiz @uppercase_decorator def greet(): return \"hello\" print(greet()) # \"HELLO\" \ud83c\udfaf APIda foydalanuvchini tekshirish (auth) uchun dekorator # login_required \u2014 bu dekorator funksiyasi bo\u2018lib, boshqa funksiyani argument sifatida qabul qiladi def login_required(func): # Ichki wrapper funksiyasi \u2014 bu o\u2018ralgan yangi funksiya def wrapper(): # Qo\u2018shimcha amal: foydalanuvchining login holatini tekshirish imitatsiyasi print(\"\ud83d\udd10 Foydalanuvchi login bo\u2018lganligini tekshiryapmiz...\") # Asl funksiyani chaqiramiz (masalan: view_dashboard) return func() # wrapper funksiyasini qaytaramiz \u2014 ya\u2019ni dekoratsiya qilingan yangi funksiya return wrapper # Bu yerda view_dashboard funksiyasi login_required dekoratori bilan \"bezanmoqda\" # Ya'ni, view_dashboard = login_required(view_dashboard) @login_required def view_dashboard(): # Asl funksiyadagi ish: dashboard ochilishini bildiradi print(\"\ud83d\udcca Dashboard ochildi.\") # Endi bu chaqirilganda avval dekorator ishlaydi, keyin as","title":"\u2705 DECORATORS"},{"location":"python/functions/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/functions/#1-topshiriq","text":"hello() nomli funksiya yozing, u chaqirilganda \"Assalomu alaykum!\" matnini chiqarsin.","title":"\u2705 1-topshiriq:"},{"location":"python/functions/#2-topshiriq","text":"to_square(x) funksiyasini yozing, u argument sifatida berilgan sonning kvadratini qaytarsin.","title":"\u2705 2-topshiriq:"},{"location":"python/functions/#3-topshiriq","text":"multiply(a, b) funksiyasini tuzing, u berilgan ikki sonning ko\u2018paytmasini qaytarsin.","title":"\u2705 3-topshiriq:"},{"location":"python/functions/#4-topshiriq","text":"say_hello(name) funksiyasiga ism argumenti berilganda, \"Salom, {ism}!\" ko\u2018rinishida xabar chiqaring.","title":"\u2705 4-topshiriq:"},{"location":"python/functions/#5-topshiriq","text":"power(base, exponent=2) funksiyasi uchun, exponent argumenti berilmasa, sonni kvadratga ko\u2018tarsin.","title":"\u2705 5-topshiriq:"},{"location":"python/functions/#6-topshiriq","text":"show_list(items) funksiyasiga ro\u2018yxat berilganda, har bir elementni yangi qatordan chiqarsin.","title":"\u2705 6-topshiriq:"},{"location":"python/functions/#7-topshiriq","text":"print_line() funksiyasi har chaqirilganda 40 ta \"-\" belgisi chiqarib bersin.","title":"\u2705 7-topshiriq:"},{"location":"python/functions/#8-topshiriq","text":"get_max(a, b) funksiyasi ikki sonning kattasini qaytarsin.","title":"\u2705 8-topshiriq:"},{"location":"python/functions/#9-topshiriq","text":"sum_all(*numbers) funksiyasi har qancha son qabul qilib, ularning yig\u2018indisini qaytarsin.","title":"\u2705 9-topshiriq:"},{"location":"python/functions/#10-topshiriq","text":"user_info(**kwargs) funksiyasi kalit-qiymat juftliklarini qabul qilib, har birini alohida qatordan ko\u2018rsatsin.","title":"\u2705 10-topshiriq:"},{"location":"python/functions/#11-topshiriq","text":"ages = [19, 21, 17, 25] ro\u2018yxatini lambda funksiyasi yordamida o\u2018sish tartibida sort qiling.","title":"\u2705 11-topshiriq:"},{"location":"python/functions/#12-topshiriq","text":"outer() nomli funksiya yarating, uning ichida inner() funksiyasi bo\u2018lsin va outer() chaqirilganda natija qaytarsin.","title":"\u2705 12-topshiriq:"},{"location":"python/functions/#13-topshiriq","text":"factorial(n) funksiyasini yozing, u n faktorialni hisoblab qaytarsin.","title":"\u2705 13-topshiriq:"},{"location":"python/functions/#14-topshiriq","text":"add_numbers(a: int, b: int) -> int funksiyasi yarating, natijasini chop eting.","title":"\u2705 14-topshiriq:"},{"location":"python/functions/#15-topshiriq","text":"subtract(a, b) funksiyasini yozing va unga tushuntiruvchi docstring yozing. Docstringni funksiyaning __doc__ atributi orqali chop eting.","title":"\u2705 15-topshiriq:"},{"location":"python/lists/","text":"\ud83e\udde9 4-DARS LISTS \u2705 PYTHONDA LISTSLAR BILAN ISHLASH \ud83d\udccc LIST \u2014 bu bir nechta ma'lumotlarni bitta o\u2018zgaruvchida navbatma-navbat saqlash uchun ishlatiladigan ma'lumot turi. \u2705 LISTNING ASOSIY XUSUSIYATLARI \u2733\ufe0f Bir nechta qiymatni bitta joyda saqlaydi \u2733\ufe0f Har bir qiymatning tartib raqami (index) bo\u2018ladi (0 dan boshlanadi) \u2733\ufe0f Istalgan turdagi ma\u2019lumotlar (son, matn, True/False) saqlanishi mumkin \u2733\ufe0f O\u2018zgartirish mumkin (ya'ni listdagi ma\u2019lumotlarni qo\u2018shish, o\u2018chirish, almashtirish mumkin) \u2705 QACHON ISHLATILADI? \u2733\ufe0f Ko\u2018p sonli ma\u2019lumotlarni tartib bilan saqlash kerak bo\u2018lsa \u2733\ufe0f Ma\u2019lumotlar ustida takrorlash, filtrlash, yoki saralash kerak bo\u2018lsa \u2733\ufe0f Bir nechta qiymatni bitta o\u2018zgaruvchida saqlash orqali kodni soddalashtirish kerak bo\u2018lsa \u2705 LIST YARATISH # Bir nechta elementli list my_list = [10, \"DeepCode\", True, 3.14] # Bo\u2018sh list empty_list = [] \u2705 LIST ELEMENTLARIGA MUROJAT QILISH \u2733\ufe0f INDEX ORQALI MUROJAT QILISH \ud83d\udccc Listdagi har bir element o\u2018zining indeks raqami bilan tartiblanadi. Pythonda indekslash 0 dan boshlanadi. # Mevalar ro'yxatini yaratamiz fruits = ['olma', 'banan', 'gilos', 'shaftoli'] # Ro'yxatdagi birinchi elementni (0-indeks) ekranga chiqaramiz print(fruits[0]) # 'olma' # Ro'yxatdagi uchinchi elementni (2-indeks) ekranga chiqaramiz print(fruits[2]) # 'gilos' \u2733\ufe0f NEGATIVE INDEXING \ud83d\udccc Pythonda oxirgi elementga manfiy indekslar yordamida murojaat qilinadi. # Mevalar ro'yxatini yaratamiz fruits = ['olma', 'banan', 'gilos', 'shaftoli'] # Ro'yxatdagi oxirgi elementni (manfiy indeks -1) ekranga chiqaramiz print(fruits[-1]) # 'shaftoli' # Ro'yxatdagi oxiridan ikkinchi elementni (manfiy indeks -2) ekranga chiqaramiz print(fruits[-2]) # 'gilos' \u2733\ufe0f SLICING \ud83d\udccc Listning ma\u2019lum qismini olish uchun slicing ishlatiladi: list[start:stop] # Mevalar ro'yxatini yaratamiz fruits = ['olma', 'banan', 'gilos', 'shaftoli'] # Indeks 1 dan boshlab 3 gacha bo'lgan elementlarni olish (3-indeks kirmaydi) print(fruits[1:3]) # ['banan', 'gilos'] # Boshlanishi avtomatik 0 deb olinadi, 0 dan 2 gacha bo'lgan elementlar (2-indeks kirmaydi) print(fruits[:2]) # ['olma', 'banan'] # Indeks 2 dan boshlab oxirigacha bo'lgan elementlarni olish print(fruits[2:]) # ['gilos', 'shaftoli'] \u2733\ufe0f SLICING WITH STEP # Mevalar ro'yxatini yaratamiz fruits = ['olma', 'banan', 'gilos', 'shaftoli'] # Har 2-elementdan birini olamiz: 0, 2-indeksdagilar (ya'ni 1-element, 3-element) print(fruits[::2]) # ['olma', 'gilos'] # Ro'yxatni teskari tartibda chiqaramiz print(fruits[::-1]) # ['shaftoli', 'gilos', 'banan', 'olma'] \u2705 LISTDAGI E'LEMENTLAR SONINI TOPISH \ud83d\udcccList uzunligi degani \u2014 list ichida nechta element (ya'ni qiymat) borligini bildiradi. Pythonda bu uzunlikni len() funksiyasi yordamida topamiz. # Bu yerda bizda 5 ta kompaniya bor companies = ['Google', 'Microsoft', 'Amazon', 'Tesla', 'Apple'] # len(companies) \u2014 bu companies listida nechta element borligini hisoblaydi print(len(companies)) \u2705 LISTGA E'LEMENT QO'SHISH \u2733\ufe0f .append(x) \ud83d\udccc list oxiriga bitta element qo\u2018shadi. # Dastlab avtomobillar ro'yxatini yaratamiz cars = ['Nexia', 'Cobalt'] # Ro'yxat oxiriga yangi element 'Malibu' ni qo\u2018shamiz cars.append('Malibu') # Yangilangan ro'yxatni ekranga chiqaramiz print(cars) # ['Nexia', 'Cobalt', 'Malibu'] \ud83d\udccc .append() faqat bitta element qo\u2018shadi. Agar bir nechta element qo\u2018shmoqchi bo\u2018lsangiz, ularni list ko\u2018rinishida beriladi va list ichiga yana bir list qo\u2018shiladi: # Dastlab 3 ta sondan iborat ro'yxat yaratamiz my_list = [1, 2, 3] # Ro'yxat oxiriga [4, 5] ro'yxatini bitta element sifatida qo\u2018shamiz (ichki ro'yxat bo'ladi) my_list.append([4, 5]) # Natijaviy ro'yxatni ekranga chiqaramiz print(my_list) # [1, 2, 3, [4, 5]] \u2733\ufe0f .extend() \ud83d\udccc bir nechta elementni alohida-alohida qo\u2018shadi. # Boshlang'ich ro'yxat: 1, 2, 3 sonlari mavjud my_list = [1, 2, 3] # extend() metodi orqali [4, 5] ro'yxatining elementlarini alohida-alohida qo\u2018shamiz my_list.extend([4, 5]) # Natijaviy ro'yxatni chiqaramiz print(\"extend() natijasi:\", my_list) # Bu ro'yxatning elementlarini alohida qo'shadi \u2733\ufe0f .insert(i, x) \ud83d\udccc list ichidagi istalgan joyga bitta element qo\u2018shadi # Dastlab 1, 2, 3 sonlaridan iborat ro'yxat yaratamiz my_list = [1, 2, 3] # 2-pozitsiyaga (ya'ni 3-element o'rniga) 99 sonini qo\u2018shamiz my_list.insert(2, 99) # Natijaviy ro'yxatni ekranga chiqaramiz print(my_list) # [1, 2, 99, 3] \u2733\ufe0f += \ud83d\udccc listga boshqa listni qo\u2018shadi # Boshlang'ich ro'yxat: 1, 2, 3 my_list = [1, 2, 3] # += operatori yordamida [4, 5] ro'yxatini my_list ga kengaytiramiz (xuddi extend() kabi ishlaydi) my_list += [4, 5] # Natijaviy ro'yxatni chiqaramiz print(my_list) # [1, 2, 3, 4, 5] \u2705 E'LEMENTLARNI O'CHIRISH \u2733\ufe0f .remove(x) \ud83d\udccc list ichida siz ko\u2018rsatgan qiymatga teng bo\u2018lgan birinchi elementni o\u2018chiradi. # Dastlabki list: bir nechta sonlar mavjud, jumladan ikki marta 3 soni my_list = [1, 2, 3, 4, 3, 5] # remove() metodi listdan **birinchi uchragan** 3 ni o'chiradi my_list.remove(3) # Yangilangan listni ekranga chiqaramiz print(my_list) # [1, 2, 4, 3, 5] \u2733\ufe0f .pop() \ud83d\udccc Agar .pop() funksiyasiga hech narsa bermasangiz, oxirgi elementni o\u2018chiradi. # Dastlabki ro'yxatni yaratamiz my_list = [10, 20, 30, 40, 50] # pop() metodi ro'yxatning oxirgi elementini (50) o'chirib tashlaydi my_list.pop() # Yangilangan ro'yxatni ekranga chiqaramiz print(my_list) # [10, 20, 30, 40] \u2733\ufe0f .pop(i) \ud83d\udccc Aniq indexdagi elementni o\u2018chiradi # Boshlang'ich ro'yxat: 10, 20, 30, 40 my_list = [10, 20, 30, 40] # pop(1) metodi ro'yxatdagi 1-indeksdagi elementni (ya'ni 20 ni) o'chiradi my_list.pop(1) # Yangilangan ro'yxatni ekranga chiqaramiz print(my_list) # [10, 30, 40] \u2733\ufe0f del \ud83d\udccc Istalgan element yoki butun listni o\u2018chiradi # Boshlang'ich ro'yxat: 4 ta harf mavjud my_list = ['a', 'b', 'c', 'd'] # del operatori yordamida ro'yxatdagi 2-indeksdagi element ('c') ni o\u2018chiramiz del my_list[2] # Ro'yxat yangilanadi: endi ['a', 'b', 'd'] bo'ladi print(\"1-element o\u2018chirilgan ro\u2018yhat:\", my_list) # ['a', 'b', 'd'] # Ro'yxatni qaytadan yaratamiz my_list = ['a', 'b', 'c', 'd'] # del operatori yordamida butun ro'yxatni (ya'ni my_list o'zgaruvchisini) o\u2018chiramiz del my_list # Bu yerda my_list endi mavjud emas, agar pastda print(my_list) desangiz \u2014 xatolik (NameError) chiqadi # print(my_list) # \u274c NameError: name 'my_list' is not defined \u2705 LISTNI TOZALASH \ud83d\udccc Agar list ichidagi hamma elementlarni o\u2018chirib, uni bo\u2018sh holatga keltirmoqchi bo\u2018lsangiz, .clear() metodidan foydalaniladi. # Boshlang'ich ro'yxat: 1 dan 5 gacha sonlar mavjud my_list = [1, 2, 3, 4, 5] # clear() metodi ro'yxatdagi barcha elementlarni o\u2018chiradi (lekin ro'yxatning o\u2018zi qoladi, bo\u2018sh holatda) my_list.clear() # Bo\u2018sh ro'yxatni ekranga chiqaramiz print(my_list) # [] \u2705 LISTNI SARALASH \ud83d\udccc Python dasturlash tilida listdagi elementlarni tartiblash uchun ikkita asosiy vosita mavjud: .sort() metodi va sorted() funksiyasi. Ularning ikkalasi ham listni tartiblash uchun ishlatiladi, lekin ular orasida muhim farqlar bor. Tartiblashda raqamlar o'sib borish tartibida, matnlar esa alifbo tartibida tartiblanadi. \u2733\ufe0f .sort() \ud83d\udccc .sort() \u2014 bu listning o\u2018ziga tegishli metod bo\u2018lib, u faqat listlar bilan ishlaydi. Agar siz .sort() metodini ishlatsangiz, u listning o\u2018zini tartiblaydi, ya\u2019ni listdagi e'lementlar joyida o\u2018zgaradi. Boshqacha aytganda, bu metod listni o\u2018zgartiradi va tartiblangan yangi list yaratmaydi. Misol uchun, sizda bir list bo\u2018lsa va .sort() desangiz, o\u2018sha list tartiblanadi va avvalgi tartibi yo\u2018qoladi. Shuning uchun, agar sizga asl list kerak bo\u2018lsa, .sort() ni ishlatishdan oldin ehtiyot bo\u2018lish kerak, chunki u listni butunlay o\u2018zgartirib yuboradi. Bu metod hech qanday natija qaytarmaydi, ya\u2019ni None degan qiymatni qaytaradi. # Boshlang'ich ro'yxat: aralash tartibda sonlar mavjud my_list = [3, 1, 4, 1, 5, 9, 2] # sort() metodi ro'yxatni o'sish tartibida (kichikdan kattaga) saralaydi my_list.sort() # Tartiblangan ro'yxatni ekranga chiqaramiz print(my_list) # [1, 1, 2, 3, 4, 5, 9] \u2733\ufe0f .sorted() \ud83d\udccc sorted() esa funksiyadir. Bu funksiya faqat list emas, balki boshqa turdagi ma\u2019lumotlar bilan ham ishlay oladi \u2014 masalan, string , tuple va boshqa tartiblangan ma\u2019lumot turlari bilan. sorted() funksiyasining eng katta afzalligi \u2014 u mavjud listni o\u2018zgartirmaydi. U asl listga tegmaydi, balki yangi tartiblangan listni qaytaradi. Bu esa sizga asl ma\u2019lumotni saqlab qolgan holda, tartiblangan nusxasi bilan ishlash imkonini beradi. Agar sizga vaqtincha tartiblangan natija kerak bo\u2018lsa yoki original listni o\u2018zgartirmasdan ishlashni xohlasangiz, sorted() funksiyasi aynan sizga mos keladi. # Boshlang'ich ro'yxat: aralash tartibdagi sonlar my_list = [3, 1, 4, 1, 5, 9] # sorted() funksiyasi yangi tartiblangan ro'yxat yaratadi, asl ro'yxat o'zgarmaydi sorted_list = sorted(my_list) # Yangi (saralangan) ro'yxatni chiqaramiz print(\"Yangi ro\u2018yxat:\", sorted_list) # [1, 1, 3, 4, 5, 9] # Asl ro'yxat o'zgarishsiz qolganini ko'rsatamiz print(\"Asl ro\u2018yxat:\", my_list) # [3, 1, 4, 1, 5, 9] \u2705 TESKARI TARTIBDA SARALASH \u2733\ufe0f .sort(reverse=True) # Boshlang'ich list: aralash sonlar mavjud my_list = [3, 1, 4, 1, 5, 9] # sort() metodi orqali listni kamayish tartibida tartiblaymiz my_list.sort(reverse=True) # Tartiblangan listni ekranga chiqaramiz print(my_list) # [9, 5, 4, 3, 1, 1] \u2733\ufe0f sorted(..., reverse=True) # Boshlang'ich list: aralash sonlar mavjud my_list = [3, 1, 4, 1, 5, 9] # sorted() funksiyasi listni kamayish tartibida tartiblaydi va yangi list qaytaradi sorted_list = sorted(my_list, reverse=True) # Teskari tartiblangan yangi listni chiqaramiz print(\"Teskari list:\", sorted_list) # [9, 5, 4, 3, 1, 1] \u2705 QO'SHIMCHA PARAMETR \u2733\ufe0f KEY # Ismlar listi: har xil uzunlikdagi so'zlardan iborat names = ['Ali', 'Muhammad', 'Zafar', 'Islom'] # sort() metodi va key=len parametri yordamida listni so'z uzunligi bo'yicha o'sish tartibida saralaymiz names.sort(key=len) # Saralangan listni chiqaramiz print(names) # ['Ali', 'Zafar', 'Islom', 'Muhammad'] \u2705 LISTNI TESKARIGA O'ZGARTIRISH \u2733\ufe0f .reverse() \ud83d\udccc Ba'zida ro\u2018yxatdagi elementlarni teskari tartibda ko\u2018rsatish kerak bo\u2018ladi \u2014 ya'ni oxirgi element birinchi, birinchi element esa oxirgi bo\u2018ladi. # Boshlang'ich list: 1 dan 5 gacha bo'lgan sonlar my_list = [1, 2, 3, 4, 5] # reverse() metodi list elementlarini teskari tartibda joylashtiradi my_list.reverse() # Teskari tartibga keltirilgan listni ekranga chiqaramiz print(my_list) # [5, 4, 3, 2, 1] \u2705 LISTNI BIRLASHTIRISH \u2733\ufe0f + \ud83d\udccc Bu usulda ikkita listni qo\u2018shib, yangi bitta list hosil qilamiz. # 1-chi list list1 = [1, 2, 3] # 2-chi list list2 = [4, 5, 6] # + operatori yordamida ikkala listni birlashtiramiz merged_list = list1 + list2 # Yangi birlashtirilgan listni chiqaramiz print(merged_list) # [1, 2, 3, 4, 5, 6] \u2733\ufe0f += \ud83d\udccc Bu usulda ikkinchi list elementlari birinchi listga qo\u2018shiladi va birinchi ro\u2018yxat o\u2018zgartiriladi. # 1-chi list list1 = [1, 2, 3] # 2-chi list list2 = [4, 5, 6] # += operatori list2 dagi elementlarni list1 ga alohida-alohida qo\u2018shadi list1 += list2 # Natijaviy list1 ni ekranga chiqaramiz print(list1) # [1, 2, 3, 4, 5, 6] \u2733\ufe0f .extend() # 1-chi list list1 = [1, 2, 3] # 2-chi list list2 = [4, 5, 6] # extend() metodi list2 dagi barcha elementlarni list1 ga alohida-alohida qo\u2018shadi list1.extend(list2) # Natijaviy list1 ni ekranga chiqaramiz print(list1) # [1, 2, 3, 4, 5, 6] \u2705 MULTI DEMENSIONAL LIST \ud83d\udccc Pythonda list ichiga yana boshqa list joylash mumkin. Bu holat multi dimensional list deb ataladi (inglizchasiga o\u2018xshab \"2D list\" ham deyiladi). # Bu multi-dimensional list (ya'ni list of lists) \u2014 har bir element o'z ichida yana bir list saqlaydi multi_dimensional_list = [ [1, 2, 3], # 0-index: birinchi inner list [4, 5, 6], # 1-index: ikkinchi inner list [7, 8, 9] # 2-index: uchinchi inner list ] \u2733\ufe0f E'LEMENTLARGA MUROJAT QILISH Ro'yxat ichidagi ro'yxatdagi elementlarga indekslar yordamida murojaat qilish mumkin. # List of lists (ya'ni list ichidagi list) multi_dimensional_list = [ [1, 2, 3], # 0-index: birinchi inner list [4, 5, 6], # 1-index: ikkinchi inner list [7, 8, 9] # 2-index: uchinchi inner list ] # Faqat bitta row'ni (masalan: 1-chi row) chiqaramiz print(\"1-chi row:\", matrix[1]) # [4, 5, 6] # Endi shu row ichidan bitta elementni chiqaramiz (masalan: 2-chi element) print(\"1-chi rowdagi 2-chi element:\", matrix[1][1]) # 5 \u2733\ufe0f E'LEMENT QO'SHISH # List of lists (multi-dimensional list) multi_dimensional_list = [ [1, 2, 3], # 0-index: birinchi ichki list (row) [4, 5, 6], # 1-index: ikkinchi ichki list (row) [7, 8, 9] # 2-index: uchinchi ichki list (row) ] # append() metodi yordamida butun bir yangi ichki list (row) qo\u2018shiladi multi_dimensional_list.append([10, 11, 12]) # Yangi list'ni ekranga chiqaramiz print(multi_dimensional_list) \u2733\ufe0f E'LEMENT O'ZGARTIRISH # Boshlang'ich list of lists (multi-dimensional list) multi_dimensional_list = [ [1, 2, 3], # 0-index [4, 5, 6], # 1-index [7, 8, 9] # 2-index ] # 0-indexdagi ichki listni yangisi bilan almashtiramiz multi_dimensional_list[0] = [13, 14, 15] # Natijani chiqaramiz print(multi_dimensional_list) \u2733\ufe0f ICHKI E'LEMENTNI O'ZGARTIRISH # Multi-dimensional list (list ichida listlar) multi_dimensional_list = [ [1, 2, 3], # 0-index row [4, 5, 6], # 1-index row [7, 8, 9] # 2-index row ] # 1-index row (ya'ni [4, 5, 6]) dagi 1-index elementni (ya'ni 5) 99 bilan almashtiramiz multi_dimensional_list[1][1] = 99 # Natijani chiqaramiz print(multi_dimensional_list) \u2705 RO'YHATDA E'LEMENT BORLIGINI TEKSHIRISH \ud83d\udccc Pythonda list ichida ma\u2019lum bir e'lement bor yoki yo\u2018qligini tekshirish uchun in operatoridan foydalaniladi. # Oddiy list my_list = [1, 2, 3, 4, 5] # 3 elementi my_list ichida mavjudmi? \u2192 Ha, shuning uchun natija: True print(3 in my_list) # True # 6 elementi my_list ichida mavjudmi? \u2192 Yo\u2018q, shuning uchun natija: False print(6 in my_list) # False \u2705 QO'SHIMCHA FUNKSIYALAR Python dasturlash tilida ro'yxatlar bilan ishlashda quyidagi funksiyalar yordamida ro'yxatdagi elementlarni qo'shish , maksimal va minimal qiymatlarni topish mumkin: \u2733\ufe0f sum() \ud83d\udccc listdagi sonlar yig\u2018indisini hisoblaydi # Oddiy sonlardan iborat list my_list = [10, 20, 30, 40, 50] # sum() funksiyasi listdagi barcha elementlarning yig'indisini hisoblaydi sum_of_list = sum(my_list) # Natijani chiqaramiz print(f\"Ro'yxatdagi elementlar yig'indisi: {sum_of_list}\") \u2733\ufe0f max() \ud83d\udccc Listdagi eng katta qiymatni qaytaradi. # Sonlardan iborat list my_list = [10, 20, 30, 40, 50] # max() funksiyasi listdagi eng katta qiymatni qaytaradi max_value = max(my_list) # Natijani ekranga chiqaramiz print(f\"Ro'yxatdagi eng katta qiymat: {max_value}\") \u2733\ufe0f min() \ud83d\udccc Listdagi eng kichik qiymatni qaytaradi. # Sonlardan iborat list my_list = [10, 20, 30, 40, 50] # min() funksiyasi listdagi eng kichik qiymatni qaytaradi min_value = min(my_list) # Natijani ekranga chiqaramiz print(f\"Ro'yxatdagi eng kichik qiymat: {min_value}\") \u2705 range() \ud83d\udccc Bu funktsiya yordamida biz ma'lum oraliqdagi sonlar ketma-ketligini yaratishimiz mumkin. list() funktsiyasi yordamida esa bu oraliqni ro'yxat shaklida saqlab olamiz: # 0 dan 9 gacha bo\u2018lgan sonlar ro\u2018yhatini yaratamiz sonlar = list(range(0, 10)) # Natijani ekranga chiqaramiz print(sonlar) [!CAUTION] range(a, b) funksiyasi doim a dan boshlanadi, b dan bitta oldin to\u2018xtaydi. \u2733\ufe0f STEP # 0 dan 20 gacha (20 kirmaydi), har 2 qadam bilan \u2014 juft sonlar juft_sonlar = list(range(0, 20, 2)) # 1 dan 20 gacha (20 kirmaydi), har 2 qadam bilan \u2014 toq sonlar toq_sonlar = list(range(1, 20, 2)) # Juft sonlarni ekranga chiqaramiz print(\"Juft sonlar: \", juft_sonlar) # Toq sonlarni ekranga chiqaramiz print(\"Toq sonlar: \", toq_sonlar) [!NOTE] Agar siz 0 dan boshlamoqchi bo\u2018lsangiz, range(10) deb yozish yetarli: NEGATIVE STEP \ud83d\udccc Agar siz kamayib boruvchi sonlar ketma-ketligini istasangiz, step qiymatini manfiy qiling: # 10 dan 1 gacha kamayuvchi sonlar ro'yxatini yaratamiz kamayuvchi = list(range(10, 0, -1)) # Natijani ekranga chiqaramiz print(kamayuvchi) \u2705 AMALIYOT \u2705 1-topshiriq: Ro'yxat yaratish va elementga murojaat qilish Quyidagi elementlarga ega bo\u2018lgan ro'yxatni yarating: 'olma' , 'banan' , 'gilos' , 'xurmo' , 'anjir' . Ro'yxatning ikkinchi va to\u2018rtinchi elementlarini terminalga chiqaring. \u2705 2-topshiriq: Ro'yxatni o\u2018zgartirish 1 dan 5 gacha bo\u2018lgan sonlar ro'yxatini yarating. Ro'yxatdagi uchinchi elementni 10 ga almashtiring va natijani chiqaring. \u2705 3-topshiriq: Element qo\u2018shish va o\u2018chirish Bo\u2018sh ro'yxat yarating. Ro'yxatga 'dog' , 'cat' , 'chicken' elementlarini qo\u2018shing. 'cat' elementini o\u2018chirib, ro'yxatni chiqaring. \u2705 4-topshiriq: Ro'yxat uzunligini topish Ro'yxat: 'red' , 'green' , 'blue' , 'yellow' , 'purple' . Ro'yxatning uzunligini hisoblab, terminalga chiqaring. \u2705 5-topshiriq: Ro'yxatlarni birlashtirish Ikkita ro'yxat yarating: - ['a', 'b', 'c'] - ['d', 'e', 'f'] Ularni birlashtirib, yangi ro'yxatni terminalga chiqaring. \u2705 6-topshiriq: Element mavjudligini tekshirish Ro'yxat: ['mashina', 'avtobus', 'velosiped', 'poyezd'] 'avtobus' ro'yxatda bormi? Tekshirib natijani ( True yoki False ) chiqaring. \u2705 7-topshiriq: Ro'yxatni saralash Ro'yxat: [3, 1, 4, 2, 5] O'sish tartibida saralang va natijani chiqaring. \u2705 8-topshiriq: Teskari tartibda chiqarish Ro'yxat: [10, 20, 30, 40, 50] .reverse() metodi yordamida ro'yxatni teskari chiqarish. \u2705 9-topshiriq: Ro'yxatni tozalash Ro'yxat: ['kitob', 'qalam', 'daftar', 'sumka'] .clear() yordamida barcha elementlarni o\u2018chirib, natijani chiqaring. \u2705 10-topshiriq: Ro'yxatni ko\u2018paytirish Ro'yxat: [1, 2, 3] Ro'yxatni 4 marta ko\u2018paytirib, yangi ro'yxatni terminalga chiqaring. \u2705 11-topshiriq: Minimal va maksimal qiymatni topish Ro'yxat: [25, 17, 9, 50, 33] min() va max() funksiyalari yordamida eng kichik va eng katta qiymatlarni toping. \u2705 12-topshiriq: Ro'yxatni nusxalash Ro'yxat: [100, 200, 300, 400, 500] Nusxa ko\u2018chiring ( copy() ) va yangi ro'yxatni chiqarib ko\u2018rsating. \u2705 13-topshiriq: Ro'yxatdagi elementlar yig\u2018indisi Ro'yxat: [2, 4, 6, 8, 10] sum() funksiyasi orqali yig\u2018indini hisoblang va natijani chiqaring. \u2705 14-topshiriq: Slicing va step ishlatish Ro'yxat: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Har ikkinchi elementni ajratib olib, yangi ro'yxat hosil qiling. \u2705 15-topshiriq: Multi-dimensional listdan element olish Ro'yxat: [[1, 2], [3, 4], [5, 6]] Ikkinchi ichki ro'yxatdagi ikkinchi elementni ( 4 ) terminalga chiqaring.","title":"Lists"},{"location":"python/lists/#4-dars-lists","text":"","title":"\ud83e\udde9 4-DARS LISTS"},{"location":"python/lists/#pythonda-listslar-bilan-ishlash","text":"\ud83d\udccc LIST \u2014 bu bir nechta ma'lumotlarni bitta o\u2018zgaruvchida navbatma-navbat saqlash uchun ishlatiladigan ma'lumot turi.","title":"\u2705 PYTHONDA LISTSLAR BILAN ISHLASH"},{"location":"python/lists/#listning-asosiy-xususiyatlari","text":"\u2733\ufe0f Bir nechta qiymatni bitta joyda saqlaydi \u2733\ufe0f Har bir qiymatning tartib raqami (index) bo\u2018ladi (0 dan boshlanadi) \u2733\ufe0f Istalgan turdagi ma\u2019lumotlar (son, matn, True/False) saqlanishi mumkin \u2733\ufe0f O\u2018zgartirish mumkin (ya'ni listdagi ma\u2019lumotlarni qo\u2018shish, o\u2018chirish, almashtirish mumkin)","title":"\u2705 LISTNING ASOSIY XUSUSIYATLARI"},{"location":"python/lists/#qachon-ishlatiladi","text":"\u2733\ufe0f Ko\u2018p sonli ma\u2019lumotlarni tartib bilan saqlash kerak bo\u2018lsa \u2733\ufe0f Ma\u2019lumotlar ustida takrorlash, filtrlash, yoki saralash kerak bo\u2018lsa \u2733\ufe0f Bir nechta qiymatni bitta o\u2018zgaruvchida saqlash orqali kodni soddalashtirish kerak bo\u2018lsa","title":"\u2705 QACHON ISHLATILADI?"},{"location":"python/lists/#list-yaratish","text":"# Bir nechta elementli list my_list = [10, \"DeepCode\", True, 3.14] # Bo\u2018sh list empty_list = []","title":"\u2705 LIST YARATISH"},{"location":"python/lists/#list-elementlariga-murojat-qilish","text":"","title":"\u2705 LIST ELEMENTLARIGA MUROJAT QILISH"},{"location":"python/lists/#index-orqali-murojat-qilish","text":"\ud83d\udccc Listdagi har bir element o\u2018zining indeks raqami bilan tartiblanadi. Pythonda indekslash 0 dan boshlanadi. # Mevalar ro'yxatini yaratamiz fruits = ['olma', 'banan', 'gilos', 'shaftoli'] # Ro'yxatdagi birinchi elementni (0-indeks) ekranga chiqaramiz print(fruits[0]) # 'olma' # Ro'yxatdagi uchinchi elementni (2-indeks) ekranga chiqaramiz print(fruits[2]) # 'gilos'","title":"\u2733\ufe0f INDEX ORQALI MUROJAT QILISH"},{"location":"python/lists/#negative-indexing","text":"\ud83d\udccc Pythonda oxirgi elementga manfiy indekslar yordamida murojaat qilinadi. # Mevalar ro'yxatini yaratamiz fruits = ['olma', 'banan', 'gilos', 'shaftoli'] # Ro'yxatdagi oxirgi elementni (manfiy indeks -1) ekranga chiqaramiz print(fruits[-1]) # 'shaftoli' # Ro'yxatdagi oxiridan ikkinchi elementni (manfiy indeks -2) ekranga chiqaramiz print(fruits[-2]) # 'gilos'","title":"\u2733\ufe0f NEGATIVE INDEXING"},{"location":"python/lists/#slicing","text":"\ud83d\udccc Listning ma\u2019lum qismini olish uchun slicing ishlatiladi: list[start:stop] # Mevalar ro'yxatini yaratamiz fruits = ['olma', 'banan', 'gilos', 'shaftoli'] # Indeks 1 dan boshlab 3 gacha bo'lgan elementlarni olish (3-indeks kirmaydi) print(fruits[1:3]) # ['banan', 'gilos'] # Boshlanishi avtomatik 0 deb olinadi, 0 dan 2 gacha bo'lgan elementlar (2-indeks kirmaydi) print(fruits[:2]) # ['olma', 'banan'] # Indeks 2 dan boshlab oxirigacha bo'lgan elementlarni olish print(fruits[2:]) # ['gilos', 'shaftoli']","title":"\u2733\ufe0f SLICING"},{"location":"python/lists/#slicing-with-step","text":"# Mevalar ro'yxatini yaratamiz fruits = ['olma', 'banan', 'gilos', 'shaftoli'] # Har 2-elementdan birini olamiz: 0, 2-indeksdagilar (ya'ni 1-element, 3-element) print(fruits[::2]) # ['olma', 'gilos'] # Ro'yxatni teskari tartibda chiqaramiz print(fruits[::-1]) # ['shaftoli', 'gilos', 'banan', 'olma']","title":"\u2733\ufe0f SLICING WITH STEP"},{"location":"python/lists/#listdagi-elementlar-sonini-topish","text":"\ud83d\udcccList uzunligi degani \u2014 list ichida nechta element (ya'ni qiymat) borligini bildiradi. Pythonda bu uzunlikni len() funksiyasi yordamida topamiz. # Bu yerda bizda 5 ta kompaniya bor companies = ['Google', 'Microsoft', 'Amazon', 'Tesla', 'Apple'] # len(companies) \u2014 bu companies listida nechta element borligini hisoblaydi print(len(companies))","title":"\u2705 LISTDAGI E'LEMENTLAR SONINI TOPISH"},{"location":"python/lists/#listga-element-qoshish","text":"","title":"\u2705 LISTGA E'LEMENT QO'SHISH"},{"location":"python/lists/#appendx","text":"\ud83d\udccc list oxiriga bitta element qo\u2018shadi. # Dastlab avtomobillar ro'yxatini yaratamiz cars = ['Nexia', 'Cobalt'] # Ro'yxat oxiriga yangi element 'Malibu' ni qo\u2018shamiz cars.append('Malibu') # Yangilangan ro'yxatni ekranga chiqaramiz print(cars) # ['Nexia', 'Cobalt', 'Malibu'] \ud83d\udccc .append() faqat bitta element qo\u2018shadi. Agar bir nechta element qo\u2018shmoqchi bo\u2018lsangiz, ularni list ko\u2018rinishida beriladi va list ichiga yana bir list qo\u2018shiladi: # Dastlab 3 ta sondan iborat ro'yxat yaratamiz my_list = [1, 2, 3] # Ro'yxat oxiriga [4, 5] ro'yxatini bitta element sifatida qo\u2018shamiz (ichki ro'yxat bo'ladi) my_list.append([4, 5]) # Natijaviy ro'yxatni ekranga chiqaramiz print(my_list) # [1, 2, 3, [4, 5]]","title":"\u2733\ufe0f .append(x)"},{"location":"python/lists/#extend","text":"\ud83d\udccc bir nechta elementni alohida-alohida qo\u2018shadi. # Boshlang'ich ro'yxat: 1, 2, 3 sonlari mavjud my_list = [1, 2, 3] # extend() metodi orqali [4, 5] ro'yxatining elementlarini alohida-alohida qo\u2018shamiz my_list.extend([4, 5]) # Natijaviy ro'yxatni chiqaramiz print(\"extend() natijasi:\", my_list) # Bu ro'yxatning elementlarini alohida qo'shadi","title":"\u2733\ufe0f .extend()"},{"location":"python/lists/#inserti-x","text":"\ud83d\udccc list ichidagi istalgan joyga bitta element qo\u2018shadi # Dastlab 1, 2, 3 sonlaridan iborat ro'yxat yaratamiz my_list = [1, 2, 3] # 2-pozitsiyaga (ya'ni 3-element o'rniga) 99 sonini qo\u2018shamiz my_list.insert(2, 99) # Natijaviy ro'yxatni ekranga chiqaramiz print(my_list) # [1, 2, 99, 3]","title":"\u2733\ufe0f .insert(i, x)"},{"location":"python/lists/#_1","text":"\ud83d\udccc listga boshqa listni qo\u2018shadi # Boshlang'ich ro'yxat: 1, 2, 3 my_list = [1, 2, 3] # += operatori yordamida [4, 5] ro'yxatini my_list ga kengaytiramiz (xuddi extend() kabi ishlaydi) my_list += [4, 5] # Natijaviy ro'yxatni chiqaramiz print(my_list) # [1, 2, 3, 4, 5]","title":"\u2733\ufe0f +="},{"location":"python/lists/#elementlarni-ochirish","text":"","title":"\u2705 E'LEMENTLARNI O'CHIRISH"},{"location":"python/lists/#removex","text":"\ud83d\udccc list ichida siz ko\u2018rsatgan qiymatga teng bo\u2018lgan birinchi elementni o\u2018chiradi. # Dastlabki list: bir nechta sonlar mavjud, jumladan ikki marta 3 soni my_list = [1, 2, 3, 4, 3, 5] # remove() metodi listdan **birinchi uchragan** 3 ni o'chiradi my_list.remove(3) # Yangilangan listni ekranga chiqaramiz print(my_list) # [1, 2, 4, 3, 5]","title":"\u2733\ufe0f .remove(x)"},{"location":"python/lists/#pop","text":"\ud83d\udccc Agar .pop() funksiyasiga hech narsa bermasangiz, oxirgi elementni o\u2018chiradi. # Dastlabki ro'yxatni yaratamiz my_list = [10, 20, 30, 40, 50] # pop() metodi ro'yxatning oxirgi elementini (50) o'chirib tashlaydi my_list.pop() # Yangilangan ro'yxatni ekranga chiqaramiz print(my_list) # [10, 20, 30, 40]","title":"\u2733\ufe0f .pop()"},{"location":"python/lists/#popi","text":"\ud83d\udccc Aniq indexdagi elementni o\u2018chiradi # Boshlang'ich ro'yxat: 10, 20, 30, 40 my_list = [10, 20, 30, 40] # pop(1) metodi ro'yxatdagi 1-indeksdagi elementni (ya'ni 20 ni) o'chiradi my_list.pop(1) # Yangilangan ro'yxatni ekranga chiqaramiz print(my_list) # [10, 30, 40]","title":"\u2733\ufe0f .pop(i)"},{"location":"python/lists/#del","text":"\ud83d\udccc Istalgan element yoki butun listni o\u2018chiradi # Boshlang'ich ro'yxat: 4 ta harf mavjud my_list = ['a', 'b', 'c', 'd'] # del operatori yordamida ro'yxatdagi 2-indeksdagi element ('c') ni o\u2018chiramiz del my_list[2] # Ro'yxat yangilanadi: endi ['a', 'b', 'd'] bo'ladi print(\"1-element o\u2018chirilgan ro\u2018yhat:\", my_list) # ['a', 'b', 'd'] # Ro'yxatni qaytadan yaratamiz my_list = ['a', 'b', 'c', 'd'] # del operatori yordamida butun ro'yxatni (ya'ni my_list o'zgaruvchisini) o\u2018chiramiz del my_list # Bu yerda my_list endi mavjud emas, agar pastda print(my_list) desangiz \u2014 xatolik (NameError) chiqadi # print(my_list) # \u274c NameError: name 'my_list' is not defined","title":"\u2733\ufe0f del"},{"location":"python/lists/#listni-tozalash","text":"\ud83d\udccc Agar list ichidagi hamma elementlarni o\u2018chirib, uni bo\u2018sh holatga keltirmoqchi bo\u2018lsangiz, .clear() metodidan foydalaniladi. # Boshlang'ich ro'yxat: 1 dan 5 gacha sonlar mavjud my_list = [1, 2, 3, 4, 5] # clear() metodi ro'yxatdagi barcha elementlarni o\u2018chiradi (lekin ro'yxatning o\u2018zi qoladi, bo\u2018sh holatda) my_list.clear() # Bo\u2018sh ro'yxatni ekranga chiqaramiz print(my_list) # []","title":"\u2705 LISTNI TOZALASH"},{"location":"python/lists/#listni-saralash","text":"\ud83d\udccc Python dasturlash tilida listdagi elementlarni tartiblash uchun ikkita asosiy vosita mavjud: .sort() metodi va sorted() funksiyasi. Ularning ikkalasi ham listni tartiblash uchun ishlatiladi, lekin ular orasida muhim farqlar bor. Tartiblashda raqamlar o'sib borish tartibida, matnlar esa alifbo tartibida tartiblanadi.","title":"\u2705 LISTNI SARALASH"},{"location":"python/lists/#sort","text":"\ud83d\udccc .sort() \u2014 bu listning o\u2018ziga tegishli metod bo\u2018lib, u faqat listlar bilan ishlaydi. Agar siz .sort() metodini ishlatsangiz, u listning o\u2018zini tartiblaydi, ya\u2019ni listdagi e'lementlar joyida o\u2018zgaradi. Boshqacha aytganda, bu metod listni o\u2018zgartiradi va tartiblangan yangi list yaratmaydi. Misol uchun, sizda bir list bo\u2018lsa va .sort() desangiz, o\u2018sha list tartiblanadi va avvalgi tartibi yo\u2018qoladi. Shuning uchun, agar sizga asl list kerak bo\u2018lsa, .sort() ni ishlatishdan oldin ehtiyot bo\u2018lish kerak, chunki u listni butunlay o\u2018zgartirib yuboradi. Bu metod hech qanday natija qaytarmaydi, ya\u2019ni None degan qiymatni qaytaradi. # Boshlang'ich ro'yxat: aralash tartibda sonlar mavjud my_list = [3, 1, 4, 1, 5, 9, 2] # sort() metodi ro'yxatni o'sish tartibida (kichikdan kattaga) saralaydi my_list.sort() # Tartiblangan ro'yxatni ekranga chiqaramiz print(my_list) # [1, 1, 2, 3, 4, 5, 9]","title":"\u2733\ufe0f .sort()"},{"location":"python/lists/#sorted","text":"\ud83d\udccc sorted() esa funksiyadir. Bu funksiya faqat list emas, balki boshqa turdagi ma\u2019lumotlar bilan ham ishlay oladi \u2014 masalan, string , tuple va boshqa tartiblangan ma\u2019lumot turlari bilan. sorted() funksiyasining eng katta afzalligi \u2014 u mavjud listni o\u2018zgartirmaydi. U asl listga tegmaydi, balki yangi tartiblangan listni qaytaradi. Bu esa sizga asl ma\u2019lumotni saqlab qolgan holda, tartiblangan nusxasi bilan ishlash imkonini beradi. Agar sizga vaqtincha tartiblangan natija kerak bo\u2018lsa yoki original listni o\u2018zgartirmasdan ishlashni xohlasangiz, sorted() funksiyasi aynan sizga mos keladi. # Boshlang'ich ro'yxat: aralash tartibdagi sonlar my_list = [3, 1, 4, 1, 5, 9] # sorted() funksiyasi yangi tartiblangan ro'yxat yaratadi, asl ro'yxat o'zgarmaydi sorted_list = sorted(my_list) # Yangi (saralangan) ro'yxatni chiqaramiz print(\"Yangi ro\u2018yxat:\", sorted_list) # [1, 1, 3, 4, 5, 9] # Asl ro'yxat o'zgarishsiz qolganini ko'rsatamiz print(\"Asl ro\u2018yxat:\", my_list) # [3, 1, 4, 1, 5, 9]","title":"\u2733\ufe0f .sorted()"},{"location":"python/lists/#teskari-tartibda-saralash","text":"","title":"\u2705 TESKARI TARTIBDA SARALASH"},{"location":"python/lists/#sortreversetrue","text":"# Boshlang'ich list: aralash sonlar mavjud my_list = [3, 1, 4, 1, 5, 9] # sort() metodi orqali listni kamayish tartibida tartiblaymiz my_list.sort(reverse=True) # Tartiblangan listni ekranga chiqaramiz print(my_list) # [9, 5, 4, 3, 1, 1]","title":"\u2733\ufe0f .sort(reverse=True)"},{"location":"python/lists/#sorted-reversetrue","text":"# Boshlang'ich list: aralash sonlar mavjud my_list = [3, 1, 4, 1, 5, 9] # sorted() funksiyasi listni kamayish tartibida tartiblaydi va yangi list qaytaradi sorted_list = sorted(my_list, reverse=True) # Teskari tartiblangan yangi listni chiqaramiz print(\"Teskari list:\", sorted_list) # [9, 5, 4, 3, 1, 1]","title":"\u2733\ufe0f sorted(..., reverse=True)"},{"location":"python/lists/#qoshimcha-parametr","text":"","title":"\u2705 QO'SHIMCHA PARAMETR"},{"location":"python/lists/#key","text":"# Ismlar listi: har xil uzunlikdagi so'zlardan iborat names = ['Ali', 'Muhammad', 'Zafar', 'Islom'] # sort() metodi va key=len parametri yordamida listni so'z uzunligi bo'yicha o'sish tartibida saralaymiz names.sort(key=len) # Saralangan listni chiqaramiz print(names) # ['Ali', 'Zafar', 'Islom', 'Muhammad']","title":"\u2733\ufe0f KEY"},{"location":"python/lists/#listni-teskariga-ozgartirish","text":"","title":"\u2705 LISTNI TESKARIGA O'ZGARTIRISH"},{"location":"python/lists/#reverse","text":"\ud83d\udccc Ba'zida ro\u2018yxatdagi elementlarni teskari tartibda ko\u2018rsatish kerak bo\u2018ladi \u2014 ya'ni oxirgi element birinchi, birinchi element esa oxirgi bo\u2018ladi. # Boshlang'ich list: 1 dan 5 gacha bo'lgan sonlar my_list = [1, 2, 3, 4, 5] # reverse() metodi list elementlarini teskari tartibda joylashtiradi my_list.reverse() # Teskari tartibga keltirilgan listni ekranga chiqaramiz print(my_list) # [5, 4, 3, 2, 1]","title":"\u2733\ufe0f .reverse()"},{"location":"python/lists/#listni-birlashtirish","text":"","title":"\u2705 LISTNI BIRLASHTIRISH"},{"location":"python/lists/#_2","text":"\ud83d\udccc Bu usulda ikkita listni qo\u2018shib, yangi bitta list hosil qilamiz. # 1-chi list list1 = [1, 2, 3] # 2-chi list list2 = [4, 5, 6] # + operatori yordamida ikkala listni birlashtiramiz merged_list = list1 + list2 # Yangi birlashtirilgan listni chiqaramiz print(merged_list) # [1, 2, 3, 4, 5, 6]","title":"\u2733\ufe0f +"},{"location":"python/lists/#_3","text":"\ud83d\udccc Bu usulda ikkinchi list elementlari birinchi listga qo\u2018shiladi va birinchi ro\u2018yxat o\u2018zgartiriladi. # 1-chi list list1 = [1, 2, 3] # 2-chi list list2 = [4, 5, 6] # += operatori list2 dagi elementlarni list1 ga alohida-alohida qo\u2018shadi list1 += list2 # Natijaviy list1 ni ekranga chiqaramiz print(list1) # [1, 2, 3, 4, 5, 6]","title":"\u2733\ufe0f +="},{"location":"python/lists/#extend_1","text":"# 1-chi list list1 = [1, 2, 3] # 2-chi list list2 = [4, 5, 6] # extend() metodi list2 dagi barcha elementlarni list1 ga alohida-alohida qo\u2018shadi list1.extend(list2) # Natijaviy list1 ni ekranga chiqaramiz print(list1) # [1, 2, 3, 4, 5, 6]","title":"\u2733\ufe0f .extend()"},{"location":"python/lists/#multi-demensional-list","text":"\ud83d\udccc Pythonda list ichiga yana boshqa list joylash mumkin. Bu holat multi dimensional list deb ataladi (inglizchasiga o\u2018xshab \"2D list\" ham deyiladi). # Bu multi-dimensional list (ya'ni list of lists) \u2014 har bir element o'z ichida yana bir list saqlaydi multi_dimensional_list = [ [1, 2, 3], # 0-index: birinchi inner list [4, 5, 6], # 1-index: ikkinchi inner list [7, 8, 9] # 2-index: uchinchi inner list ]","title":"\u2705 MULTI DEMENSIONAL LIST"},{"location":"python/lists/#elementlarga-murojat-qilish","text":"Ro'yxat ichidagi ro'yxatdagi elementlarga indekslar yordamida murojaat qilish mumkin. # List of lists (ya'ni list ichidagi list) multi_dimensional_list = [ [1, 2, 3], # 0-index: birinchi inner list [4, 5, 6], # 1-index: ikkinchi inner list [7, 8, 9] # 2-index: uchinchi inner list ] # Faqat bitta row'ni (masalan: 1-chi row) chiqaramiz print(\"1-chi row:\", matrix[1]) # [4, 5, 6] # Endi shu row ichidan bitta elementni chiqaramiz (masalan: 2-chi element) print(\"1-chi rowdagi 2-chi element:\", matrix[1][1]) # 5","title":"\u2733\ufe0f E'LEMENTLARGA MUROJAT QILISH"},{"location":"python/lists/#element-qoshish","text":"# List of lists (multi-dimensional list) multi_dimensional_list = [ [1, 2, 3], # 0-index: birinchi ichki list (row) [4, 5, 6], # 1-index: ikkinchi ichki list (row) [7, 8, 9] # 2-index: uchinchi ichki list (row) ] # append() metodi yordamida butun bir yangi ichki list (row) qo\u2018shiladi multi_dimensional_list.append([10, 11, 12]) # Yangi list'ni ekranga chiqaramiz print(multi_dimensional_list)","title":"\u2733\ufe0f E'LEMENT QO'SHISH"},{"location":"python/lists/#element-ozgartirish","text":"# Boshlang'ich list of lists (multi-dimensional list) multi_dimensional_list = [ [1, 2, 3], # 0-index [4, 5, 6], # 1-index [7, 8, 9] # 2-index ] # 0-indexdagi ichki listni yangisi bilan almashtiramiz multi_dimensional_list[0] = [13, 14, 15] # Natijani chiqaramiz print(multi_dimensional_list)","title":"\u2733\ufe0f E'LEMENT O'ZGARTIRISH"},{"location":"python/lists/#ichki-elementni-ozgartirish","text":"# Multi-dimensional list (list ichida listlar) multi_dimensional_list = [ [1, 2, 3], # 0-index row [4, 5, 6], # 1-index row [7, 8, 9] # 2-index row ] # 1-index row (ya'ni [4, 5, 6]) dagi 1-index elementni (ya'ni 5) 99 bilan almashtiramiz multi_dimensional_list[1][1] = 99 # Natijani chiqaramiz print(multi_dimensional_list)","title":"\u2733\ufe0f ICHKI E'LEMENTNI O'ZGARTIRISH"},{"location":"python/lists/#royhatda-element-borligini-tekshirish","text":"\ud83d\udccc Pythonda list ichida ma\u2019lum bir e'lement bor yoki yo\u2018qligini tekshirish uchun in operatoridan foydalaniladi. # Oddiy list my_list = [1, 2, 3, 4, 5] # 3 elementi my_list ichida mavjudmi? \u2192 Ha, shuning uchun natija: True print(3 in my_list) # True # 6 elementi my_list ichida mavjudmi? \u2192 Yo\u2018q, shuning uchun natija: False print(6 in my_list) # False","title":"\u2705 RO'YHATDA E'LEMENT BORLIGINI TEKSHIRISH"},{"location":"python/lists/#qoshimcha-funksiyalar","text":"Python dasturlash tilida ro'yxatlar bilan ishlashda quyidagi funksiyalar yordamida ro'yxatdagi elementlarni qo'shish , maksimal va minimal qiymatlarni topish mumkin:","title":"\u2705 QO'SHIMCHA FUNKSIYALAR"},{"location":"python/lists/#sum","text":"\ud83d\udccc listdagi sonlar yig\u2018indisini hisoblaydi # Oddiy sonlardan iborat list my_list = [10, 20, 30, 40, 50] # sum() funksiyasi listdagi barcha elementlarning yig'indisini hisoblaydi sum_of_list = sum(my_list) # Natijani chiqaramiz print(f\"Ro'yxatdagi elementlar yig'indisi: {sum_of_list}\")","title":"\u2733\ufe0f sum()"},{"location":"python/lists/#max","text":"\ud83d\udccc Listdagi eng katta qiymatni qaytaradi. # Sonlardan iborat list my_list = [10, 20, 30, 40, 50] # max() funksiyasi listdagi eng katta qiymatni qaytaradi max_value = max(my_list) # Natijani ekranga chiqaramiz print(f\"Ro'yxatdagi eng katta qiymat: {max_value}\")","title":"\u2733\ufe0f max()"},{"location":"python/lists/#min","text":"\ud83d\udccc Listdagi eng kichik qiymatni qaytaradi. # Sonlardan iborat list my_list = [10, 20, 30, 40, 50] # min() funksiyasi listdagi eng kichik qiymatni qaytaradi min_value = min(my_list) # Natijani ekranga chiqaramiz print(f\"Ro'yxatdagi eng kichik qiymat: {min_value}\")","title":"\u2733\ufe0f min()"},{"location":"python/lists/#range","text":"\ud83d\udccc Bu funktsiya yordamida biz ma'lum oraliqdagi sonlar ketma-ketligini yaratishimiz mumkin. list() funktsiyasi yordamida esa bu oraliqni ro'yxat shaklida saqlab olamiz: # 0 dan 9 gacha bo\u2018lgan sonlar ro\u2018yhatini yaratamiz sonlar = list(range(0, 10)) # Natijani ekranga chiqaramiz print(sonlar) [!CAUTION] range(a, b) funksiyasi doim a dan boshlanadi, b dan bitta oldin to\u2018xtaydi.","title":"\u2705 range()"},{"location":"python/lists/#step","text":"# 0 dan 20 gacha (20 kirmaydi), har 2 qadam bilan \u2014 juft sonlar juft_sonlar = list(range(0, 20, 2)) # 1 dan 20 gacha (20 kirmaydi), har 2 qadam bilan \u2014 toq sonlar toq_sonlar = list(range(1, 20, 2)) # Juft sonlarni ekranga chiqaramiz print(\"Juft sonlar: \", juft_sonlar) # Toq sonlarni ekranga chiqaramiz print(\"Toq sonlar: \", toq_sonlar) [!NOTE] Agar siz 0 dan boshlamoqchi bo\u2018lsangiz, range(10) deb yozish yetarli:","title":"\u2733\ufe0f STEP"},{"location":"python/lists/#negative-step","text":"\ud83d\udccc Agar siz kamayib boruvchi sonlar ketma-ketligini istasangiz, step qiymatini manfiy qiling: # 10 dan 1 gacha kamayuvchi sonlar ro'yxatini yaratamiz kamayuvchi = list(range(10, 0, -1)) # Natijani ekranga chiqaramiz print(kamayuvchi)","title":"NEGATIVE STEP"},{"location":"python/lists/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/lists/#1-topshiriq-royxat-yaratish-va-elementga-murojaat-qilish","text":"Quyidagi elementlarga ega bo\u2018lgan ro'yxatni yarating: 'olma' , 'banan' , 'gilos' , 'xurmo' , 'anjir' . Ro'yxatning ikkinchi va to\u2018rtinchi elementlarini terminalga chiqaring.","title":"\u2705 1-topshiriq: Ro'yxat yaratish va elementga murojaat qilish"},{"location":"python/lists/#2-topshiriq-royxatni-ozgartirish","text":"1 dan 5 gacha bo\u2018lgan sonlar ro'yxatini yarating. Ro'yxatdagi uchinchi elementni 10 ga almashtiring va natijani chiqaring.","title":"\u2705 2-topshiriq: Ro'yxatni o\u2018zgartirish"},{"location":"python/lists/#3-topshiriq-element-qoshish-va-ochirish","text":"Bo\u2018sh ro'yxat yarating. Ro'yxatga 'dog' , 'cat' , 'chicken' elementlarini qo\u2018shing. 'cat' elementini o\u2018chirib, ro'yxatni chiqaring.","title":"\u2705 3-topshiriq: Element qo\u2018shish va o\u2018chirish"},{"location":"python/lists/#4-topshiriq-royxat-uzunligini-topish","text":"Ro'yxat: 'red' , 'green' , 'blue' , 'yellow' , 'purple' . Ro'yxatning uzunligini hisoblab, terminalga chiqaring.","title":"\u2705 4-topshiriq: Ro'yxat uzunligini topish"},{"location":"python/lists/#5-topshiriq-royxatlarni-birlashtirish","text":"Ikkita ro'yxat yarating: - ['a', 'b', 'c'] - ['d', 'e', 'f'] Ularni birlashtirib, yangi ro'yxatni terminalga chiqaring.","title":"\u2705 5-topshiriq: Ro'yxatlarni birlashtirish"},{"location":"python/lists/#6-topshiriq-element-mavjudligini-tekshirish","text":"Ro'yxat: ['mashina', 'avtobus', 'velosiped', 'poyezd'] 'avtobus' ro'yxatda bormi? Tekshirib natijani ( True yoki False ) chiqaring.","title":"\u2705 6-topshiriq: Element mavjudligini tekshirish"},{"location":"python/lists/#7-topshiriq-royxatni-saralash","text":"Ro'yxat: [3, 1, 4, 2, 5] O'sish tartibida saralang va natijani chiqaring.","title":"\u2705 7-topshiriq: Ro'yxatni saralash"},{"location":"python/lists/#8-topshiriq-teskari-tartibda-chiqarish","text":"Ro'yxat: [10, 20, 30, 40, 50] .reverse() metodi yordamida ro'yxatni teskari chiqarish.","title":"\u2705 8-topshiriq: Teskari tartibda chiqarish"},{"location":"python/lists/#9-topshiriq-royxatni-tozalash","text":"Ro'yxat: ['kitob', 'qalam', 'daftar', 'sumka'] .clear() yordamida barcha elementlarni o\u2018chirib, natijani chiqaring.","title":"\u2705 9-topshiriq: Ro'yxatni tozalash"},{"location":"python/lists/#10-topshiriq-royxatni-kopaytirish","text":"Ro'yxat: [1, 2, 3] Ro'yxatni 4 marta ko\u2018paytirib, yangi ro'yxatni terminalga chiqaring.","title":"\u2705 10-topshiriq: Ro'yxatni ko\u2018paytirish"},{"location":"python/lists/#11-topshiriq-minimal-va-maksimal-qiymatni-topish","text":"Ro'yxat: [25, 17, 9, 50, 33] min() va max() funksiyalari yordamida eng kichik va eng katta qiymatlarni toping.","title":"\u2705 11-topshiriq: Minimal va maksimal qiymatni topish"},{"location":"python/lists/#12-topshiriq-royxatni-nusxalash","text":"Ro'yxat: [100, 200, 300, 400, 500] Nusxa ko\u2018chiring ( copy() ) va yangi ro'yxatni chiqarib ko\u2018rsating.","title":"\u2705 12-topshiriq: Ro'yxatni nusxalash"},{"location":"python/lists/#13-topshiriq-royxatdagi-elementlar-yigindisi","text":"Ro'yxat: [2, 4, 6, 8, 10] sum() funksiyasi orqali yig\u2018indini hisoblang va natijani chiqaring.","title":"\u2705 13-topshiriq: Ro'yxatdagi elementlar yig\u2018indisi"},{"location":"python/lists/#14-topshiriq-slicing-va-step-ishlatish","text":"Ro'yxat: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Har ikkinchi elementni ajratib olib, yangi ro'yxat hosil qiling.","title":"\u2705 14-topshiriq: Slicing va step ishlatish"},{"location":"python/lists/#15-topshiriq-multi-dimensional-listdan-element-olish","text":"Ro'yxat: [[1, 2], [3, 4], [5, 6]] Ikkinchi ichki ro'yxatdagi ikkinchi elementni ( 4 ) terminalga chiqaring.","title":"\u2705 15-topshiriq: Multi-dimensional listdan element olish"},{"location":"python/modules/","text":"\ud83e\udde9 13-DARS MODULS \u2705 MODUL NIMA? \ud83d\udccc Modul \u2014 bu Python fayli bo\u2018lib, u ichida funksiyalar , classlar , o\u2018zgaruvchilar , yoki boshqa Python kodlari saqlanadi. \ud83d\udccc Modulning asosiy vazifasi \u2014 kodni bo\u2018laklarga ajratish, tartibli saqlash va boshqa joylarda qayta ishlatish imkonini berish. \u2705 MODUL KERAKMI? NIMA FOYDA? \ud83d\udccc Quyidagi sabablarga ko\u2018ra modul foydali: Kod takrorlanmasligi \u2014 bir marta yozilgan kodni istalgan joyda qayta ishlatish mumkin. Kodlarni guruhlash \u2014 o\u2018xshash funksiyalar bitta faylga to\u2018plansa, ularni boshqarish oson bo\u2018ladi. Katta dasturlarni boshqarish osonlashadi \u2014 har bir qism alohida modul bo\u2018lsa, tuzilma soddalashadi. Test qilish oson \u2014 modulni alohida sinab ko\u2018rish mumkin. \u2705 MODULLARNI import QILISH \ud83d\udccc Pythonda modullardan foydalanish uchun avvalo ularni import qilish kerak. Modullarni import qilish uchun import kalit so'zidan foydalaniladi. # Dasturga tashqi yoki ichki modulni ulash (import qilish) uchun ishlatiladi # 'modul_nomi' o\u2018rniga kerakli modul nomi yoziladi (masalan: math, random, datetime va h.k.) import modul_nomi \ud83d\udccc math modulini import qilish # 'math' modulini import qilamiz, bu modulda matematik funksiyalar mavjud import math # Aylananing radiusi 5 ga teng deb belgilaymiz radius = 5 # Aylana yuzini hisoblaymiz: \u03c0 * r^2 formulasi asosida yuza = math.pi * radius**2 # Hisoblangan aylana yuzini ekranga chiqaramiz print(f\"Aylana yuzi: {yuza}\") \u2705 MODULLARDAN MUAYYAN QISMLARNI IMPORT QILISH \ud83d\udccc from modul_nomi import funksiya_yoki_object sintaksisi yordamida siz ma'lum bir moduldan faqat kerakli funksiya yoki o'zgaruvchini import qilishingiz mumkin. Bu sizga modulni to'liq import qilmasdan, faqat zaruriy qismlarini olish imkonini beradi. # Belgilangan modul ichidan faqat kerakli funksiya yoki obyektni import qilish uchun ishlatiladi # 'modul_nomi' \u2013 bu modul nomi (masalan: math, random, datetime) # 'funksiya_yoki_object' \u2013 modul ichidagi aniq bir funksiya, klass yoki o\u2018zgaruvchi nomi from modul_nomi import funksiya_yoki_object \ud83d\udccc math modulidan sqrt funksiyasini import qilish # 'math' modulidan faqat 'sqrt' (kvadrat ildiz) funksiyasini import qilamiz from math import sqrt # Kvadrat ildizi olinadigan sonni belgilaymiz son = 16 # Berilgan sonning kvadrat ildizini hisoblaymiz ildiz = sqrt(son) # Natijani ekranga chiqaramiz print(f\"{son} ning kvadrat ildizi: {ildiz}\") \u2705 MODULGA BOSHQA NOM BERISH \ud83d\udccc Modulni import qilishda unga qisqa yoki qulayroq nom berish uchun as operatoridan foydalanishingiz mumkin. # 'math' modulini 'm' degan qisqa nom bilan import qilamiz import math as m # Aylananing radiusini belgilaymiz radius = 7 # Aylananing diametrini hisoblaymiz: D = 2 * \u03c0 * r formulasi bo\u2018yicha diametr = 2 * m.pi * radius # Hisoblangan diametrni ekranga chiqaramiz print(f\"Aylananing diametri: {diametr}\") \u2705 MODUL YARATISH \ud83d\udccc Modul yaratish uchun asosiy dasturimizdagi funksiyalarni yangi faylga ko'chiramiz xolos. Modulga oson murojat qilishimiz uchun, faylimiz asosiy dasturimiz bilan bitta papkada bo'lishi kerak. Bunda adashib ketmaslik uchun, loyihangizning(dasturning) asosiy faylini main.py deb nomlash o'rinli. # mymodule.py - Bu modulda funksiyalar va klasslar jamlangan # Salomlashish uchun funksiya def greet(name): \"\"\"Salomlashish funktsiyasi.\"\"\" return f\"Salom, {name}!\" # Ikki sonni qo\u2018shish funksiyasi def add(a, b): \"\"\"Ikki sonni qo'shish funktsiyasi.\"\"\" return a + b # Ikki sonni ko\u2018paytirish funksiyasi def multiply(a, b): \"\"\"Ikki sonni ko'paytirish funktsiyasi.\"\"\" return a * b # Shaxslarni ifodalovchi klass class Person: \"\"\"Shaxs klassi.\"\"\" # Klassni ishga tushiruvchi konstruktor def __init__(self, name, age): self.name = name self.age = age # Shaxs haqida tanishtiruvchi metod def introduce(self): \"\"\"Shaxsni tanishtiruvchi metod.\"\"\" return f\"Men {self.name} va {self.age} yoshdaman.\" \u2705MODULDAN FOYDALANISH \ud83d\udccc Modul yaratganingizdan so'ng, uni boshqa Python dasturlarida import qilib ishlatishingiz mumkin. # mymodule modulini import qilamiz, undagi funksiyalar va klasslardan foydalanish uchun import mymodule # greet funksiyasini chaqirib, \"Ali\" ga salom beramiz print(mymodule.greet(\"Ali\")) # add funksiyasi yordamida 5 va 3 sonlarini qo\u2018shamiz va natijani chiqaramiz print(mymodule.add(5, 3)) # multiply funksiyasi yordamida 4 va 7 sonlarini ko\u2018paytiramiz va natijani chiqaramiz print(mymodule.multiply(4, 7)) # Person klassidan yangi obyekt yaratamiz, ism va yoshni beramiz person = mymodule.Person(\"Omar\", 25) # obyektning introduce metodini chaqirib, tanishtirish matnini chiqaramiz print(person.introduce()) \u2705 MODULNI KENGAYTIRISH \ud83d\udccc Modulga qo'shimcha funksiyalar yoki klasslar qo'shishingiz mumkin. # Ikki sondan birini ayirish funksiyasi def subtract(a, b): \"\"\"Ikki sondan birini ayirish funktsiyasi.\"\"\" return a - b # Ikki sonni bo'lish funksiyasi def divide(a, b): \"\"\"Ikki sonni bo'lish funktsiyasi.\"\"\" if b == 0: # Agar bo\u2018luvchi 0 bo\u2018lsa, xatolik chiqaramiz raise ValueError(\"Bo'lish uchun 0 bilan bo'lish mumkin emas!\") return a / b \u2705 FOYDALI MODULLAR \ud83d\udccc math MODULI \u2705 NIMA UCHUN FOYDALI? Matematik hisob-kitoblarni oson va aniq bajarish uchun kerak. Kvadrat ildiz, logarifm, trigonometrik funksiyalar, faktoriyal kabi ko\u2018plab matematik operatsiyalarni bajarish imkonini beradi. Dasturlashda murakkab matematik formulalarni ishlatishda yordam beradi. 1. math.ceil(x) \ud83d\udccc x sonini yuqoriga qarab yaxlitlaydi. Ya'ni, agar son butun emas bo\u2018lsa, keyingi eng yaqin butun songa oshiradi. Agar son butun bo\u2018lsa, o\u2018zi o\u2018zgarmaydi. # 'math' modulini import qilamiz import math # 5.1 sonini yuqoriga qarab butun songa yaxlitlaymiz (ceil funksiyasi) print(math.ceil(5.1)) # Natija: 6 # 5.9 sonini yuqoriga qarab butun songa yaxlitlaymiz print(math.ceil(5.9)) # Natija: 6 # Manfiy -3.4 sonini yuqoriga qarab yaxlitlaymiz (-3.4 dan katta eng kichik butun son -3) print(math.ceil(-3.4)) # Natija: -3 # 7 allaqachon butun son, shuning uchun o\u2018zgarmaydi print(math.ceil(7)) # Natija: 7 2. math.floor(x) \ud83d\udccc x sonini pastga qarab yaxlitlaydi. Ya'ni, agar son butun emas bo\u2018lsa, oldingi eng yaqin butun songa tushiradi. Agar son butun bo\u2018lsa, o\u2018zi o\u2018zgarmaydi. # 'math' modulini import qilamiz import math # 5.9 sonini pastga qarab butun songa yaxlitlaymiz (floor funksiyasi) print(math.floor(5.9)) # Natija: 5 # 5.1 sonini pastga qarab butun songa yaxlitlaymiz print(math.floor(5.1)) # Natija: 5 # Manfiy -3.4 sonini pastga qarab yaxlitlaymiz (-3.4 dan kichik eng katta butun son -4) print(math.floor(-3.4)) # Natija: -4 # 7 allaqachon butun son, shuning uchun o\u2018zgarmaydi print(math.floor(7)) # Natija: 7 random MODULI \ud83d\udccc random moduli \u2014 bu Python kutubxonasi bo\u2018lib, u yordamida tasodifiy sonlar, tasodifiy elementlar tanlash va ro\u2018yxatlarni aralashtirish mumkin. \u2705 NIMA UCHUN FOYDALI? O'yinlarda qahramonlar yoki voqealar uchun tasodifiylik yaratish uchun, Testlarda tasodifiy savollar tanlash uchun, Statistik tadqiqotlarda namuna olish uchun ishlatiladi. Shuningdek, har xil dasturlarda tasodifiy natijalar yaratishda qo\u2018llaniladi. 1. random.randint(a, b) \ud83d\udccc a va b orasidagi tasodifiy butun sonni qaytaradi (a va b ham shu oraliqqa kiradi). # random modulini import qilamiz, bu modul tasodifiy sonlar bilan ishlash uchun kerak import random # 1 dan 10 gacha (ikkala chegarani ham qo'shib) tasodifiy butun son hosil qilamiz son = random.randint(1, 10) # Hosil qilingan tasodifiy sonni ekranga chiqaramiz print(son) # 1 dan 10 gacha bo'lgan butun son (masalan, 3, 7, 10 va hokazo) 2. random.choice(sequence) \ud83d\udccc Berilgan ketma-ketlik (list, string yoki boshqa iterable) ichidan tasodifiy bitta elementni tanlaydi. # random modulini import qilamiz, tasodifiy element tanlash uchun kerak bo\u2018ladi import random # Mevalar ro\u2018yxatini yaratamiz mevalar = ['olma', 'banan', 'anor', 'shaftoli'] # Ro\u2018yxatdan tasodifiy bitta meva tanlaymiz tasodifiy_meva = random.choice(mevalar) # Tanlangan mevaning nomini ekranga chiqaramiz print(tasodifiy_meva) # masalan, 'anor' yoki 'banan' chiqishi mumkin 3. random.shuffle(list) \ud83d\udccc List elementlarini joyini tasodifiy tarzda almashtiradi (listni o\u2018zgartiradi). # random modulini import qilamiz, ro'yxat elementlarini aralashtirish uchun kerak import random # Raqamlar ro'yxatini yaratamiz raqamlar = [1, 2, 3, 4, 5] # Ro'yxatdagi elementlarni tasodifiy tartibda aralashtiramiz random.shuffle(raqamlar) # Aralashtirilgan ro'yxatni ekranga chiqaramiz print(raqamlar) # ro'yxat elementlari aralashadi, masalan, [3, 1, 5, 2, 4] datetime MODULI \ud83d\udccc datetime moduli - Python kutubxonasi bo\u2018lib, sana va vaqt bilan ishlash uchun ishlatiladi. \u2705 NIMA UCHUN FOYDALI? Vaqtni hisoblash (masalan, ikki sana orasidagi farqni topish) Hozirgi vaqtni olish Sanalarni formatlash va ko\u2018rsatish Muddatlarni qo\u2018shish yoki ayirish. 1. datetime.date.today() \ud83d\udccc Hozirgi kundagi sanani qaytaradi (faqat sana, vaqt emas). # datetime modulini import qilamiz, vaqt va sana bilan ishlash uchun kerak import datetime # Hozirgi sanani olish uchun today() funksiyasidan foydalanamiz bugun = datetime.date.today() # Olingan sanani ekranga chiqaramiz, masalan: 2025-06-06 print(bugun) # masalan, 2025-06-06 2. datetime.datetime.now() \ud83d\udccc Hozirgi sanani va vaqtni to\u2018liq qaytaradi (soat, daqiqa, soniya bilan). # datetime modulini import qilamiz, sana va vaqt bilan ishlash uchun kerak import datetime # Hozirgi sana va vaqtni olish uchun now() funksiyasidan foydalanamiz hozir = datetime.datetime.now() # Olingan sana va vaqtni ekranga chiqaramiz, masalan: 2025-06-06 15:30:25.123456 print(hozir) # masalan, 2025-06-06 15:30:25.123456 3. datetime.timedelta(days=5) \ud83d\udccc Vaqt oralig\u2018ini ifodalaydi. Masalan, 5 kun yoki 2 soat kabilarni yaratadi. # datetime modulini import qilamiz, sana va vaqt bilan ishlash uchun kerak import datetime # timedelta obyektini yaratamiz, bu 5 kunlik vaqt farqini ifodalaydi besh_kun = datetime.timedelta(days=5) # Hozirgi sanani olamiz bugun = datetime.date.today() # Bugungi sanaga 5 kun qo'shamiz, natijada kelasi sana hosil bo'ladi kelasi_sana = bugun + besh_kun # Kelasi sanani ekranga chiqaramiz print(kelasi_sana) # bugun sanadan 5 kun keyingi sana chiqadi \ud83d\udccc os MODULI os moduli \u2014 bu Python kutubxonasi bo\u2018lib, u orqali operatsion tizim bilan bog\u2018liq amallarni bajarish mumkin. \u2705 NIMA UCHUN FOYDALI? Fayllar va papkalar ustida amallar bajarish (yaratish, o\u2018chirish, ko\u2018rish) Biz ishlab turgan papkani yo'lini aniqlash Papka va fayllar bilan dastur orqali interaktiv ishlash 1. os.getcwd() \ud83d\udccc Biz ishlab turgan papkani (working directory) yo\u2018lini qaytaradi. # os modulini import qilamiz, operatsion tizim bilan bog\u2018liq funksiyalar uchun kerak import os # Hozirgi ishchi papkaning (current working directory) yo\u2018lini olamiz papka = os.getcwd() # Olingan papka yo\u2018lini ekranga chiqaramiz, masalan: /home/username/projects print(papka) # Masalan: /home/username/projects 2. os.listdir(path) \ud83d\udccc Berilgan papka ichidagi barcha fayl va papkalar ro\u2018yxatini beradi. # os modulini import qilamiz, operatsion tizim bilan ishlash uchun kerak import os # Hozirgi papkadagi barcha fayl va papkalar ro'yxatini olamiz fayllar = os.listdir('.') # '.' bu hozirgi ishlab turgan papkani bildiradi # Olingan fayl va papkalar ro'yxatini ekranga chiqaramiz print(fayllar) # Masalan: ['file1.txt', 'image.png', 'folder1'] 3. os.mkdir(name) \ud83d\udccc Yangi papka yaratadi. # os modulini import qilamiz, operatsion tizim bilan ishlash uchun kerak import os # 'yangi_papka' nomli yangi papka yaratamiz (agar mavjud bo'lmasa) os.mkdir('yangi_papka') # Papka yaratilib bo\u2018lgani haqida xabar beramiz print(\"Yangi papka yaratildi\") 3. os.remove(filename) \ud83d\udccc Faylni o\u2018chiradi. # os modulini import qilamiz, fayllar va papkalar bilan ishlash uchun kerak import os # 'eskifayl.txt' nomli faylni o'chiramiz (agar mavjud bo'lsa) os.remove('old_file.txt') # Fayl muvaffaqiyatli o'chirilgani haqida xabar beramiz print(\"Fayl o'chirildi\") \ud83d\udccc json MODULI \ud83d\udccc json moduli \u2014 bu Python kutubxonasi bo\u2018lib, JSON formatidagi ma\u2019lumotlar bilan ishlash uchun ishlatiladi. JSON \u2014 bu ma\u2019lumotlarni yozish va uzatishda keng qo\u2018llaniladigan standart format. Web dasturlashda, API (Application Programming Interface) lar bilan ishlashda juda muhim. \u2705 NIMA UCHUN FOYDALI? JSON formatidagi ma\u2019lumotlarni Python obyektlariga o\u2018qish, Python obyektlarini JSON formatiga yozish, API dan kelgan JSON javoblarini qayta ishlash, Ma\u2019lumotlarni faylga JSON formatida saqlash va o\u2018qish. json.loads(s) \ud83d\udccc JSON ko\u2018rinishidagi satrni Python obyektiga (list, dictionary va boshqalar) aylantiradi. # json modulini import qilamiz, JSON formatidagi ma'lumotlarni o'qish va yozish uchun kerak import json # JSON formatidagi satrni yaratamiz (string ko'rinishida) json_satr = '{\"ism\": \"Umid\", \"yosh\": 25}' # json.loads() funksiyasi yordamida JSON stringlarni Python dictionaryga aylantiramiz python_obj = json.loads(json_satr) # Python lug'atini ekranga chiqaramiz print(python_obj) # {'ism': 'Umid', 'yosh': 25} # Dictionarydan 'ism' kalitiga mos keluvchi qiymatni chiqaramiz print(python_obj['ism']) # Umid 2. json.dumps(obj) \ud83d\udccc Python obyektini JSON formatidagi stringga aylantiradi. # json modulini import qilamiz, JSON formatiga o\u2018tkazish va o\u2018qish uchun kerak import json # Python dictionary yaratamiz python_obj = {'ism': 'Umid', 'yosh': 25} # json.dumps() yordamida Python dictionaryni JSON formatidagi stringga aylantiramiz json_satr = json.dumps(python_obj) # JSON formatidagi stringni ekranga chiqaramiz print(json_satr) # '{\"ism\": \"Umid\", \"yosh\": 25}' 3. json.load(file) \ud83d\udccc JSON faylini o\u2018qiydi va Python obyektiga aylantiradi. # json modulini import qilamiz, JSON fayllarni o'qish va yozish uchun kerak import json # 'data.json' faylini o'qish uchun ochamiz ('r' - read rejimi) with open('data.json', 'r') as fayl: # fayldagi JSON ma'lumotlarni Python obyektiga (masalan, dictionary) o\u2018qiymiz malumot = json.load(fayl) # Olingan ma'lumotni ekranga chiqaramiz print(malumot) 4. json.dump(obj, file) \ud83d\udccc Python obyektini JSON faylga yozadi. # json modulini import qilamiz, JSON formatida yozish va o'qish uchun kerak import json # Python dictionary yaratamiz, uni JSON formatida faylga yozamiz data = {'ism': 'Umid', 'yosh': 25} # 'data.json' faylini yozish uchun ochamiz ('w' - write rejimi) with open('data.json', 'w') as fayl: # Python dictionaryni JSON formatida faylga yozamiz json.dump(data, fayl) \u2705 AMALIYOT \u2705 1-topshiriq: math modulidan foydalanib, 10 ta sonning kvadrat ildizini hisoblovchi dastur yozing va natijalarni chiqaring. \u2705 2-topshiriq: random modulidan foydalanib, 1 dan 100 gacha bo\u2018lgan 5 ta tasodifiy butun sonlarni ro\u2018yxatga joylashtiring va ularni ekranga chiqaring. \u2705 3-topshiriq: datetime modulidan foydalanib, bugungi sanani va vaqtni formatlangan holda YYYY-MM-DD HH:MM:SS ko\u2018rinishida ekranga chiqaring. \u2705 4-topshiriq: O\u2018zingizning kichik modul faylingizni yarating ( mycalc.py ) va unga add(a, b) , subtract(a, b) , multiply(a, b) , divide(a, b) funksiyalarini yozing. Keyin ularni boshqa dasturga import qilib, natijalarni ko\u2018rsating. \u2705 5-topshiriq: math modulidan pi va sin funksiyalarini import qilib, 0 dan \u03c0 gacha bo\u2018lgan 5 ta qiymat uchun sinuslarini hisoblab chiqaring. \u2705 6-topshiriq: random.choice() funksiyasi yordamida ro\u2018yxatdan tasodifiy 3 ta ism tanlab, ularni ekranga chiqaring. \u2705 7-topshiriq: random.shuffle() yordamida berilgan ro\u2018yxat elementlarini aralashtiring va natijani chop eting. \u2705 8-topshiriq: datetime modulidan foydalanib, foydalanuvchidan yil, oy, kun kiritishini so\u2018rang va shu sanani datetime.date obyekti sifatida saqlang. \u2705 9-topshiriq: Yangi modul yarating, unga greet(name) funksiyasini yozing, u berilgan ismga salom beradi. Modulni import qilib, turli ismlar bilan chaqiring. \u2705 10-topshiriq: math modulining ceil va floor funksiyalarini import qilib, foydalanuvchi kiritgan haqiqiy son uchun ikkala qiymatni ham chiqaring. \u2705 11-topshiriq: O\u2018z modulingizda yangi funksiya yarating \u2014 is_even(number) \u2014 son juft yoki toqligini tekshiradi va True yoki False qaytaradi. Modulni import qilib, ro\u2018yxatdagi sonlarni tekshiring. \u2705 12-topshiriq: random modulidan foydalanib, 52 ta kartadan iborat ro\u2018yxat yarating (masalan: \"Queen of Hearts\", \"10 of Diamonds\", va hokazo), keyin tasodifiy 5 ta kartani tanlab chiqaring. (Diamonds, Hearts, Clubs, Spades) \u2705 13-topshiriq: datetime modulidan hozirgi vaqtni olib, uni soat, daqiqa va sekundga ajratib chiqaradigan dastur yozing. \u2705 14-topshiriq: Modulga yangi funksiyalar qo\u2018shing: factorial(n) va is_prime(n) , ularni o\u2018zingiz yozing (modulda) va keyin asosiy dasturda chaqiring. \u2705 15-topshiriq: math modulidan pow funksiyasini import qilib, foydalanuvchidan asosi va darajani qabul qilib, natijani hisoblang.","title":"\ud83e\udde9 13-DARS MODULS"},{"location":"python/modules/#13-dars-moduls","text":"","title":"\ud83e\udde9 13-DARS MODULS"},{"location":"python/modules/#modul-nima","text":"\ud83d\udccc Modul \u2014 bu Python fayli bo\u2018lib, u ichida funksiyalar , classlar , o\u2018zgaruvchilar , yoki boshqa Python kodlari saqlanadi. \ud83d\udccc Modulning asosiy vazifasi \u2014 kodni bo\u2018laklarga ajratish, tartibli saqlash va boshqa joylarda qayta ishlatish imkonini berish.","title":"\u2705 MODUL NIMA?"},{"location":"python/modules/#modul-kerakmi-nima-foyda","text":"\ud83d\udccc Quyidagi sabablarga ko\u2018ra modul foydali: Kod takrorlanmasligi \u2014 bir marta yozilgan kodni istalgan joyda qayta ishlatish mumkin. Kodlarni guruhlash \u2014 o\u2018xshash funksiyalar bitta faylga to\u2018plansa, ularni boshqarish oson bo\u2018ladi. Katta dasturlarni boshqarish osonlashadi \u2014 har bir qism alohida modul bo\u2018lsa, tuzilma soddalashadi. Test qilish oson \u2014 modulni alohida sinab ko\u2018rish mumkin.","title":"\u2705 MODUL KERAKMI? NIMA FOYDA?"},{"location":"python/modules/#modullarni-import-qilish","text":"\ud83d\udccc Pythonda modullardan foydalanish uchun avvalo ularni import qilish kerak. Modullarni import qilish uchun import kalit so'zidan foydalaniladi. # Dasturga tashqi yoki ichki modulni ulash (import qilish) uchun ishlatiladi # 'modul_nomi' o\u2018rniga kerakli modul nomi yoziladi (masalan: math, random, datetime va h.k.) import modul_nomi \ud83d\udccc math modulini import qilish # 'math' modulini import qilamiz, bu modulda matematik funksiyalar mavjud import math # Aylananing radiusi 5 ga teng deb belgilaymiz radius = 5 # Aylana yuzini hisoblaymiz: \u03c0 * r^2 formulasi asosida yuza = math.pi * radius**2 # Hisoblangan aylana yuzini ekranga chiqaramiz print(f\"Aylana yuzi: {yuza}\")","title":"\u2705 MODULLARNI import QILISH"},{"location":"python/modules/#modullardan-muayyan-qismlarni-import-qilish","text":"\ud83d\udccc from modul_nomi import funksiya_yoki_object sintaksisi yordamida siz ma'lum bir moduldan faqat kerakli funksiya yoki o'zgaruvchini import qilishingiz mumkin. Bu sizga modulni to'liq import qilmasdan, faqat zaruriy qismlarini olish imkonini beradi. # Belgilangan modul ichidan faqat kerakli funksiya yoki obyektni import qilish uchun ishlatiladi # 'modul_nomi' \u2013 bu modul nomi (masalan: math, random, datetime) # 'funksiya_yoki_object' \u2013 modul ichidagi aniq bir funksiya, klass yoki o\u2018zgaruvchi nomi from modul_nomi import funksiya_yoki_object \ud83d\udccc math modulidan sqrt funksiyasini import qilish # 'math' modulidan faqat 'sqrt' (kvadrat ildiz) funksiyasini import qilamiz from math import sqrt # Kvadrat ildizi olinadigan sonni belgilaymiz son = 16 # Berilgan sonning kvadrat ildizini hisoblaymiz ildiz = sqrt(son) # Natijani ekranga chiqaramiz print(f\"{son} ning kvadrat ildizi: {ildiz}\")","title":"\u2705 MODULLARDAN MUAYYAN QISMLARNI IMPORT QILISH"},{"location":"python/modules/#modulga-boshqa-nom-berish","text":"\ud83d\udccc Modulni import qilishda unga qisqa yoki qulayroq nom berish uchun as operatoridan foydalanishingiz mumkin. # 'math' modulini 'm' degan qisqa nom bilan import qilamiz import math as m # Aylananing radiusini belgilaymiz radius = 7 # Aylananing diametrini hisoblaymiz: D = 2 * \u03c0 * r formulasi bo\u2018yicha diametr = 2 * m.pi * radius # Hisoblangan diametrni ekranga chiqaramiz print(f\"Aylananing diametri: {diametr}\")","title":"\u2705 MODULGA BOSHQA NOM BERISH"},{"location":"python/modules/#modul-yaratish","text":"\ud83d\udccc Modul yaratish uchun asosiy dasturimizdagi funksiyalarni yangi faylga ko'chiramiz xolos. Modulga oson murojat qilishimiz uchun, faylimiz asosiy dasturimiz bilan bitta papkada bo'lishi kerak. Bunda adashib ketmaslik uchun, loyihangizning(dasturning) asosiy faylini main.py deb nomlash o'rinli. # mymodule.py - Bu modulda funksiyalar va klasslar jamlangan # Salomlashish uchun funksiya def greet(name): \"\"\"Salomlashish funktsiyasi.\"\"\" return f\"Salom, {name}!\" # Ikki sonni qo\u2018shish funksiyasi def add(a, b): \"\"\"Ikki sonni qo'shish funktsiyasi.\"\"\" return a + b # Ikki sonni ko\u2018paytirish funksiyasi def multiply(a, b): \"\"\"Ikki sonni ko'paytirish funktsiyasi.\"\"\" return a * b # Shaxslarni ifodalovchi klass class Person: \"\"\"Shaxs klassi.\"\"\" # Klassni ishga tushiruvchi konstruktor def __init__(self, name, age): self.name = name self.age = age # Shaxs haqida tanishtiruvchi metod def introduce(self): \"\"\"Shaxsni tanishtiruvchi metod.\"\"\" return f\"Men {self.name} va {self.age} yoshdaman.\"","title":"\u2705 MODUL YARATISH"},{"location":"python/modules/#moduldan-foydalanish","text":"\ud83d\udccc Modul yaratganingizdan so'ng, uni boshqa Python dasturlarida import qilib ishlatishingiz mumkin. # mymodule modulini import qilamiz, undagi funksiyalar va klasslardan foydalanish uchun import mymodule # greet funksiyasini chaqirib, \"Ali\" ga salom beramiz print(mymodule.greet(\"Ali\")) # add funksiyasi yordamida 5 va 3 sonlarini qo\u2018shamiz va natijani chiqaramiz print(mymodule.add(5, 3)) # multiply funksiyasi yordamida 4 va 7 sonlarini ko\u2018paytiramiz va natijani chiqaramiz print(mymodule.multiply(4, 7)) # Person klassidan yangi obyekt yaratamiz, ism va yoshni beramiz person = mymodule.Person(\"Omar\", 25) # obyektning introduce metodini chaqirib, tanishtirish matnini chiqaramiz print(person.introduce())","title":"\u2705MODULDAN FOYDALANISH"},{"location":"python/modules/#modulni-kengaytirish","text":"\ud83d\udccc Modulga qo'shimcha funksiyalar yoki klasslar qo'shishingiz mumkin. # Ikki sondan birini ayirish funksiyasi def subtract(a, b): \"\"\"Ikki sondan birini ayirish funktsiyasi.\"\"\" return a - b # Ikki sonni bo'lish funksiyasi def divide(a, b): \"\"\"Ikki sonni bo'lish funktsiyasi.\"\"\" if b == 0: # Agar bo\u2018luvchi 0 bo\u2018lsa, xatolik chiqaramiz raise ValueError(\"Bo'lish uchun 0 bilan bo'lish mumkin emas!\") return a / b","title":"\u2705 MODULNI KENGAYTIRISH"},{"location":"python/modules/#foydali-modullar","text":"","title":"\u2705 FOYDALI MODULLAR"},{"location":"python/modules/#math-moduli","text":"","title":"\ud83d\udccc math MODULI"},{"location":"python/modules/#nima-uchun-foydali","text":"Matematik hisob-kitoblarni oson va aniq bajarish uchun kerak. Kvadrat ildiz, logarifm, trigonometrik funksiyalar, faktoriyal kabi ko\u2018plab matematik operatsiyalarni bajarish imkonini beradi. Dasturlashda murakkab matematik formulalarni ishlatishda yordam beradi.","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/modules/#1-mathceilx","text":"\ud83d\udccc x sonini yuqoriga qarab yaxlitlaydi. Ya'ni, agar son butun emas bo\u2018lsa, keyingi eng yaqin butun songa oshiradi. Agar son butun bo\u2018lsa, o\u2018zi o\u2018zgarmaydi. # 'math' modulini import qilamiz import math # 5.1 sonini yuqoriga qarab butun songa yaxlitlaymiz (ceil funksiyasi) print(math.ceil(5.1)) # Natija: 6 # 5.9 sonini yuqoriga qarab butun songa yaxlitlaymiz print(math.ceil(5.9)) # Natija: 6 # Manfiy -3.4 sonini yuqoriga qarab yaxlitlaymiz (-3.4 dan katta eng kichik butun son -3) print(math.ceil(-3.4)) # Natija: -3 # 7 allaqachon butun son, shuning uchun o\u2018zgarmaydi print(math.ceil(7)) # Natija: 7","title":"1. math.ceil(x)"},{"location":"python/modules/#2-mathfloorx","text":"\ud83d\udccc x sonini pastga qarab yaxlitlaydi. Ya'ni, agar son butun emas bo\u2018lsa, oldingi eng yaqin butun songa tushiradi. Agar son butun bo\u2018lsa, o\u2018zi o\u2018zgarmaydi. # 'math' modulini import qilamiz import math # 5.9 sonini pastga qarab butun songa yaxlitlaymiz (floor funksiyasi) print(math.floor(5.9)) # Natija: 5 # 5.1 sonini pastga qarab butun songa yaxlitlaymiz print(math.floor(5.1)) # Natija: 5 # Manfiy -3.4 sonini pastga qarab yaxlitlaymiz (-3.4 dan kichik eng katta butun son -4) print(math.floor(-3.4)) # Natija: -4 # 7 allaqachon butun son, shuning uchun o\u2018zgarmaydi print(math.floor(7)) # Natija: 7","title":"2. math.floor(x)"},{"location":"python/modules/#random-moduli","text":"\ud83d\udccc random moduli \u2014 bu Python kutubxonasi bo\u2018lib, u yordamida tasodifiy sonlar, tasodifiy elementlar tanlash va ro\u2018yxatlarni aralashtirish mumkin.","title":"random MODULI"},{"location":"python/modules/#nima-uchun-foydali_1","text":"O'yinlarda qahramonlar yoki voqealar uchun tasodifiylik yaratish uchun, Testlarda tasodifiy savollar tanlash uchun, Statistik tadqiqotlarda namuna olish uchun ishlatiladi. Shuningdek, har xil dasturlarda tasodifiy natijalar yaratishda qo\u2018llaniladi.","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/modules/#1-randomrandinta-b","text":"\ud83d\udccc a va b orasidagi tasodifiy butun sonni qaytaradi (a va b ham shu oraliqqa kiradi). # random modulini import qilamiz, bu modul tasodifiy sonlar bilan ishlash uchun kerak import random # 1 dan 10 gacha (ikkala chegarani ham qo'shib) tasodifiy butun son hosil qilamiz son = random.randint(1, 10) # Hosil qilingan tasodifiy sonni ekranga chiqaramiz print(son) # 1 dan 10 gacha bo'lgan butun son (masalan, 3, 7, 10 va hokazo)","title":"1. random.randint(a, b)"},{"location":"python/modules/#2-randomchoicesequence","text":"\ud83d\udccc Berilgan ketma-ketlik (list, string yoki boshqa iterable) ichidan tasodifiy bitta elementni tanlaydi. # random modulini import qilamiz, tasodifiy element tanlash uchun kerak bo\u2018ladi import random # Mevalar ro\u2018yxatini yaratamiz mevalar = ['olma', 'banan', 'anor', 'shaftoli'] # Ro\u2018yxatdan tasodifiy bitta meva tanlaymiz tasodifiy_meva = random.choice(mevalar) # Tanlangan mevaning nomini ekranga chiqaramiz print(tasodifiy_meva) # masalan, 'anor' yoki 'banan' chiqishi mumkin","title":"2. random.choice(sequence)"},{"location":"python/modules/#3-randomshufflelist","text":"\ud83d\udccc List elementlarini joyini tasodifiy tarzda almashtiradi (listni o\u2018zgartiradi). # random modulini import qilamiz, ro'yxat elementlarini aralashtirish uchun kerak import random # Raqamlar ro'yxatini yaratamiz raqamlar = [1, 2, 3, 4, 5] # Ro'yxatdagi elementlarni tasodifiy tartibda aralashtiramiz random.shuffle(raqamlar) # Aralashtirilgan ro'yxatni ekranga chiqaramiz print(raqamlar) # ro'yxat elementlari aralashadi, masalan, [3, 1, 5, 2, 4]","title":"3. random.shuffle(list)"},{"location":"python/modules/#datetime-moduli","text":"\ud83d\udccc datetime moduli - Python kutubxonasi bo\u2018lib, sana va vaqt bilan ishlash uchun ishlatiladi.","title":"datetime MODULI"},{"location":"python/modules/#nima-uchun-foydali_2","text":"Vaqtni hisoblash (masalan, ikki sana orasidagi farqni topish) Hozirgi vaqtni olish Sanalarni formatlash va ko\u2018rsatish Muddatlarni qo\u2018shish yoki ayirish.","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/modules/#1-datetimedatetoday","text":"\ud83d\udccc Hozirgi kundagi sanani qaytaradi (faqat sana, vaqt emas). # datetime modulini import qilamiz, vaqt va sana bilan ishlash uchun kerak import datetime # Hozirgi sanani olish uchun today() funksiyasidan foydalanamiz bugun = datetime.date.today() # Olingan sanani ekranga chiqaramiz, masalan: 2025-06-06 print(bugun) # masalan, 2025-06-06","title":"1. datetime.date.today()"},{"location":"python/modules/#2-datetimedatetimenow","text":"\ud83d\udccc Hozirgi sanani va vaqtni to\u2018liq qaytaradi (soat, daqiqa, soniya bilan). # datetime modulini import qilamiz, sana va vaqt bilan ishlash uchun kerak import datetime # Hozirgi sana va vaqtni olish uchun now() funksiyasidan foydalanamiz hozir = datetime.datetime.now() # Olingan sana va vaqtni ekranga chiqaramiz, masalan: 2025-06-06 15:30:25.123456 print(hozir) # masalan, 2025-06-06 15:30:25.123456","title":"2. datetime.datetime.now()"},{"location":"python/modules/#3-datetimetimedeltadays5","text":"\ud83d\udccc Vaqt oralig\u2018ini ifodalaydi. Masalan, 5 kun yoki 2 soat kabilarni yaratadi. # datetime modulini import qilamiz, sana va vaqt bilan ishlash uchun kerak import datetime # timedelta obyektini yaratamiz, bu 5 kunlik vaqt farqini ifodalaydi besh_kun = datetime.timedelta(days=5) # Hozirgi sanani olamiz bugun = datetime.date.today() # Bugungi sanaga 5 kun qo'shamiz, natijada kelasi sana hosil bo'ladi kelasi_sana = bugun + besh_kun # Kelasi sanani ekranga chiqaramiz print(kelasi_sana) # bugun sanadan 5 kun keyingi sana chiqadi","title":"3. datetime.timedelta(days=5)"},{"location":"python/modules/#os-moduli","text":"os moduli \u2014 bu Python kutubxonasi bo\u2018lib, u orqali operatsion tizim bilan bog\u2018liq amallarni bajarish mumkin.","title":"\ud83d\udccc os MODULI"},{"location":"python/modules/#nima-uchun-foydali_3","text":"Fayllar va papkalar ustida amallar bajarish (yaratish, o\u2018chirish, ko\u2018rish) Biz ishlab turgan papkani yo'lini aniqlash Papka va fayllar bilan dastur orqali interaktiv ishlash","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/modules/#1-osgetcwd","text":"\ud83d\udccc Biz ishlab turgan papkani (working directory) yo\u2018lini qaytaradi. # os modulini import qilamiz, operatsion tizim bilan bog\u2018liq funksiyalar uchun kerak import os # Hozirgi ishchi papkaning (current working directory) yo\u2018lini olamiz papka = os.getcwd() # Olingan papka yo\u2018lini ekranga chiqaramiz, masalan: /home/username/projects print(papka) # Masalan: /home/username/projects","title":"1. os.getcwd()"},{"location":"python/modules/#2-oslistdirpath","text":"\ud83d\udccc Berilgan papka ichidagi barcha fayl va papkalar ro\u2018yxatini beradi. # os modulini import qilamiz, operatsion tizim bilan ishlash uchun kerak import os # Hozirgi papkadagi barcha fayl va papkalar ro'yxatini olamiz fayllar = os.listdir('.') # '.' bu hozirgi ishlab turgan papkani bildiradi # Olingan fayl va papkalar ro'yxatini ekranga chiqaramiz print(fayllar) # Masalan: ['file1.txt', 'image.png', 'folder1']","title":"2. os.listdir(path)"},{"location":"python/modules/#3-osmkdirname","text":"\ud83d\udccc Yangi papka yaratadi. # os modulini import qilamiz, operatsion tizim bilan ishlash uchun kerak import os # 'yangi_papka' nomli yangi papka yaratamiz (agar mavjud bo'lmasa) os.mkdir('yangi_papka') # Papka yaratilib bo\u2018lgani haqida xabar beramiz print(\"Yangi papka yaratildi\")","title":"3. os.mkdir(name)"},{"location":"python/modules/#3-osremovefilename","text":"\ud83d\udccc Faylni o\u2018chiradi. # os modulini import qilamiz, fayllar va papkalar bilan ishlash uchun kerak import os # 'eskifayl.txt' nomli faylni o'chiramiz (agar mavjud bo'lsa) os.remove('old_file.txt') # Fayl muvaffaqiyatli o'chirilgani haqida xabar beramiz print(\"Fayl o'chirildi\")","title":"3. os.remove(filename)"},{"location":"python/modules/#json-moduli","text":"\ud83d\udccc json moduli \u2014 bu Python kutubxonasi bo\u2018lib, JSON formatidagi ma\u2019lumotlar bilan ishlash uchun ishlatiladi. JSON \u2014 bu ma\u2019lumotlarni yozish va uzatishda keng qo\u2018llaniladigan standart format. Web dasturlashda, API (Application Programming Interface) lar bilan ishlashda juda muhim.","title":"\ud83d\udccc json MODULI"},{"location":"python/modules/#nima-uchun-foydali_4","text":"JSON formatidagi ma\u2019lumotlarni Python obyektlariga o\u2018qish, Python obyektlarini JSON formatiga yozish, API dan kelgan JSON javoblarini qayta ishlash, Ma\u2019lumotlarni faylga JSON formatida saqlash va o\u2018qish.","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/modules/#jsonloadss","text":"\ud83d\udccc JSON ko\u2018rinishidagi satrni Python obyektiga (list, dictionary va boshqalar) aylantiradi. # json modulini import qilamiz, JSON formatidagi ma'lumotlarni o'qish va yozish uchun kerak import json # JSON formatidagi satrni yaratamiz (string ko'rinishida) json_satr = '{\"ism\": \"Umid\", \"yosh\": 25}' # json.loads() funksiyasi yordamida JSON stringlarni Python dictionaryga aylantiramiz python_obj = json.loads(json_satr) # Python lug'atini ekranga chiqaramiz print(python_obj) # {'ism': 'Umid', 'yosh': 25} # Dictionarydan 'ism' kalitiga mos keluvchi qiymatni chiqaramiz print(python_obj['ism']) # Umid","title":"json.loads(s)"},{"location":"python/modules/#2-jsondumpsobj","text":"\ud83d\udccc Python obyektini JSON formatidagi stringga aylantiradi. # json modulini import qilamiz, JSON formatiga o\u2018tkazish va o\u2018qish uchun kerak import json # Python dictionary yaratamiz python_obj = {'ism': 'Umid', 'yosh': 25} # json.dumps() yordamida Python dictionaryni JSON formatidagi stringga aylantiramiz json_satr = json.dumps(python_obj) # JSON formatidagi stringni ekranga chiqaramiz print(json_satr) # '{\"ism\": \"Umid\", \"yosh\": 25}'","title":"2. json.dumps(obj)"},{"location":"python/modules/#3-jsonloadfile","text":"\ud83d\udccc JSON faylini o\u2018qiydi va Python obyektiga aylantiradi. # json modulini import qilamiz, JSON fayllarni o'qish va yozish uchun kerak import json # 'data.json' faylini o'qish uchun ochamiz ('r' - read rejimi) with open('data.json', 'r') as fayl: # fayldagi JSON ma'lumotlarni Python obyektiga (masalan, dictionary) o\u2018qiymiz malumot = json.load(fayl) # Olingan ma'lumotni ekranga chiqaramiz print(malumot)","title":"3. json.load(file)"},{"location":"python/modules/#4-jsondumpobj-file","text":"\ud83d\udccc Python obyektini JSON faylga yozadi. # json modulini import qilamiz, JSON formatida yozish va o'qish uchun kerak import json # Python dictionary yaratamiz, uni JSON formatida faylga yozamiz data = {'ism': 'Umid', 'yosh': 25} # 'data.json' faylini yozish uchun ochamiz ('w' - write rejimi) with open('data.json', 'w') as fayl: # Python dictionaryni JSON formatida faylga yozamiz json.dump(data, fayl)","title":"4. json.dump(obj, file)"},{"location":"python/modules/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/modules/#1-topshiriq","text":"math modulidan foydalanib, 10 ta sonning kvadrat ildizini hisoblovchi dastur yozing va natijalarni chiqaring.","title":"\u2705 1-topshiriq:"},{"location":"python/modules/#2-topshiriq","text":"random modulidan foydalanib, 1 dan 100 gacha bo\u2018lgan 5 ta tasodifiy butun sonlarni ro\u2018yxatga joylashtiring va ularni ekranga chiqaring.","title":"\u2705 2-topshiriq:"},{"location":"python/modules/#3-topshiriq","text":"datetime modulidan foydalanib, bugungi sanani va vaqtni formatlangan holda YYYY-MM-DD HH:MM:SS ko\u2018rinishida ekranga chiqaring.","title":"\u2705 3-topshiriq:"},{"location":"python/modules/#4-topshiriq","text":"O\u2018zingizning kichik modul faylingizni yarating ( mycalc.py ) va unga add(a, b) , subtract(a, b) , multiply(a, b) , divide(a, b) funksiyalarini yozing. Keyin ularni boshqa dasturga import qilib, natijalarni ko\u2018rsating.","title":"\u2705 4-topshiriq:"},{"location":"python/modules/#5-topshiriq","text":"math modulidan pi va sin funksiyalarini import qilib, 0 dan \u03c0 gacha bo\u2018lgan 5 ta qiymat uchun sinuslarini hisoblab chiqaring.","title":"\u2705 5-topshiriq:"},{"location":"python/modules/#6-topshiriq","text":"random.choice() funksiyasi yordamida ro\u2018yxatdan tasodifiy 3 ta ism tanlab, ularni ekranga chiqaring.","title":"\u2705 6-topshiriq:"},{"location":"python/modules/#7-topshiriq","text":"random.shuffle() yordamida berilgan ro\u2018yxat elementlarini aralashtiring va natijani chop eting.","title":"\u2705 7-topshiriq:"},{"location":"python/modules/#8-topshiriq","text":"datetime modulidan foydalanib, foydalanuvchidan yil, oy, kun kiritishini so\u2018rang va shu sanani datetime.date obyekti sifatida saqlang.","title":"\u2705 8-topshiriq:"},{"location":"python/modules/#9-topshiriq","text":"Yangi modul yarating, unga greet(name) funksiyasini yozing, u berilgan ismga salom beradi. Modulni import qilib, turli ismlar bilan chaqiring.","title":"\u2705 9-topshiriq:"},{"location":"python/modules/#10-topshiriq","text":"math modulining ceil va floor funksiyalarini import qilib, foydalanuvchi kiritgan haqiqiy son uchun ikkala qiymatni ham chiqaring.","title":"\u2705 10-topshiriq:"},{"location":"python/modules/#11-topshiriq","text":"O\u2018z modulingizda yangi funksiya yarating \u2014 is_even(number) \u2014 son juft yoki toqligini tekshiradi va True yoki False qaytaradi. Modulni import qilib, ro\u2018yxatdagi sonlarni tekshiring.","title":"\u2705 11-topshiriq:"},{"location":"python/modules/#12-topshiriq","text":"random modulidan foydalanib, 52 ta kartadan iborat ro\u2018yxat yarating (masalan: \"Queen of Hearts\", \"10 of Diamonds\", va hokazo), keyin tasodifiy 5 ta kartani tanlab chiqaring. (Diamonds, Hearts, Clubs, Spades)","title":"\u2705 12-topshiriq:"},{"location":"python/modules/#13-topshiriq","text":"datetime modulidan hozirgi vaqtni olib, uni soat, daqiqa va sekundga ajratib chiqaradigan dastur yozing.","title":"\u2705 13-topshiriq:"},{"location":"python/modules/#14-topshiriq","text":"Modulga yangi funksiyalar qo\u2018shing: factorial(n) va is_prime(n) , ularni o\u2018zingiz yozing (modulda) va keyin asosiy dasturda chaqiring.","title":"\u2705 14-topshiriq:"},{"location":"python/modules/#15-topshiriq","text":"math modulidan pow funksiyasini import qilib, foydalanuvchidan asosi va darajani qabul qilib, natijani hisoblang.","title":"\u2705 15-topshiriq:"},{"location":"python/moduls/","text":"\ud83e\udde9 13-DARS MODULS \u2705 MODUL NIMA? \ud83d\udccc Modul \u2014 bu Python fayli bo\u2018lib, u ichida funksiyalar , classlar , o\u2018zgaruvchilar , yoki boshqa Python kodlari saqlanadi. \ud83d\udccc Modulning asosiy vazifasi \u2014 kodni bo\u2018laklarga ajratish, tartibli saqlash va boshqa joylarda qayta ishlatish imkonini berish. \u2705 MODUL KERAKMI? NIMA FOYDA? \ud83d\udccc Quyidagi sabablarga ko\u2018ra modul foydali: Kod takrorlanmasligi \u2014 bir marta yozilgan kodni istalgan joyda qayta ishlatish mumkin. Kodlarni guruhlash \u2014 o\u2018xshash funksiyalar bitta faylga to\u2018plansa, ularni boshqarish oson bo\u2018ladi. Katta dasturlarni boshqarish osonlashadi \u2014 har bir qism alohida modul bo\u2018lsa, tuzilma soddalashadi. Test qilish oson \u2014 modulni alohida sinab ko\u2018rish mumkin. \u2705 MODULLARNI import QILISH \ud83d\udccc Pythonda modullardan foydalanish uchun avvalo ularni import qilish kerak. Modullarni import qilish uchun import kalit so'zidan foydalaniladi. # Dasturga tashqi yoki ichki modulni ulash (import qilish) uchun ishlatiladi # 'modul_nomi' o\u2018rniga kerakli modul nomi yoziladi (masalan: math, random, datetime va h.k.) import modul_nomi \ud83d\udccc math modulini import qilish # 'math' modulini import qilamiz, bu modulda matematik funksiyalar mavjud import math # Aylananing radiusi 5 ga teng deb belgilaymiz radius = 5 # Aylana yuzini hisoblaymiz: \u03c0 * r^2 formulasi asosida yuza = math.pi * radius**2 # Hisoblangan aylana yuzini ekranga chiqaramiz print(f\"Aylana yuzi: {yuza}\") \u2705 MODULLARDAN MUAYYAN QISMLARNI IMPORT QILISH \ud83d\udccc from modul_nomi import funksiya_yoki_object sintaksisi yordamida siz ma'lum bir moduldan faqat kerakli funksiya yoki o'zgaruvchini import qilishingiz mumkin. Bu sizga modulni to'liq import qilmasdan, faqat zaruriy qismlarini olish imkonini beradi. # Belgilangan modul ichidan faqat kerakli funksiya yoki obyektni import qilish uchun ishlatiladi # 'modul_nomi' \u2013 bu modul nomi (masalan: math, random, datetime) # 'funksiya_yoki_object' \u2013 modul ichidagi aniq bir funksiya, klass yoki o\u2018zgaruvchi nomi from modul_nomi import funksiya_yoki_object \ud83d\udccc math modulidan sqrt funksiyasini import qilish # 'math' modulidan faqat 'sqrt' (kvadrat ildiz) funksiyasini import qilamiz from math import sqrt # Kvadrat ildizi olinadigan sonni belgilaymiz son = 16 # Berilgan sonning kvadrat ildizini hisoblaymiz ildiz = sqrt(son) # Natijani ekranga chiqaramiz print(f\"{son} ning kvadrat ildizi: {ildiz}\") \u2705 MODULGA BOSHQA NOM BERISH \ud83d\udccc Modulni import qilishda unga qisqa yoki qulayroq nom berish uchun as operatoridan foydalanishingiz mumkin. # 'math' modulini 'm' degan qisqa nom bilan import qilamiz import math as m # Aylananing radiusini belgilaymiz radius = 7 # Aylananing diametrini hisoblaymiz: D = 2 * \u03c0 * r formulasi bo\u2018yicha diametr = 2 * m.pi * radius # Hisoblangan diametrni ekranga chiqaramiz print(f\"Aylananing diametri: {diametr}\") \u2705 MODUL YARATISH \ud83d\udccc Modul yaratish uchun asosiy dasturimizdagi funksiyalarni yangi faylga ko'chiramiz xolos. Modulga oson murojat qilishimiz uchun, faylimiz asosiy dasturimiz bilan bitta papkada bo'lishi kerak. Bunda adashib ketmaslik uchun, loyihangizning(dasturning) asosiy faylini main.py deb nomlash o'rinli. # mymodule.py - Bu modulda funksiyalar va klasslar jamlangan # Salomlashish uchun funksiya def greet(name): \"\"\"Salomlashish funktsiyasi.\"\"\" return f\"Salom, {name}!\" # Ikki sonni qo\u2018shish funksiyasi def add(a, b): \"\"\"Ikki sonni qo'shish funktsiyasi.\"\"\" return a + b # Ikki sonni ko\u2018paytirish funksiyasi def multiply(a, b): \"\"\"Ikki sonni ko'paytirish funktsiyasi.\"\"\" return a * b # Shaxslarni ifodalovchi klass class Person: \"\"\"Shaxs klassi.\"\"\" # Klassni ishga tushiruvchi konstruktor def __init__(self, name, age): self.name = name self.age = age # Shaxs haqida tanishtiruvchi metod def introduce(self): \"\"\"Shaxsni tanishtiruvchi metod.\"\"\" return f\"Men {self.name} va {self.age} yoshdaman.\" \u2705MODULDAN FOYDALANISH \ud83d\udccc Modul yaratganingizdan so'ng, uni boshqa Python dasturlarida import qilib ishlatishingiz mumkin. # mymodule modulini import qilamiz, undagi funksiyalar va klasslardan foydalanish uchun import mymodule # greet funksiyasini chaqirib, \"Ali\" ga salom beramiz print(mymodule.greet(\"Ali\")) # add funksiyasi yordamida 5 va 3 sonlarini qo\u2018shamiz va natijani chiqaramiz print(mymodule.add(5, 3)) # multiply funksiyasi yordamida 4 va 7 sonlarini ko\u2018paytiramiz va natijani chiqaramiz print(mymodule.multiply(4, 7)) # Person klassidan yangi obyekt yaratamiz, ism va yoshni beramiz person = mymodule.Person(\"Omar\", 25) # obyektning introduce metodini chaqirib, tanishtirish matnini chiqaramiz print(person.introduce()) \u2705 MODULNI KENGAYTIRISH \ud83d\udccc Modulga qo'shimcha funksiyalar yoki klasslar qo'shishingiz mumkin. # Ikki sondan birini ayirish funksiyasi def subtract(a, b): \"\"\"Ikki sondan birini ayirish funktsiyasi.\"\"\" return a - b # Ikki sonni bo'lish funksiyasi def divide(a, b): \"\"\"Ikki sonni bo'lish funktsiyasi.\"\"\" if b == 0: # Agar bo\u2018luvchi 0 bo\u2018lsa, xatolik chiqaramiz raise ValueError(\"Bo'lish uchun 0 bilan bo'lish mumkin emas!\") return a / b \u2705 FOYDALI MODULLAR \ud83d\udccc math MODULI \u2705 NIMA UCHUN FOYDALI? Matematik hisob-kitoblarni oson va aniq bajarish uchun kerak. Kvadrat ildiz, logarifm, trigonometrik funksiyalar, faktoriyal kabi ko\u2018plab matematik operatsiyalarni bajarish imkonini beradi. Dasturlashda murakkab matematik formulalarni ishlatishda yordam beradi. 1. math.ceil(x) \ud83d\udccc x sonini yuqoriga qarab yaxlitlaydi. Ya'ni, agar son butun emas bo\u2018lsa, keyingi eng yaqin butun songa oshiradi. Agar son butun bo\u2018lsa, o\u2018zi o\u2018zgarmaydi. # 'math' modulini import qilamiz import math # 5.1 sonini yuqoriga qarab butun songa yaxlitlaymiz (ceil funksiyasi) print(math.ceil(5.1)) # Natija: 6 # 5.9 sonini yuqoriga qarab butun songa yaxlitlaymiz print(math.ceil(5.9)) # Natija: 6 # Manfiy -3.4 sonini yuqoriga qarab yaxlitlaymiz (-3.4 dan katta eng kichik butun son -3) print(math.ceil(-3.4)) # Natija: -3 # 7 allaqachon butun son, shuning uchun o\u2018zgarmaydi print(math.ceil(7)) # Natija: 7 2. math.floor(x) \ud83d\udccc x sonini pastga qarab yaxlitlaydi. Ya'ni, agar son butun emas bo\u2018lsa, oldingi eng yaqin butun songa tushiradi. Agar son butun bo\u2018lsa, o\u2018zi o\u2018zgarmaydi. # 'math' modulini import qilamiz import math # 5.9 sonini pastga qarab butun songa yaxlitlaymiz (floor funksiyasi) print(math.floor(5.9)) # Natija: 5 # 5.1 sonini pastga qarab butun songa yaxlitlaymiz print(math.floor(5.1)) # Natija: 5 # Manfiy -3.4 sonini pastga qarab yaxlitlaymiz (-3.4 dan kichik eng katta butun son -4) print(math.floor(-3.4)) # Natija: -4 # 7 allaqachon butun son, shuning uchun o\u2018zgarmaydi print(math.floor(7)) # Natija: 7 random MODULI \ud83d\udccc random moduli \u2014 bu Python kutubxonasi bo\u2018lib, u yordamida tasodifiy sonlar, tasodifiy elementlar tanlash va ro\u2018yxatlarni aralashtirish mumkin. \u2705 NIMA UCHUN FOYDALI? O'yinlarda qahramonlar yoki voqealar uchun tasodifiylik yaratish uchun, Testlarda tasodifiy savollar tanlash uchun, Statistik tadqiqotlarda namuna olish uchun ishlatiladi. Shuningdek, har xil dasturlarda tasodifiy natijalar yaratishda qo\u2018llaniladi. 1. random.randint(a, b) \ud83d\udccc a va b orasidagi tasodifiy butun sonni qaytaradi (a va b ham shu oraliqqa kiradi). # random modulini import qilamiz, bu modul tasodifiy sonlar bilan ishlash uchun kerak import random # 1 dan 10 gacha (ikkala chegarani ham qo'shib) tasodifiy butun son hosil qilamiz son = random.randint(1, 10) # Hosil qilingan tasodifiy sonni ekranga chiqaramiz print(son) # 1 dan 10 gacha bo'lgan butun son (masalan, 3, 7, 10 va hokazo) 2. random.choice(sequence) \ud83d\udccc Berilgan ketma-ketlik (list, string yoki boshqa iterable) ichidan tasodifiy bitta elementni tanlaydi. # random modulini import qilamiz, tasodifiy element tanlash uchun kerak bo\u2018ladi import random # Mevalar ro\u2018yxatini yaratamiz mevalar = ['olma', 'banan', 'anor', 'shaftoli'] # Ro\u2018yxatdan tasodifiy bitta meva tanlaymiz tasodifiy_meva = random.choice(mevalar) # Tanlangan mevaning nomini ekranga chiqaramiz print(tasodifiy_meva) # masalan, 'anor' yoki 'banan' chiqishi mumkin 3. random.shuffle(list) \ud83d\udccc List elementlarini joyini tasodifiy tarzda almashtiradi (listni o\u2018zgartiradi). # random modulini import qilamiz, ro'yxat elementlarini aralashtirish uchun kerak import random # Raqamlar ro'yxatini yaratamiz raqamlar = [1, 2, 3, 4, 5] # Ro'yxatdagi elementlarni tasodifiy tartibda aralashtiramiz random.shuffle(raqamlar) # Aralashtirilgan ro'yxatni ekranga chiqaramiz print(raqamlar) # ro'yxat elementlari aralashadi, masalan, [3, 1, 5, 2, 4] datetime MODULI \ud83d\udccc datetime moduli - Python kutubxonasi bo\u2018lib, sana va vaqt bilan ishlash uchun ishlatiladi. \u2705 NIMA UCHUN FOYDALI? Vaqtni hisoblash (masalan, ikki sana orasidagi farqni topish) Hozirgi vaqtni olish Sanalarni formatlash va ko\u2018rsatish Muddatlarni qo\u2018shish yoki ayirish. 1. datetime.date.today() \ud83d\udccc Hozirgi kundagi sanani qaytaradi (faqat sana, vaqt emas). # datetime modulini import qilamiz, vaqt va sana bilan ishlash uchun kerak import datetime # Hozirgi sanani olish uchun today() funksiyasidan foydalanamiz bugun = datetime.date.today() # Olingan sanani ekranga chiqaramiz, masalan: 2025-06-06 print(bugun) # masalan, 2025-06-06 2. datetime.datetime.now() \ud83d\udccc Hozirgi sanani va vaqtni to\u2018liq qaytaradi (soat, daqiqa, soniya bilan). # datetime modulini import qilamiz, sana va vaqt bilan ishlash uchun kerak import datetime # Hozirgi sana va vaqtni olish uchun now() funksiyasidan foydalanamiz hozir = datetime.datetime.now() # Olingan sana va vaqtni ekranga chiqaramiz, masalan: 2025-06-06 15:30:25.123456 print(hozir) # masalan, 2025-06-06 15:30:25.123456 3. datetime.timedelta(days=5) \ud83d\udccc Vaqt oralig\u2018ini ifodalaydi. Masalan, 5 kun yoki 2 soat kabilarni yaratadi. # datetime modulini import qilamiz, sana va vaqt bilan ishlash uchun kerak import datetime # timedelta obyektini yaratamiz, bu 5 kunlik vaqt farqini ifodalaydi besh_kun = datetime.timedelta(days=5) # Hozirgi sanani olamiz bugun = datetime.date.today() # Bugungi sanaga 5 kun qo'shamiz, natijada kelasi sana hosil bo'ladi kelasi_sana = bugun + besh_kun # Kelasi sanani ekranga chiqaramiz print(kelasi_sana) # bugun sanadan 5 kun keyingi sana chiqadi \ud83d\udccc os MODULI os moduli \u2014 bu Python kutubxonasi bo\u2018lib, u orqali operatsion tizim bilan bog\u2018liq amallarni bajarish mumkin. \u2705 NIMA UCHUN FOYDALI? Fayllar va papkalar ustida amallar bajarish (yaratish, o\u2018chirish, ko\u2018rish) Biz ishlab turgan papkani yo'lini aniqlash Papka va fayllar bilan dastur orqali interaktiv ishlash 1. os.getcwd() \ud83d\udccc Biz ishlab turgan papkani (working directory) yo\u2018lini qaytaradi. # os modulini import qilamiz, operatsion tizim bilan bog\u2018liq funksiyalar uchun kerak import os # Hozirgi ishchi papkaning (current working directory) yo\u2018lini olamiz papka = os.getcwd() # Olingan papka yo\u2018lini ekranga chiqaramiz, masalan: /home/username/projects print(papka) # Masalan: /home/username/projects 2. os.listdir(path) \ud83d\udccc Berilgan papka ichidagi barcha fayl va papkalar ro\u2018yxatini beradi. # os modulini import qilamiz, operatsion tizim bilan ishlash uchun kerak import os # Hozirgi papkadagi barcha fayl va papkalar ro'yxatini olamiz fayllar = os.listdir('.') # '.' bu hozirgi ishlab turgan papkani bildiradi # Olingan fayl va papkalar ro'yxatini ekranga chiqaramiz print(fayllar) # Masalan: ['file1.txt', 'image.png', 'folder1'] 3. os.mkdir(name) \ud83d\udccc Yangi papka yaratadi. # os modulini import qilamiz, operatsion tizim bilan ishlash uchun kerak import os # 'yangi_papka' nomli yangi papka yaratamiz (agar mavjud bo'lmasa) os.mkdir('yangi_papka') # Papka yaratilib bo\u2018lgani haqida xabar beramiz print(\"Yangi papka yaratildi\") 3. os.remove(filename) \ud83d\udccc Faylni o\u2018chiradi. # os modulini import qilamiz, fayllar va papkalar bilan ishlash uchun kerak import os # 'eskifayl.txt' nomli faylni o'chiramiz (agar mavjud bo'lsa) os.remove('old_file.txt') # Fayl muvaffaqiyatli o'chirilgani haqida xabar beramiz print(\"Fayl o'chirildi\") \ud83d\udccc json MODULI \ud83d\udccc json moduli \u2014 bu Python kutubxonasi bo\u2018lib, JSON formatidagi ma\u2019lumotlar bilan ishlash uchun ishlatiladi. JSON \u2014 bu ma\u2019lumotlarni yozish va uzatishda keng qo\u2018llaniladigan standart format. Web dasturlashda, API (Application Programming Interface) lar bilan ishlashda juda muhim. \u2705 NIMA UCHUN FOYDALI? JSON formatidagi ma\u2019lumotlarni Python obyektlariga o\u2018qish, Python obyektlarini JSON formatiga yozish, API dan kelgan JSON javoblarini qayta ishlash, Ma\u2019lumotlarni faylga JSON formatida saqlash va o\u2018qish. json.loads(s) \ud83d\udccc JSON ko\u2018rinishidagi satrni Python obyektiga (list, dictionary va boshqalar) aylantiradi. # json modulini import qilamiz, JSON formatidagi ma'lumotlarni o'qish va yozish uchun kerak import json # JSON formatidagi satrni yaratamiz (string ko'rinishida) json_satr = '{\"ism\": \"Umid\", \"yosh\": 25}' # json.loads() funksiyasi yordamida JSON stringlarni Python dictionaryga aylantiramiz python_obj = json.loads(json_satr) # Python lug'atini ekranga chiqaramiz print(python_obj) # {'ism': 'Umid', 'yosh': 25} # Dictionarydan 'ism' kalitiga mos keluvchi qiymatni chiqaramiz print(python_obj['ism']) # Umid 2. json.dumps(obj) \ud83d\udccc Python obyektini JSON formatidagi stringga aylantiradi. # json modulini import qilamiz, JSON formatiga o\u2018tkazish va o\u2018qish uchun kerak import json # Python dictionary yaratamiz python_obj = {'ism': 'Umid', 'yosh': 25} # json.dumps() yordamida Python dictionaryni JSON formatidagi stringga aylantiramiz json_satr = json.dumps(python_obj) # JSON formatidagi stringni ekranga chiqaramiz print(json_satr) # '{\"ism\": \"Umid\", \"yosh\": 25}' 3. json.load(file) \ud83d\udccc JSON faylini o\u2018qiydi va Python obyektiga aylantiradi. # json modulini import qilamiz, JSON fayllarni o'qish va yozish uchun kerak import json # 'data.json' faylini o'qish uchun ochamiz ('r' - read rejimi) with open('data.json', 'r') as fayl: # fayldagi JSON ma'lumotlarni Python obyektiga (masalan, dictionary) o\u2018qiymiz malumot = json.load(fayl) # Olingan ma'lumotni ekranga chiqaramiz print(malumot) 4. json.dump(obj, file) \ud83d\udccc Python obyektini JSON faylga yozadi. # json modulini import qilamiz, JSON formatida yozish va o'qish uchun kerak import json # Python dictionary yaratamiz, uni JSON formatida faylga yozamiz data = {'ism': 'Umid', 'yosh': 25} # 'data.json' faylini yozish uchun ochamiz ('w' - write rejimi) with open('data.json', 'w') as fayl: # Python dictionaryni JSON formatida faylga yozamiz json.dump(data, fayl) \u2705 AMALIYOT \u2705 1-topshiriq: math modulidan foydalanib, 10 ta sonning kvadrat ildizini hisoblovchi dastur yozing va natijalarni chiqaring. \u2705 2-topshiriq: random modulidan foydalanib, 1 dan 100 gacha bo\u2018lgan 5 ta tasodifiy butun sonlarni ro\u2018yxatga joylashtiring va ularni ekranga chiqaring. \u2705 3-topshiriq: datetime modulidan foydalanib, bugungi sanani va vaqtni formatlangan holda YYYY-MM-DD HH:MM:SS ko\u2018rinishida ekranga chiqaring. \u2705 4-topshiriq: O\u2018zingizning kichik modul faylingizni yarating ( mycalc.py ) va unga add(a, b) , subtract(a, b) , multiply(a, b) , divide(a, b) funksiyalarini yozing. Keyin ularni boshqa dasturga import qilib, natijalarni ko\u2018rsating. \u2705 5-topshiriq: math modulidan pi va sin funksiyalarini import qilib, 0 dan \u03c0 gacha bo\u2018lgan 5 ta qiymat uchun sinuslarini hisoblab chiqaring. \u2705 6-topshiriq: random.choice() funksiyasi yordamida ro\u2018yxatdan tasodifiy 3 ta ism tanlab, ularni ekranga chiqaring. \u2705 7-topshiriq: random.shuffle() yordamida berilgan ro\u2018yxat elementlarini aralashtiring va natijani chop eting. \u2705 8-topshiriq: datetime modulidan foydalanib, foydalanuvchidan yil, oy, kun kiritishini so\u2018rang va shu sanani datetime.date obyekti sifatida saqlang. \u2705 9-topshiriq: Yangi modul yarating, unga greet(name) funksiyasini yozing, u berilgan ismga salom beradi. Modulni import qilib, turli ismlar bilan chaqiring. \u2705 10-topshiriq: math modulining ceil va floor funksiyalarini import qilib, foydalanuvchi kiritgan haqiqiy son uchun ikkala qiymatni ham chiqaring. \u2705 11-topshiriq: O\u2018z modulingizda yangi funksiya yarating \u2014 is_even(number) \u2014 son juft yoki toqligini tekshiradi va True yoki False qaytaradi. Modulni import qilib, ro\u2018yxatdagi sonlarni tekshiring. \u2705 12-topshiriq: random modulidan foydalanib, 52 ta kartadan iborat ro\u2018yxat yarating (masalan: \"Queen of Hearts\", \"10 of Diamonds\", va hokazo), keyin tasodifiy 5 ta kartani tanlab chiqaring. (Diamonds, Hearts, Clubs, Spades) \u2705 13-topshiriq: datetime modulidan hozirgi vaqtni olib, uni soat, daqiqa va sekundga ajratib chiqaradigan dastur yozing. \u2705 14-topshiriq: Modulga yangi funksiyalar qo\u2018shing: factorial(n) va is_prime(n) , ularni o\u2018zingiz yozing (modulda) va keyin asosiy dasturda chaqiring. \u2705 15-topshiriq: math modulidan pow funksiyasini import qilib, foydalanuvchidan asosi va darajani qabul qilib, natijani hisoblang.","title":"Moduls"},{"location":"python/moduls/#13-dars-moduls","text":"","title":"\ud83e\udde9 13-DARS MODULS"},{"location":"python/moduls/#modul-nima","text":"\ud83d\udccc Modul \u2014 bu Python fayli bo\u2018lib, u ichida funksiyalar , classlar , o\u2018zgaruvchilar , yoki boshqa Python kodlari saqlanadi. \ud83d\udccc Modulning asosiy vazifasi \u2014 kodni bo\u2018laklarga ajratish, tartibli saqlash va boshqa joylarda qayta ishlatish imkonini berish.","title":"\u2705 MODUL NIMA?"},{"location":"python/moduls/#modul-kerakmi-nima-foyda","text":"\ud83d\udccc Quyidagi sabablarga ko\u2018ra modul foydali: Kod takrorlanmasligi \u2014 bir marta yozilgan kodni istalgan joyda qayta ishlatish mumkin. Kodlarni guruhlash \u2014 o\u2018xshash funksiyalar bitta faylga to\u2018plansa, ularni boshqarish oson bo\u2018ladi. Katta dasturlarni boshqarish osonlashadi \u2014 har bir qism alohida modul bo\u2018lsa, tuzilma soddalashadi. Test qilish oson \u2014 modulni alohida sinab ko\u2018rish mumkin.","title":"\u2705 MODUL KERAKMI? NIMA FOYDA?"},{"location":"python/moduls/#modullarni-import-qilish","text":"\ud83d\udccc Pythonda modullardan foydalanish uchun avvalo ularni import qilish kerak. Modullarni import qilish uchun import kalit so'zidan foydalaniladi. # Dasturga tashqi yoki ichki modulni ulash (import qilish) uchun ishlatiladi # 'modul_nomi' o\u2018rniga kerakli modul nomi yoziladi (masalan: math, random, datetime va h.k.) import modul_nomi \ud83d\udccc math modulini import qilish # 'math' modulini import qilamiz, bu modulda matematik funksiyalar mavjud import math # Aylananing radiusi 5 ga teng deb belgilaymiz radius = 5 # Aylana yuzini hisoblaymiz: \u03c0 * r^2 formulasi asosida yuza = math.pi * radius**2 # Hisoblangan aylana yuzini ekranga chiqaramiz print(f\"Aylana yuzi: {yuza}\")","title":"\u2705 MODULLARNI import QILISH"},{"location":"python/moduls/#modullardan-muayyan-qismlarni-import-qilish","text":"\ud83d\udccc from modul_nomi import funksiya_yoki_object sintaksisi yordamida siz ma'lum bir moduldan faqat kerakli funksiya yoki o'zgaruvchini import qilishingiz mumkin. Bu sizga modulni to'liq import qilmasdan, faqat zaruriy qismlarini olish imkonini beradi. # Belgilangan modul ichidan faqat kerakli funksiya yoki obyektni import qilish uchun ishlatiladi # 'modul_nomi' \u2013 bu modul nomi (masalan: math, random, datetime) # 'funksiya_yoki_object' \u2013 modul ichidagi aniq bir funksiya, klass yoki o\u2018zgaruvchi nomi from modul_nomi import funksiya_yoki_object \ud83d\udccc math modulidan sqrt funksiyasini import qilish # 'math' modulidan faqat 'sqrt' (kvadrat ildiz) funksiyasini import qilamiz from math import sqrt # Kvadrat ildizi olinadigan sonni belgilaymiz son = 16 # Berilgan sonning kvadrat ildizini hisoblaymiz ildiz = sqrt(son) # Natijani ekranga chiqaramiz print(f\"{son} ning kvadrat ildizi: {ildiz}\")","title":"\u2705 MODULLARDAN MUAYYAN QISMLARNI IMPORT QILISH"},{"location":"python/moduls/#modulga-boshqa-nom-berish","text":"\ud83d\udccc Modulni import qilishda unga qisqa yoki qulayroq nom berish uchun as operatoridan foydalanishingiz mumkin. # 'math' modulini 'm' degan qisqa nom bilan import qilamiz import math as m # Aylananing radiusini belgilaymiz radius = 7 # Aylananing diametrini hisoblaymiz: D = 2 * \u03c0 * r formulasi bo\u2018yicha diametr = 2 * m.pi * radius # Hisoblangan diametrni ekranga chiqaramiz print(f\"Aylananing diametri: {diametr}\")","title":"\u2705 MODULGA BOSHQA NOM BERISH"},{"location":"python/moduls/#modul-yaratish","text":"\ud83d\udccc Modul yaratish uchun asosiy dasturimizdagi funksiyalarni yangi faylga ko'chiramiz xolos. Modulga oson murojat qilishimiz uchun, faylimiz asosiy dasturimiz bilan bitta papkada bo'lishi kerak. Bunda adashib ketmaslik uchun, loyihangizning(dasturning) asosiy faylini main.py deb nomlash o'rinli. # mymodule.py - Bu modulda funksiyalar va klasslar jamlangan # Salomlashish uchun funksiya def greet(name): \"\"\"Salomlashish funktsiyasi.\"\"\" return f\"Salom, {name}!\" # Ikki sonni qo\u2018shish funksiyasi def add(a, b): \"\"\"Ikki sonni qo'shish funktsiyasi.\"\"\" return a + b # Ikki sonni ko\u2018paytirish funksiyasi def multiply(a, b): \"\"\"Ikki sonni ko'paytirish funktsiyasi.\"\"\" return a * b # Shaxslarni ifodalovchi klass class Person: \"\"\"Shaxs klassi.\"\"\" # Klassni ishga tushiruvchi konstruktor def __init__(self, name, age): self.name = name self.age = age # Shaxs haqida tanishtiruvchi metod def introduce(self): \"\"\"Shaxsni tanishtiruvchi metod.\"\"\" return f\"Men {self.name} va {self.age} yoshdaman.\"","title":"\u2705 MODUL YARATISH"},{"location":"python/moduls/#moduldan-foydalanish","text":"\ud83d\udccc Modul yaratganingizdan so'ng, uni boshqa Python dasturlarida import qilib ishlatishingiz mumkin. # mymodule modulini import qilamiz, undagi funksiyalar va klasslardan foydalanish uchun import mymodule # greet funksiyasini chaqirib, \"Ali\" ga salom beramiz print(mymodule.greet(\"Ali\")) # add funksiyasi yordamida 5 va 3 sonlarini qo\u2018shamiz va natijani chiqaramiz print(mymodule.add(5, 3)) # multiply funksiyasi yordamida 4 va 7 sonlarini ko\u2018paytiramiz va natijani chiqaramiz print(mymodule.multiply(4, 7)) # Person klassidan yangi obyekt yaratamiz, ism va yoshni beramiz person = mymodule.Person(\"Omar\", 25) # obyektning introduce metodini chaqirib, tanishtirish matnini chiqaramiz print(person.introduce())","title":"\u2705MODULDAN FOYDALANISH"},{"location":"python/moduls/#modulni-kengaytirish","text":"\ud83d\udccc Modulga qo'shimcha funksiyalar yoki klasslar qo'shishingiz mumkin. # Ikki sondan birini ayirish funksiyasi def subtract(a, b): \"\"\"Ikki sondan birini ayirish funktsiyasi.\"\"\" return a - b # Ikki sonni bo'lish funksiyasi def divide(a, b): \"\"\"Ikki sonni bo'lish funktsiyasi.\"\"\" if b == 0: # Agar bo\u2018luvchi 0 bo\u2018lsa, xatolik chiqaramiz raise ValueError(\"Bo'lish uchun 0 bilan bo'lish mumkin emas!\") return a / b","title":"\u2705 MODULNI KENGAYTIRISH"},{"location":"python/moduls/#foydali-modullar","text":"","title":"\u2705 FOYDALI MODULLAR"},{"location":"python/moduls/#math-moduli","text":"","title":"\ud83d\udccc math MODULI"},{"location":"python/moduls/#nima-uchun-foydali","text":"Matematik hisob-kitoblarni oson va aniq bajarish uchun kerak. Kvadrat ildiz, logarifm, trigonometrik funksiyalar, faktoriyal kabi ko\u2018plab matematik operatsiyalarni bajarish imkonini beradi. Dasturlashda murakkab matematik formulalarni ishlatishda yordam beradi.","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/moduls/#1-mathceilx","text":"\ud83d\udccc x sonini yuqoriga qarab yaxlitlaydi. Ya'ni, agar son butun emas bo\u2018lsa, keyingi eng yaqin butun songa oshiradi. Agar son butun bo\u2018lsa, o\u2018zi o\u2018zgarmaydi. # 'math' modulini import qilamiz import math # 5.1 sonini yuqoriga qarab butun songa yaxlitlaymiz (ceil funksiyasi) print(math.ceil(5.1)) # Natija: 6 # 5.9 sonini yuqoriga qarab butun songa yaxlitlaymiz print(math.ceil(5.9)) # Natija: 6 # Manfiy -3.4 sonini yuqoriga qarab yaxlitlaymiz (-3.4 dan katta eng kichik butun son -3) print(math.ceil(-3.4)) # Natija: -3 # 7 allaqachon butun son, shuning uchun o\u2018zgarmaydi print(math.ceil(7)) # Natija: 7","title":"1. math.ceil(x)"},{"location":"python/moduls/#2-mathfloorx","text":"\ud83d\udccc x sonini pastga qarab yaxlitlaydi. Ya'ni, agar son butun emas bo\u2018lsa, oldingi eng yaqin butun songa tushiradi. Agar son butun bo\u2018lsa, o\u2018zi o\u2018zgarmaydi. # 'math' modulini import qilamiz import math # 5.9 sonini pastga qarab butun songa yaxlitlaymiz (floor funksiyasi) print(math.floor(5.9)) # Natija: 5 # 5.1 sonini pastga qarab butun songa yaxlitlaymiz print(math.floor(5.1)) # Natija: 5 # Manfiy -3.4 sonini pastga qarab yaxlitlaymiz (-3.4 dan kichik eng katta butun son -4) print(math.floor(-3.4)) # Natija: -4 # 7 allaqachon butun son, shuning uchun o\u2018zgarmaydi print(math.floor(7)) # Natija: 7","title":"2. math.floor(x)"},{"location":"python/moduls/#random-moduli","text":"\ud83d\udccc random moduli \u2014 bu Python kutubxonasi bo\u2018lib, u yordamida tasodifiy sonlar, tasodifiy elementlar tanlash va ro\u2018yxatlarni aralashtirish mumkin.","title":"random MODULI"},{"location":"python/moduls/#nima-uchun-foydali_1","text":"O'yinlarda qahramonlar yoki voqealar uchun tasodifiylik yaratish uchun, Testlarda tasodifiy savollar tanlash uchun, Statistik tadqiqotlarda namuna olish uchun ishlatiladi. Shuningdek, har xil dasturlarda tasodifiy natijalar yaratishda qo\u2018llaniladi.","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/moduls/#1-randomrandinta-b","text":"\ud83d\udccc a va b orasidagi tasodifiy butun sonni qaytaradi (a va b ham shu oraliqqa kiradi). # random modulini import qilamiz, bu modul tasodifiy sonlar bilan ishlash uchun kerak import random # 1 dan 10 gacha (ikkala chegarani ham qo'shib) tasodifiy butun son hosil qilamiz son = random.randint(1, 10) # Hosil qilingan tasodifiy sonni ekranga chiqaramiz print(son) # 1 dan 10 gacha bo'lgan butun son (masalan, 3, 7, 10 va hokazo)","title":"1. random.randint(a, b)"},{"location":"python/moduls/#2-randomchoicesequence","text":"\ud83d\udccc Berilgan ketma-ketlik (list, string yoki boshqa iterable) ichidan tasodifiy bitta elementni tanlaydi. # random modulini import qilamiz, tasodifiy element tanlash uchun kerak bo\u2018ladi import random # Mevalar ro\u2018yxatini yaratamiz mevalar = ['olma', 'banan', 'anor', 'shaftoli'] # Ro\u2018yxatdan tasodifiy bitta meva tanlaymiz tasodifiy_meva = random.choice(mevalar) # Tanlangan mevaning nomini ekranga chiqaramiz print(tasodifiy_meva) # masalan, 'anor' yoki 'banan' chiqishi mumkin","title":"2. random.choice(sequence)"},{"location":"python/moduls/#3-randomshufflelist","text":"\ud83d\udccc List elementlarini joyini tasodifiy tarzda almashtiradi (listni o\u2018zgartiradi). # random modulini import qilamiz, ro'yxat elementlarini aralashtirish uchun kerak import random # Raqamlar ro'yxatini yaratamiz raqamlar = [1, 2, 3, 4, 5] # Ro'yxatdagi elementlarni tasodifiy tartibda aralashtiramiz random.shuffle(raqamlar) # Aralashtirilgan ro'yxatni ekranga chiqaramiz print(raqamlar) # ro'yxat elementlari aralashadi, masalan, [3, 1, 5, 2, 4]","title":"3. random.shuffle(list)"},{"location":"python/moduls/#datetime-moduli","text":"\ud83d\udccc datetime moduli - Python kutubxonasi bo\u2018lib, sana va vaqt bilan ishlash uchun ishlatiladi.","title":"datetime MODULI"},{"location":"python/moduls/#nima-uchun-foydali_2","text":"Vaqtni hisoblash (masalan, ikki sana orasidagi farqni topish) Hozirgi vaqtni olish Sanalarni formatlash va ko\u2018rsatish Muddatlarni qo\u2018shish yoki ayirish.","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/moduls/#1-datetimedatetoday","text":"\ud83d\udccc Hozirgi kundagi sanani qaytaradi (faqat sana, vaqt emas). # datetime modulini import qilamiz, vaqt va sana bilan ishlash uchun kerak import datetime # Hozirgi sanani olish uchun today() funksiyasidan foydalanamiz bugun = datetime.date.today() # Olingan sanani ekranga chiqaramiz, masalan: 2025-06-06 print(bugun) # masalan, 2025-06-06","title":"1. datetime.date.today()"},{"location":"python/moduls/#2-datetimedatetimenow","text":"\ud83d\udccc Hozirgi sanani va vaqtni to\u2018liq qaytaradi (soat, daqiqa, soniya bilan). # datetime modulini import qilamiz, sana va vaqt bilan ishlash uchun kerak import datetime # Hozirgi sana va vaqtni olish uchun now() funksiyasidan foydalanamiz hozir = datetime.datetime.now() # Olingan sana va vaqtni ekranga chiqaramiz, masalan: 2025-06-06 15:30:25.123456 print(hozir) # masalan, 2025-06-06 15:30:25.123456","title":"2. datetime.datetime.now()"},{"location":"python/moduls/#3-datetimetimedeltadays5","text":"\ud83d\udccc Vaqt oralig\u2018ini ifodalaydi. Masalan, 5 kun yoki 2 soat kabilarni yaratadi. # datetime modulini import qilamiz, sana va vaqt bilan ishlash uchun kerak import datetime # timedelta obyektini yaratamiz, bu 5 kunlik vaqt farqini ifodalaydi besh_kun = datetime.timedelta(days=5) # Hozirgi sanani olamiz bugun = datetime.date.today() # Bugungi sanaga 5 kun qo'shamiz, natijada kelasi sana hosil bo'ladi kelasi_sana = bugun + besh_kun # Kelasi sanani ekranga chiqaramiz print(kelasi_sana) # bugun sanadan 5 kun keyingi sana chiqadi","title":"3. datetime.timedelta(days=5)"},{"location":"python/moduls/#os-moduli","text":"os moduli \u2014 bu Python kutubxonasi bo\u2018lib, u orqali operatsion tizim bilan bog\u2018liq amallarni bajarish mumkin.","title":"\ud83d\udccc os MODULI"},{"location":"python/moduls/#nima-uchun-foydali_3","text":"Fayllar va papkalar ustida amallar bajarish (yaratish, o\u2018chirish, ko\u2018rish) Biz ishlab turgan papkani yo'lini aniqlash Papka va fayllar bilan dastur orqali interaktiv ishlash","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/moduls/#1-osgetcwd","text":"\ud83d\udccc Biz ishlab turgan papkani (working directory) yo\u2018lini qaytaradi. # os modulini import qilamiz, operatsion tizim bilan bog\u2018liq funksiyalar uchun kerak import os # Hozirgi ishchi papkaning (current working directory) yo\u2018lini olamiz papka = os.getcwd() # Olingan papka yo\u2018lini ekranga chiqaramiz, masalan: /home/username/projects print(papka) # Masalan: /home/username/projects","title":"1. os.getcwd()"},{"location":"python/moduls/#2-oslistdirpath","text":"\ud83d\udccc Berilgan papka ichidagi barcha fayl va papkalar ro\u2018yxatini beradi. # os modulini import qilamiz, operatsion tizim bilan ishlash uchun kerak import os # Hozirgi papkadagi barcha fayl va papkalar ro'yxatini olamiz fayllar = os.listdir('.') # '.' bu hozirgi ishlab turgan papkani bildiradi # Olingan fayl va papkalar ro'yxatini ekranga chiqaramiz print(fayllar) # Masalan: ['file1.txt', 'image.png', 'folder1']","title":"2. os.listdir(path)"},{"location":"python/moduls/#3-osmkdirname","text":"\ud83d\udccc Yangi papka yaratadi. # os modulini import qilamiz, operatsion tizim bilan ishlash uchun kerak import os # 'yangi_papka' nomli yangi papka yaratamiz (agar mavjud bo'lmasa) os.mkdir('yangi_papka') # Papka yaratilib bo\u2018lgani haqida xabar beramiz print(\"Yangi papka yaratildi\")","title":"3. os.mkdir(name)"},{"location":"python/moduls/#3-osremovefilename","text":"\ud83d\udccc Faylni o\u2018chiradi. # os modulini import qilamiz, fayllar va papkalar bilan ishlash uchun kerak import os # 'eskifayl.txt' nomli faylni o'chiramiz (agar mavjud bo'lsa) os.remove('old_file.txt') # Fayl muvaffaqiyatli o'chirilgani haqida xabar beramiz print(\"Fayl o'chirildi\")","title":"3. os.remove(filename)"},{"location":"python/moduls/#json-moduli","text":"\ud83d\udccc json moduli \u2014 bu Python kutubxonasi bo\u2018lib, JSON formatidagi ma\u2019lumotlar bilan ishlash uchun ishlatiladi. JSON \u2014 bu ma\u2019lumotlarni yozish va uzatishda keng qo\u2018llaniladigan standart format. Web dasturlashda, API (Application Programming Interface) lar bilan ishlashda juda muhim.","title":"\ud83d\udccc json MODULI"},{"location":"python/moduls/#nima-uchun-foydali_4","text":"JSON formatidagi ma\u2019lumotlarni Python obyektlariga o\u2018qish, Python obyektlarini JSON formatiga yozish, API dan kelgan JSON javoblarini qayta ishlash, Ma\u2019lumotlarni faylga JSON formatida saqlash va o\u2018qish.","title":"\u2705 NIMA UCHUN FOYDALI?"},{"location":"python/moduls/#jsonloadss","text":"\ud83d\udccc JSON ko\u2018rinishidagi satrni Python obyektiga (list, dictionary va boshqalar) aylantiradi. # json modulini import qilamiz, JSON formatidagi ma'lumotlarni o'qish va yozish uchun kerak import json # JSON formatidagi satrni yaratamiz (string ko'rinishida) json_satr = '{\"ism\": \"Umid\", \"yosh\": 25}' # json.loads() funksiyasi yordamida JSON stringlarni Python dictionaryga aylantiramiz python_obj = json.loads(json_satr) # Python lug'atini ekranga chiqaramiz print(python_obj) # {'ism': 'Umid', 'yosh': 25} # Dictionarydan 'ism' kalitiga mos keluvchi qiymatni chiqaramiz print(python_obj['ism']) # Umid","title":"json.loads(s)"},{"location":"python/moduls/#2-jsondumpsobj","text":"\ud83d\udccc Python obyektini JSON formatidagi stringga aylantiradi. # json modulini import qilamiz, JSON formatiga o\u2018tkazish va o\u2018qish uchun kerak import json # Python dictionary yaratamiz python_obj = {'ism': 'Umid', 'yosh': 25} # json.dumps() yordamida Python dictionaryni JSON formatidagi stringga aylantiramiz json_satr = json.dumps(python_obj) # JSON formatidagi stringni ekranga chiqaramiz print(json_satr) # '{\"ism\": \"Umid\", \"yosh\": 25}'","title":"2. json.dumps(obj)"},{"location":"python/moduls/#3-jsonloadfile","text":"\ud83d\udccc JSON faylini o\u2018qiydi va Python obyektiga aylantiradi. # json modulini import qilamiz, JSON fayllarni o'qish va yozish uchun kerak import json # 'data.json' faylini o'qish uchun ochamiz ('r' - read rejimi) with open('data.json', 'r') as fayl: # fayldagi JSON ma'lumotlarni Python obyektiga (masalan, dictionary) o\u2018qiymiz malumot = json.load(fayl) # Olingan ma'lumotni ekranga chiqaramiz print(malumot)","title":"3. json.load(file)"},{"location":"python/moduls/#4-jsondumpobj-file","text":"\ud83d\udccc Python obyektini JSON faylga yozadi. # json modulini import qilamiz, JSON formatida yozish va o'qish uchun kerak import json # Python dictionary yaratamiz, uni JSON formatida faylga yozamiz data = {'ism': 'Umid', 'yosh': 25} # 'data.json' faylini yozish uchun ochamiz ('w' - write rejimi) with open('data.json', 'w') as fayl: # Python dictionaryni JSON formatida faylga yozamiz json.dump(data, fayl)","title":"4. json.dump(obj, file)"},{"location":"python/moduls/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/moduls/#1-topshiriq","text":"math modulidan foydalanib, 10 ta sonning kvadrat ildizini hisoblovchi dastur yozing va natijalarni chiqaring.","title":"\u2705 1-topshiriq:"},{"location":"python/moduls/#2-topshiriq","text":"random modulidan foydalanib, 1 dan 100 gacha bo\u2018lgan 5 ta tasodifiy butun sonlarni ro\u2018yxatga joylashtiring va ularni ekranga chiqaring.","title":"\u2705 2-topshiriq:"},{"location":"python/moduls/#3-topshiriq","text":"datetime modulidan foydalanib, bugungi sanani va vaqtni formatlangan holda YYYY-MM-DD HH:MM:SS ko\u2018rinishida ekranga chiqaring.","title":"\u2705 3-topshiriq:"},{"location":"python/moduls/#4-topshiriq","text":"O\u2018zingizning kichik modul faylingizni yarating ( mycalc.py ) va unga add(a, b) , subtract(a, b) , multiply(a, b) , divide(a, b) funksiyalarini yozing. Keyin ularni boshqa dasturga import qilib, natijalarni ko\u2018rsating.","title":"\u2705 4-topshiriq:"},{"location":"python/moduls/#5-topshiriq","text":"math modulidan pi va sin funksiyalarini import qilib, 0 dan \u03c0 gacha bo\u2018lgan 5 ta qiymat uchun sinuslarini hisoblab chiqaring.","title":"\u2705 5-topshiriq:"},{"location":"python/moduls/#6-topshiriq","text":"random.choice() funksiyasi yordamida ro\u2018yxatdan tasodifiy 3 ta ism tanlab, ularni ekranga chiqaring.","title":"\u2705 6-topshiriq:"},{"location":"python/moduls/#7-topshiriq","text":"random.shuffle() yordamida berilgan ro\u2018yxat elementlarini aralashtiring va natijani chop eting.","title":"\u2705 7-topshiriq:"},{"location":"python/moduls/#8-topshiriq","text":"datetime modulidan foydalanib, foydalanuvchidan yil, oy, kun kiritishini so\u2018rang va shu sanani datetime.date obyekti sifatida saqlang.","title":"\u2705 8-topshiriq:"},{"location":"python/moduls/#9-topshiriq","text":"Yangi modul yarating, unga greet(name) funksiyasini yozing, u berilgan ismga salom beradi. Modulni import qilib, turli ismlar bilan chaqiring.","title":"\u2705 9-topshiriq:"},{"location":"python/moduls/#10-topshiriq","text":"math modulining ceil va floor funksiyalarini import qilib, foydalanuvchi kiritgan haqiqiy son uchun ikkala qiymatni ham chiqaring.","title":"\u2705 10-topshiriq:"},{"location":"python/moduls/#11-topshiriq","text":"O\u2018z modulingizda yangi funksiya yarating \u2014 is_even(number) \u2014 son juft yoki toqligini tekshiradi va True yoki False qaytaradi. Modulni import qilib, ro\u2018yxatdagi sonlarni tekshiring.","title":"\u2705 11-topshiriq:"},{"location":"python/moduls/#12-topshiriq","text":"random modulidan foydalanib, 52 ta kartadan iborat ro\u2018yxat yarating (masalan: \"Queen of Hearts\", \"10 of Diamonds\", va hokazo), keyin tasodifiy 5 ta kartani tanlab chiqaring. (Diamonds, Hearts, Clubs, Spades)","title":"\u2705 12-topshiriq:"},{"location":"python/moduls/#13-topshiriq","text":"datetime modulidan hozirgi vaqtni olib, uni soat, daqiqa va sekundga ajratib chiqaradigan dastur yozing.","title":"\u2705 13-topshiriq:"},{"location":"python/moduls/#14-topshiriq","text":"Modulga yangi funksiyalar qo\u2018shing: factorial(n) va is_prime(n) , ularni o\u2018zingiz yozing (modulda) va keyin asosiy dasturda chaqiring.","title":"\u2705 14-topshiriq:"},{"location":"python/moduls/#15-topshiriq","text":"math modulidan pow funksiyasini import qilib, foydalanuvchidan asosi va darajani qabul qilib, natijani hisoblang.","title":"\u2705 15-topshiriq:"},{"location":"python/oop/","text":"\ud83e\udde9 17-DARS OOP (OBJECT-ORIENTED PROGRAMMING) [!NOTE] Object-Oriented Programming ( OOP ) Python dasturlash tilida muhim mavzulardan biri hisoblanadi va u orqali dasturlarni modulli, qayta foydalanish mumkin bo'lgan, tuzilmaviy kodlarni yaratish mumkin. Keling, OOPning asosiy tushunchalari va amaliy misollari bilan tanishib chiqamiz. Key OOP Principles: 1. Encapsulation (Inkapsulyatsiya) - Ma'lumotlarni va funksiyalarni (metodlarni) bitta birlikda, ya'ni ob'ekt ichida saqlashni ta'minlaydi. Bu ma'lumotlarni tashqi tomondan to'g'ridan-to'g'ri o'zgartirilmasligini ta'minlash uchun ishlatiladi. 2. Inheritance (Meros olish) - Bir klass (ota klass) xususiyatlarini boshqa klassga (farzand klass) o'tkazish imkoniyatini beradi, ya'ni yangi klassni mavjud klass asosida yaratish mumkin. 3. Polymorphism (Polimorfizm) - Bir xil nomdagi metodlarning turli xil sinflarda turlicha ishlash imkoniyatini beradi. 4. Abstraction (Abstraksiya) - Muhim detallarni ajratib olish va ortiqcha tafsilotlarni yashirishni ta'minlaydi. What is a class in Python? [!NOTE] class bu ma'lumotlar va ularni qayta ishlovchi funksiyalarni birlashtiruvchi shablon yoki qolip hisoblanadi. class yordamida obyektlar yaratamiz. Har bir obyekt biror class ning nusxasi hisoblanadi. Creating a Simple class class yaratish uchun class kalit so'zidan foydalanamiz va unga nom beramiz. class Car: def __init__(self, model, color): self.model = model self.color = color def display_info(self): print(f\"Model: {self.model}, Color: {self.color}\") Yuqoridagi misolda Car nomli class yaratilgan. __init__ metodi har safar yangi obyekt yaratilganda avtomatik ravishda chaqiriladi. Bu metod obyektni boshlang'ich holatini o'rnatadi. self bu obyektning o'zi, ya'ni yaratilgan obyektga murojaat qilish uchun ishlatiladi. Creating an Object class asosida obyekt yaratish uchun class nomiga qavs ichida kerakli parametrlarni yozamiz: class Car: def __init__(self, model, color): self.model = model self.color = color def display_info(self): print(f\"Model: {self.model}, Color: {self.color}\") my_car = Car(\"Chevrolet\", \"Black\") my_car.display_info() Bu kod Car classidan yangi my_car obyektini yaratadi va uning ma'lumotlarini qaytaradi. Natija quyidagicha bo'ladi: Model: Chevrolet, Color: Black Encapsulation(Inkapsulyatsiya) Encapsulation yordamida class dagi xususiyatlar ( property ) va metodlarni yashirish mumkin. Bu o'zgaruvchilarning to'g'ridan-to'g'ri o'zgartirilishini oldini olib, maxsus metodlar orqali ularga kirishni ta'minlaydi. Pythonda private( xususiy ) o'zgaruvchilarni yaratish uchun o'zgaruvchining nomi oldiga ikki pastki chiziq ( __ ) qo'yamiz: class BankAccount: def __init__(self, balance): self.__balance = balance # private attribute def deposit(self, amount): if amount > 0: self.__balance += amount print(f\"{amount} deposited. New balance: {self.__balance}\") else: print(\"Invalid deposit amount\") def withdraw(self, amount): if amount <= self.__balance: self.__balance -= amount print(f\"{amount} withdrawn. New balance: {self.__balance}\") else: print(\"Insufficient funds\") # BankAccount ob'ektini yaratamiz va unga pul qo'shamiz account = BankAccount(1000) account.deposit(500) # 500 deposited. New balance: 1500 account.withdraw(200) # 200 withdrawn. New balance: 1300 Yuqorida __balance xususiyati to'g'ridan-to'g'ri obyektdan kirish mumkin emas, faqat deposit va withdraw metodlari orqali o'zgartiriladi. Inheritance(Meros olish) Meros olish boshqa class dan xususiyatlar va metodlarni meros qilib olish imkonini beradi, bu orqali kod qayta ishlatiladi. Keling, Car va ElectricCar misollarini yanada kengaytiramiz. class Car: def __init__(self, model, color, year): self.model = model self.color = color self.year = year def drive(self): print(f\"{self.model} is driving\") def stop(self): print(f\"{self.model} has stopped\") class ElectricCar(Car): def __init__(self, model, color, year, battery_size): super().__init__(model, color, year) # Ota klass `Car` ning __init__ metodini chaqiramiz self.battery_size = battery_size def charge(self): print(f\"{self.model} is charging. Battery size: {self.battery_size} kWh\") tesla = ElectricCar(\"Tesla Model S\", \"Red\", 2023, 100) tesla.drive() # Tesla Model S is driving tesla.charge() # Tesla Model S is charging. Battery size: 100 kWh tesla.stop() # Tesla Model S has stopped Bu yerda ElectricCar classi Car classidan meros oladi va qo'shimcha charge metodini qo'shadi: Natija: Model: Tesla, Color: White Battery size: 75 kWh Polymorphism(Polimorfizm) Polimorfizm bir xil nomdagi metodlarning turli class larda turlicha ishlashini anglatadi. Bu OOP da muhim bo'lib, turli ob'ektlarga bir xil metodni qo'llash imkonini beradi. class Bird: def sound(self): print(\"Bird makes a sound\") class Parrot(Bird): def sound(self): print(\"Parrot says hello\") class Sparrow(Bird): def sound(self): print(\"Sparrow chirps\") Yuqorida Parrot va Sparrow classlari Bird classidan meros olgan, lekin har bir classda sound metodi turlicha bajariladi: class Bird: def sound(self): print(\"Bird makes a sound\") class Parrot(Bird): def sound(self): print(\"Parrot says hello\") class Sparrow(Bird): def sound(self): print(\"Sparrow chirps\") def make_sound(bird): bird.sound() parrot = Parrot() sparrow = Sparrow() make_sound(parrot) # Parrot says hello make_sound(sparrow) # Sparrow chirps Abstraction(Abstraksiya) Abstraksiya yordamida foydalanuvchilar faqat kerakli metod va atribut larga kirishi mumkin bo'ladi. Pythonda to\u2018g\u2018ridan-to\u2018g\u2018ri abstrakt classlar mavjud emas, ammo abc ( Abstract Base Classes ) modulidan foydalanib, abstrakt class yaratish mumkin. Keling, hayvonlar misolida ko'ramiz: from abc import ABC, abstractmethod class Animal(ABC): @abstractmethod def sound(self): pass class Dog(Animal): def sound(self): print(\"Woof!\") class Cat(Animal): def sound(self): print(\"Meow!\") dog = Dog() cat = Cat() dog.sound() # Woof! cat.sound() # Meow! Bu yerda Animal class i abstract class bo'lib, undagi sound metodi barcha farzand classlarida aniqlanishi kerak. Dog va Cat classlarida sound metodini har xil bajarish mumkin. AMALIYOT class yaratish Book classini yarating. U quyidagi atributlarga ega bo'lishi kerak: title ( nomi ) author ( muallifi ) year ( nashr yili ) Shuningdek, classda display_info metodini qo'shing, u kitob haqida ma'lumotlarni chiqarishi kerak. class Book: # Bu yerga kod yozing Instansiya O'zgaruvchilarini Qo'llash Yuqoridagi Book classini davom ettiring va unda get_age metodini qo'shing. Bu metod kitobning bugungi kunga nisbatan yoshini hisoblash kerak ( hozirgi yil - nashr yili ). class Book: # Bu yerga kod yozing Meros Olish Book classidan meros oluvchi Ebook classini yarating. Ebook classi quyidagi qo'shimcha atributga ega bo'lishi kerak: file_size ( fayl o'lchami ) Ebook classida display_info metodini yangilang va unda fayl o'lchamini ko'rsatish uchun ma'lumotlarni chiqarishi kerak. class Book: # Bu yerga kod yozing class Ebook(Book): # Bu yerga kod yozing Inkapsulyatsiya BankAccount classini yarating, unda maxfiy __balance atributi bo'lishi kerak. classda quyidagi metodlar bo'lishi kerak: deposit ( amount ) - hisobga pul qo'shish. withdraw ( amount ) - hisobdan pul yechib olish. get_balance() - hisobdagi mablag'ni ko'rsatish. class BankAccount: # Bu yerga kod yozing classlararo Aloqa Author classini yarating, unda name va books atributlari bo'lishi kerak. books - bu Book classidan iborat ro'yxat. Author classida quyidagi metodlar bo'lishi kerak: add_book ( book ) - yangi kitob qo'shish. display_books() - muallifga tegishli kitoblarni ko'rsatish. class Author: # Bu yerga kod yozing Barcha Tuzilmalarni Qo'llash Yangi dastur yarating, unda Library classini yarating. Library classida quyidagi atributlar bo'lishi kerak: name ( kutubxona nomi ) books ( kitoblar ro'yxati ) Library classida quyidagi metodlar bo'lishi kerak: add_book ( book ) - kutubxonaga kitob qo'shish. remove_book ( title ) - kutubxonadan kitobni olib tashlash. display_books() - kutubxonadagi kitoblarni ko'rsatish. class Library: # Bu yerga kod yozing Avtobus classini yaratish Bus classini yarating, bu class quyidagi atributlarga ega bo'lishi kerak: bus_number ( avtobus raqami ) capacity ( sig'imi ) passengers ( yo'lovchilar ro'yxati ) Bus classida quyidagi metodlar bo'lishi kerak: add_passenger ( passenger ) - avtobusga yo'lovchi qo'shish. remove_passenger ( passenger ) - avtobusdan yo'lovchini olib tashlash. display_passengers() - avtobusdagi barcha yo'lovchilarni ko'rsatish. class Bus: # Bu yerga kod yozing Avtobusdan meros olish DoubleDeckerBus classini Bus classidan meros qilib oling. Bu classda qo'shimcha atributlar sifatida upper_capacity (yuqori qavat sig'imi) va lower_capacity (pastki qavat sig'imi) bo'lishi kerak. DoubleDeckerBus klassida add_passenger metodini yangilang, shunda u har ikki qavatda yo'lovchilarni hisobga olishi kerak. class Bus: # Bu yerga kod yozing class DoubleDeckerBus(Bus): # Bu yerga kod yozing Mashinalar garaji Garage classini yarating, bu classda quyidagi atributlar bo'lishi kerak: name ( garaj nomi ) cars ( mashinalar ro'yxati ) Garage classida quyidagi metodlar bo'lishi kerak: add_car ( car ) - garajga mashina qo'shish. remove_car ( car ) - garajdan mashinani olib tashlash. display_cars() - garajdagi barcha mashinalarni ko'rsatish. class Garage: # Bu yerga kod yozing Qo'shimcha muallif classini yaratish Publisher classini yarating, unda name va books atributlari bo'lishi kerak. books - bu Book classidan iborat ro'yxat. Publisher classida quyidagi metodlar bo'lishi kerak: add_book ( book ) - nashriyotga kitob qo'shish. remove_book ( title ) - nashriyotdan kitobni olib tashlash. display_books() - nashriyotdagi kitoblarni ko'rsatish. class Publisher: # Bu yerga kod yozing","title":"OOP"},{"location":"python/oop/#17-dars-oop-object-oriented-programming","text":"[!NOTE] Object-Oriented Programming ( OOP ) Python dasturlash tilida muhim mavzulardan biri hisoblanadi va u orqali dasturlarni modulli, qayta foydalanish mumkin bo'lgan, tuzilmaviy kodlarni yaratish mumkin. Keling, OOPning asosiy tushunchalari va amaliy misollari bilan tanishib chiqamiz. Key OOP Principles: 1. Encapsulation (Inkapsulyatsiya) - Ma'lumotlarni va funksiyalarni (metodlarni) bitta birlikda, ya'ni ob'ekt ichida saqlashni ta'minlaydi. Bu ma'lumotlarni tashqi tomondan to'g'ridan-to'g'ri o'zgartirilmasligini ta'minlash uchun ishlatiladi. 2. Inheritance (Meros olish) - Bir klass (ota klass) xususiyatlarini boshqa klassga (farzand klass) o'tkazish imkoniyatini beradi, ya'ni yangi klassni mavjud klass asosida yaratish mumkin. 3. Polymorphism (Polimorfizm) - Bir xil nomdagi metodlarning turli xil sinflarda turlicha ishlash imkoniyatini beradi. 4. Abstraction (Abstraksiya) - Muhim detallarni ajratib olish va ortiqcha tafsilotlarni yashirishni ta'minlaydi.","title":"\ud83e\udde9 17-DARS OOP (OBJECT-ORIENTED PROGRAMMING)"},{"location":"python/oop/#what-is-a-class-in-python","text":"[!NOTE] class bu ma'lumotlar va ularni qayta ishlovchi funksiyalarni birlashtiruvchi shablon yoki qolip hisoblanadi. class yordamida obyektlar yaratamiz. Har bir obyekt biror class ning nusxasi hisoblanadi.","title":"What is a class in Python?"},{"location":"python/oop/#creating-a-simple-class","text":"class yaratish uchun class kalit so'zidan foydalanamiz va unga nom beramiz. class Car: def __init__(self, model, color): self.model = model self.color = color def display_info(self): print(f\"Model: {self.model}, Color: {self.color}\") Yuqoridagi misolda Car nomli class yaratilgan. __init__ metodi har safar yangi obyekt yaratilganda avtomatik ravishda chaqiriladi. Bu metod obyektni boshlang'ich holatini o'rnatadi. self bu obyektning o'zi, ya'ni yaratilgan obyektga murojaat qilish uchun ishlatiladi.","title":"Creating a Simple class"},{"location":"python/oop/#creating-an-object","text":"class asosida obyekt yaratish uchun class nomiga qavs ichida kerakli parametrlarni yozamiz: class Car: def __init__(self, model, color): self.model = model self.color = color def display_info(self): print(f\"Model: {self.model}, Color: {self.color}\") my_car = Car(\"Chevrolet\", \"Black\") my_car.display_info() Bu kod Car classidan yangi my_car obyektini yaratadi va uning ma'lumotlarini qaytaradi. Natija quyidagicha bo'ladi: Model: Chevrolet, Color: Black","title":"Creating an Object"},{"location":"python/oop/#encapsulationinkapsulyatsiya","text":"Encapsulation yordamida class dagi xususiyatlar ( property ) va metodlarni yashirish mumkin. Bu o'zgaruvchilarning to'g'ridan-to'g'ri o'zgartirilishini oldini olib, maxsus metodlar orqali ularga kirishni ta'minlaydi. Pythonda private( xususiy ) o'zgaruvchilarni yaratish uchun o'zgaruvchining nomi oldiga ikki pastki chiziq ( __ ) qo'yamiz: class BankAccount: def __init__(self, balance): self.__balance = balance # private attribute def deposit(self, amount): if amount > 0: self.__balance += amount print(f\"{amount} deposited. New balance: {self.__balance}\") else: print(\"Invalid deposit amount\") def withdraw(self, amount): if amount <= self.__balance: self.__balance -= amount print(f\"{amount} withdrawn. New balance: {self.__balance}\") else: print(\"Insufficient funds\") # BankAccount ob'ektini yaratamiz va unga pul qo'shamiz account = BankAccount(1000) account.deposit(500) # 500 deposited. New balance: 1500 account.withdraw(200) # 200 withdrawn. New balance: 1300 Yuqorida __balance xususiyati to'g'ridan-to'g'ri obyektdan kirish mumkin emas, faqat deposit va withdraw metodlari orqali o'zgartiriladi.","title":"Encapsulation(Inkapsulyatsiya)"},{"location":"python/oop/#inheritancemeros-olish","text":"Meros olish boshqa class dan xususiyatlar va metodlarni meros qilib olish imkonini beradi, bu orqali kod qayta ishlatiladi. Keling, Car va ElectricCar misollarini yanada kengaytiramiz. class Car: def __init__(self, model, color, year): self.model = model self.color = color self.year = year def drive(self): print(f\"{self.model} is driving\") def stop(self): print(f\"{self.model} has stopped\") class ElectricCar(Car): def __init__(self, model, color, year, battery_size): super().__init__(model, color, year) # Ota klass `Car` ning __init__ metodini chaqiramiz self.battery_size = battery_size def charge(self): print(f\"{self.model} is charging. Battery size: {self.battery_size} kWh\") tesla = ElectricCar(\"Tesla Model S\", \"Red\", 2023, 100) tesla.drive() # Tesla Model S is driving tesla.charge() # Tesla Model S is charging. Battery size: 100 kWh tesla.stop() # Tesla Model S has stopped Bu yerda ElectricCar classi Car classidan meros oladi va qo'shimcha charge metodini qo'shadi: Natija: Model: Tesla, Color: White Battery size: 75 kWh","title":"Inheritance(Meros olish)"},{"location":"python/oop/#polymorphismpolimorfizm","text":"Polimorfizm bir xil nomdagi metodlarning turli class larda turlicha ishlashini anglatadi. Bu OOP da muhim bo'lib, turli ob'ektlarga bir xil metodni qo'llash imkonini beradi. class Bird: def sound(self): print(\"Bird makes a sound\") class Parrot(Bird): def sound(self): print(\"Parrot says hello\") class Sparrow(Bird): def sound(self): print(\"Sparrow chirps\") Yuqorida Parrot va Sparrow classlari Bird classidan meros olgan, lekin har bir classda sound metodi turlicha bajariladi: class Bird: def sound(self): print(\"Bird makes a sound\") class Parrot(Bird): def sound(self): print(\"Parrot says hello\") class Sparrow(Bird): def sound(self): print(\"Sparrow chirps\") def make_sound(bird): bird.sound() parrot = Parrot() sparrow = Sparrow() make_sound(parrot) # Parrot says hello make_sound(sparrow) # Sparrow chirps","title":"Polymorphism(Polimorfizm)"},{"location":"python/oop/#abstractionabstraksiya","text":"Abstraksiya yordamida foydalanuvchilar faqat kerakli metod va atribut larga kirishi mumkin bo'ladi. Pythonda to\u2018g\u2018ridan-to\u2018g\u2018ri abstrakt classlar mavjud emas, ammo abc ( Abstract Base Classes ) modulidan foydalanib, abstrakt class yaratish mumkin. Keling, hayvonlar misolida ko'ramiz: from abc import ABC, abstractmethod class Animal(ABC): @abstractmethod def sound(self): pass class Dog(Animal): def sound(self): print(\"Woof!\") class Cat(Animal): def sound(self): print(\"Meow!\") dog = Dog() cat = Cat() dog.sound() # Woof! cat.sound() # Meow! Bu yerda Animal class i abstract class bo'lib, undagi sound metodi barcha farzand classlarida aniqlanishi kerak. Dog va Cat classlarida sound metodini har xil bajarish mumkin.","title":"Abstraction(Abstraksiya)"},{"location":"python/oop/#amaliyot","text":"class yaratish Book classini yarating. U quyidagi atributlarga ega bo'lishi kerak: title ( nomi ) author ( muallifi ) year ( nashr yili ) Shuningdek, classda display_info metodini qo'shing, u kitob haqida ma'lumotlarni chiqarishi kerak. class Book: # Bu yerga kod yozing Instansiya O'zgaruvchilarini Qo'llash Yuqoridagi Book classini davom ettiring va unda get_age metodini qo'shing. Bu metod kitobning bugungi kunga nisbatan yoshini hisoblash kerak ( hozirgi yil - nashr yili ). class Book: # Bu yerga kod yozing Meros Olish Book classidan meros oluvchi Ebook classini yarating. Ebook classi quyidagi qo'shimcha atributga ega bo'lishi kerak: file_size ( fayl o'lchami ) Ebook classida display_info metodini yangilang va unda fayl o'lchamini ko'rsatish uchun ma'lumotlarni chiqarishi kerak. class Book: # Bu yerga kod yozing class Ebook(Book): # Bu yerga kod yozing Inkapsulyatsiya BankAccount classini yarating, unda maxfiy __balance atributi bo'lishi kerak. classda quyidagi metodlar bo'lishi kerak: deposit ( amount ) - hisobga pul qo'shish. withdraw ( amount ) - hisobdan pul yechib olish. get_balance() - hisobdagi mablag'ni ko'rsatish. class BankAccount: # Bu yerga kod yozing classlararo Aloqa Author classini yarating, unda name va books atributlari bo'lishi kerak. books - bu Book classidan iborat ro'yxat. Author classida quyidagi metodlar bo'lishi kerak: add_book ( book ) - yangi kitob qo'shish. display_books() - muallifga tegishli kitoblarni ko'rsatish. class Author: # Bu yerga kod yozing Barcha Tuzilmalarni Qo'llash Yangi dastur yarating, unda Library classini yarating. Library classida quyidagi atributlar bo'lishi kerak: name ( kutubxona nomi ) books ( kitoblar ro'yxati ) Library classida quyidagi metodlar bo'lishi kerak: add_book ( book ) - kutubxonaga kitob qo'shish. remove_book ( title ) - kutubxonadan kitobni olib tashlash. display_books() - kutubxonadagi kitoblarni ko'rsatish. class Library: # Bu yerga kod yozing Avtobus classini yaratish Bus classini yarating, bu class quyidagi atributlarga ega bo'lishi kerak: bus_number ( avtobus raqami ) capacity ( sig'imi ) passengers ( yo'lovchilar ro'yxati ) Bus classida quyidagi metodlar bo'lishi kerak: add_passenger ( passenger ) - avtobusga yo'lovchi qo'shish. remove_passenger ( passenger ) - avtobusdan yo'lovchini olib tashlash. display_passengers() - avtobusdagi barcha yo'lovchilarni ko'rsatish. class Bus: # Bu yerga kod yozing Avtobusdan meros olish DoubleDeckerBus classini Bus classidan meros qilib oling. Bu classda qo'shimcha atributlar sifatida upper_capacity (yuqori qavat sig'imi) va lower_capacity (pastki qavat sig'imi) bo'lishi kerak. DoubleDeckerBus klassida add_passenger metodini yangilang, shunda u har ikki qavatda yo'lovchilarni hisobga olishi kerak. class Bus: # Bu yerga kod yozing class DoubleDeckerBus(Bus): # Bu yerga kod yozing Mashinalar garaji Garage classini yarating, bu classda quyidagi atributlar bo'lishi kerak: name ( garaj nomi ) cars ( mashinalar ro'yxati ) Garage classida quyidagi metodlar bo'lishi kerak: add_car ( car ) - garajga mashina qo'shish. remove_car ( car ) - garajdan mashinani olib tashlash. display_cars() - garajdagi barcha mashinalarni ko'rsatish. class Garage: # Bu yerga kod yozing Qo'shimcha muallif classini yaratish Publisher classini yarating, unda name va books atributlari bo'lishi kerak. books - bu Book classidan iborat ro'yxat. Publisher classida quyidagi metodlar bo'lishi kerak: add_book ( book ) - nashriyotga kitob qo'shish. remove_book ( title ) - nashriyotdan kitobni olib tashlash. display_books() - nashriyotdagi kitoblarni ko'rsatish. class Publisher: # Bu yerga kod yozing","title":"AMALIYOT"},{"location":"python/operators/","text":"\ud83e\udde9 3-DARS OPERATORS Python operatorlarini quyidagi guruhlarga bo'lish mumkin: Arifmetik operatorlar Taqqoslash operatorlari Mantiqiy operatorlar Bitwise (Bitli) operatorlar Tayinlash (Assign) operatorlari A'zolik (Membership) operatorlari Identifikatsiya (Identity) operatorlari Aralashtirilgan operatorlar (Mixed Operators) \u2705 ARIFMETIK OPERATORLAR \ud83d\udccc Python dasturlash tilida arifmetik operatorlar \u2014 sonlar ustida hisob-kitob qilish uchun ishlatiladigan maxsus belgilar yoki ifodalardir. Ular yordamida qo\u2018shish, ayirish, ko\u2018paytirish, bo\u2018lish kabi oddiy matematik amallarni bajarish mumkin. # a va b o'zgaruvchilariga qiymat beramiz a = 10 b = 3 # Qo\u2018shish amali: a + b yigindi = a + b print(yigindi) # Natija: 13 # Ayirish amali: a - b ayirma = a - b print(ayirma) # Natija: 7 # Ko\u2018paytirish amali: a * b kopaytma = a * b print(kopaytma) # Natija: 30 # Bo\u2018lish amali (natija float): a / b bolish = a / b print(bolish) # Natija: 3.3333333333333335 # Butun qismga bo\u2018lish: a // b (natija butun son) butun_qism = a // b print(butun_qism) # Natija: 3 # Qoldiqni topish: a % b qoldiq = a % b print(qoldiq) # Natija: 1 # Darajaga ko\u2018tarish: a ** b (10 ning 3-darajasi) daraja = a ** b print(daraja) # Natija: 1000 \u2705 TAQQOSLASH OPERATORLARI \ud83d\udccc Python dasturlash tilida taqqoslash operatorlari (comparison operators) \u2014 ikki qiymatni taqqoslash uchun ishlatiladi. Ular natijada True yoki False (ya'ni mantiqiy qiymat) qaytaradi. 1. \u2747\ufe0f TENGMI == Ikkita qiymat teng bo\u2018lsa, True , aks holda False qaytaradi. # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' va 'b' tengmi degan shart natijasi berilyapti # Bu yerda 5 == 3 bo'lmagani uchun natija False bo'ladi result = (a == b) # False, chunki 5 \u2260 3 # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: False 2. \u2747\ufe0f TENG EMAS != \ud83d\udccc Qiymatlar bir-biriga teng bo\u2018lmasa, True qaytaradi. # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' va 'b' teng emasmi degan shart natijasi berilyapti # Bu yerda 5 != 3 bo'lgani uchun natija True bo'ladi result = (a != b) # True, chunki 5 \u2260 3 # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: True 3. \u2747\ufe0f KATTA > \ud83d\udccc Chap tomondagi qiymat o\u2018ng tomondagidan katta bo\u2018lsa, True . # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' > 'b' sharti natijasi berilyapti # Bu yerda 5 > 3 bo'lgani uchun natija True bo'ladi result = (a > b) # True, chunki 5 > 3 # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: True 4. \u2747\ufe0f KICHIK < \ud83d\udccc Chap tomondagi qiymat o\u2018ng tomondagidan kichik bo\u2018lsa, True . # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' < 'b' (ya'ni 5 < 3) sharti tekshirilmoqda # Bu shart noto\u2018g\u2018ri, chunki 5 kichik emas 3 dan \u2014 natija: False result = (a < b) # False, chunki 5 < 3 emas # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: False 5. \u2747\ufe0f KATTA YOKI TENG >= \ud83d\udccc Agar chap tomondagi qiymat katta yoki teng bo\u2018lsa, True . # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' >= 'b' (ya'ni 5 katta yoki teng 3) sharti tekshirilmoqda # Bu shart to\u2018g\u2018ri, chunki 5 katta 3 dan \u2014 natija: True result = (a >= b) # True, chunki 5 >= 3 # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: True 6. \u2747\ufe0f KICHIK YOKI TENG (<=) \ud83d\udccc Agar chap tomondagi qiymat kichik yoki teng bo\u2018lsa, True . # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' <= 'b' (ya'ni 5 kichik yoki teng 3) sharti tekshirilmoqda # Bu shart noto\u2018g\u2018ri, chunki 5 kichik emas va 5 teng ham emas 3 ga \u2014 natija: False result = (a <= b) # False, chunki 5 <= 3 emas # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: False \u2705 MANTIQIY OPERATORLAR \ud83d\udccc Python dasturlash tilida mantiqiy operatorlar (logical operators) shartlarni solishtirishda ishlatiladi va ular True yoki False qiymatlar bilan ishlaydi. Ular bir nechta shartlarni birlashtirish yoki tahlil qilish uchun qo\u02bbllaniladi. 1. \u2747\ufe0f AND \ud83d\udccc Bu operator ikkala shart True bo\u02bblsa, True qaytaradi. # 'a' o'zgaruvchisiga True (rost) qiymati berilmoqda a = True # 'b' o'zgaruvchisiga False (yolg'on) qiymati berilmoqda b = False # 'result' o'zgaruvchisiga 'a and b' mantiqiy ifodasi natijasi berilmoqda # AND operatori ikkala qiymat ham True bo'lsa, True qaytaradi. Aks holda False. # Bu yerda: True and False \u2192 natija: False result = a and b # result False ga teng bo'ladi # 'result' ni ekranga chiqaramiz print(result) # Natija: False 2. \u2747\ufe0f OR \ud83d\udccc Hech bo'lmaganda bitta shart True bo'lsa, natija True bo'ladi, aks holda False . # 'a' o'zgaruvchisiga True (rost) qiymati berilyapti a = True # 'b' o'zgaruvchisiga False (yolg'on) qiymati berilyapti b = False # 'result' o'zgaruvchisiga 'a or b' mantiqiy ifodasi natijasi berilyapti # OR operatori ikkala qiymatdan hech bo'lmaganda bittasi True bo'lsa, True qaytaradi # Bu yerda: True or False \u2192 natija: True result = a or b # result True ga teng bo'ladi # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: True 3. \u2747\ufe0f NOT \ud83d\udccc Shartning mantiqiy qiymatini teskariga o'zgartiradi ( True bo'lsa False ga, False bo'lsa True ga). # 'a' o'zgaruvchisiga True (rost) qiymati berilyapti a = True # 'result' o'zgaruvchisiga 'not a' ifodasi natijasi berilmoqda # NOT operatori qiymatni teskarisiga o'zgartiradi: True \u2192 False, False \u2192 True # Bu yerda: not True \u2192 False result = not a # result False ga teng bo'ladi # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: False \ud83d\udccc Quyidagi misolda mantiqiy operatorlar qanday ishlashini ko'rishimiz mumkin: # 'a' o'zgaruvchisiga 8 soni berilmoqda a = 8 # 'b' o'zgaruvchisiga 12 soni berilmoqda b = 12 # 'c' o'zgaruvchisiga 8 soni berilmoqda c = 8 # 'd' o'zgaruvchisiga 15 soni berilmoqda d = 15 # AND operatorlari bilan uchta shart tekshirilmoqda: # (a == c) \u2192 8 == 8 \u2192 True # (b > a) \u2192 12 > 8 \u2192 True # (d % 5 == 0) \u2192 15 % 5 == 0 \u2192 0 == 0 \u2192 True # AND operatori bilan bog\u2018langan barcha shartlar True bo\u2018lsa, umumiy natija ham True bo'ladi result = (a == c) and (b > a) and (d % 5 == 0) # True: chunki a va c teng, b a dan katta, d esa 5 ga bo'linadi # Natijani ekranga chiqaramiz print(result) # True # 'x' o'zgaruvchisiga 3 soni berilmoqda x = 3 # 'y' o'zgaruvchisiga 7 soni berilmoqda y = 7 # 'z' o'zgaruvchisiga 10 soni berilmoqda z = 10 # OR operatorlari bilan uchta shart tekshirilmoqda: # (x > y) \u2192 3 > 7 \u2192 False # (z == 10) \u2192 10 == 10 \u2192 True # (y < 5) \u2192 7 < 5 \u2192 False # OR operatorida hech bo\u2018lmaganda bitta shart True bo\u2018lsa, umumiy natija True bo\u2018ladi result = (x > y) or (z == 10) or (y < 5) # True: chunki faqat (z == 10) sharti True # Natijani ekranga chiqaramiz print(result) # True # 'a' o'zgaruvchisiga 4 soni berilmoqda a = 4 # 'b' o'zgaruvchisiga 9 soni berilmoqda b = 9 # Quyidagi ifodada birinchi navbatda AND operatori ishlaydi: # (a < b) \u2192 4 < 9 \u2192 True # (b < 10) \u2192 9 < 10 \u2192 True # Demak: (a < b) and (b < 10) \u2192 True and True \u2192 True # NOT operatori esa ifodani inkor qiladi: not True \u2192 False result = not ((a < b) and (b < 10)) # (a < b) and (b < 10) \u2192 True, lekin not uni False qiladi # Natijani ekranga chiqaramiz print(result) # False # 'x' o'zgaruvchisiga 6 soni berilmoqda x = 6 # 'y' o'zgaruvchisiga 12 soni berilmoqda y = 12 # 'z' o'zgaruvchisiga 6 soni berilmoqda z = 6 # Butun ifoda ikki qismdan iborat: # 1-qism: (x == z or y < 10) # (x == z) \u2192 6 == 6 \u2192 True # (y < 10) \u2192 12 < 10 \u2192 False # OR operatori bor, shuning uchun hech bo\u2018lmaganda bitta shart True bo\u2018lsa, natija: True # 2-qism: not (y % 2 != 0) # (y % 2 != 0) \u2192 12 % 2 \u2192 0 \u2192 0 != 0 \u2192 False # not False \u2192 True # Yakuniy ifoda: # True and True \u2192 natija: True result = (x == z or y < 10) and not (y % 2 != 0) # Natijani ekranga chiqaramiz print(result) # True # 'is_logged_in' \u2014 foydalanuvchi tizimga kirganmi? \u2192 True (ha, kirgan) is_logged_in = True # 'is_admin' \u2014 foydalanuvchi adminmi? \u2192 False (yo\u2018q, admin emas) is_admin = False # 'has_permission' \u2014 foydalanuvchining kerakli ruxsatlari bormi? \u2192 True (ha, bor) has_permission = True # Yakuniy mantiqiy ifoda: # Foydalanuvchi tizimga kirgan bo\u2018lishi kerak (is_logged_in \u2192 True) # Ruxsati bo\u2018lishi kerak (has_permission \u2192 True) # Va admin bo\u2018lmasligi kerak (not is_admin \u2192 not False \u2192 True) # Shartlar: True and True and True \u2192 natija: True result = is_logged_in and has_permission and not is_admin # Natijani ekranga chiqaramiz print(result) # True \u2705 BITWISE(BITLI) OPERATORLAR \ud83d\udccc Bitwise operatorlar \u2014 bu sonlar ustida 0 va 1 lar bilan ishlaydigan maxsus amallar. Kompyuter har bir sonni ichida faqat 0 va 1 larda saqlaydi (buni ikkilik son deyiladi). Bitwise operatorlar ana shu 0 va 1 larni solishtirib hisob-kitob qiladi. \u2747\ufe0f AND ( & ) \ud83d\udccc Bu operator ikkala sonning mos bitlarini AND amali bilan solishtiradi. Ikkala bit ham 1 bo'lsa, natija 1 , aks holda 0 . # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # b o'zgaruvchiga 3 soni berilmoqda # 3 ning ikkilik (binary) ko'rinishi: 0011 b = 3 # a va b o'zgaruvchilari ustida bitwise AND (&) amali bajarilmoqda # a: 0101 # b: 0011 # ---- # & 0001 --> faqat ikkala bit ham 1 bo'lgan joyda natija 1 bo'ladi natija = a & b # natijani ekranga chiqaramiz # 0001 bu 10lik sanoq sistemasida 1 ga teng print(natija) \u2747\ufe0f OR ( | ) \ud83d\udccc Bu operator ikkala sonning mos bitlarini OR amali bilan solishtiradi. Kamida bitta bit 1 bo'lsa, natija 1 , aks holda 0 . # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # b o'zgaruvchiga 3 soni berilmoqda # 3 ning ikkilik (binary) ko'rinishi: 0011 b = 3 # a va b ustida bitwise OR (|) operatori bajarilmoqda # a: 0101 # b: 0011 # ---- # | 0111 --> har ikkala bitdan hech bo'lmaganda biri 1 bo'lsa, natijada 1 bo'ladi natija = a | b # natijani ekranga chiqaramiz # 0111 bu 10lik sanoq sistemasida 7 ga teng print(natija) \u2747\ufe0f XOR ( ^ ) \ud83d\udccc Bu operator ikkala sonning mos bitlarini XOR amali bilan solishtiradi. Agar bitta bit 1 , ikkinchisi 0 bo'lsa, natija 1 , aks holda 0 . # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # b o'zgaruvchiga 3 soni berilmoqda # 3 ning ikkilik (binary) ko'rinishi: 0011 b = 3 # a va b ustida bitwise XOR (^) operatori bajarilmoqda # a: 0101 # b: 0011 # ---- # ^ 0110 --> faqat bitta bit 1 bo'lsa (ya'ni faqat 1 yoki faqat 0 bo'lsa), natija 1 bo'ladi # agar ikkala bit bir xil bo\u2018lsa (0-0 yoki 1-1) natija 0 bo\u2018ladi natija = a ^ b # natijani ekranga chiqaramiz # 0110 bu 10lik sanoq sistemasida 6 ga teng print(natija) \u2747\ufe0f NOT ( ~ ) \ud83d\udccc Bu operator bitlarning qarama-qarshi qiymatini qaytaradi. 0 ni 1 ga, 1 ni 0 ga o'zgartiradi. Python tilida ~x = -x-1 deb qabul qilinadi. # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # bitwise NOT (~) operatori a ustida qo'llanilmoqda # ~a bu bitlarning inkori (teskari qiymati) degani # Python tilida bu quyidagicha ishlaydi: ~x = -x - 1 # ~5 = -5 - 1 = -6 # Yoki binary orqali tushuntirsak: # 5 -> 0000 0101 # ~5 -> 1111 1010 (ya'ni 2 ning komplementi orqali -6 bo'ladi) natija = ~a # natijani ekranga chiqaramiz # natija: -6 print(natija) \u2747\ufe0f LEFT SHIFT ( << ) \ud83d\udccc Bu operator bitlarni chapga siljitadi va o'ng tomonga 0 qo'shadi. Har bir siljitish operatsiyasi bitlarning qiymatini 2 ga ko'paytiradi. # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # a << 1 bu bitlarni 1 pozitsiyaga chapga siljitish degani # 0101 (5) chapga 1 ta siljisa: 1010 bo'ladi # bu 10 lik sanoq sistemasida 10 ga teng # Har bir chapga siljitish qiymatni 2 ga ko'paytiradi: # 5 << 1 = 5 * 2 = 10 natija = a << 1 # natijani ekranga chiqaramiz # natija: 10 print(natija) \u2747\ufe0f RIGHT SHIFT ( >> ) \ud83d\udccc Bu operator bitlarni o'ngga siljitadi va chap tomonga 0 yoki sonning ishorasi ( positive / negative sign ) qo'yiladi. Har bir siljitish operatsiyasi bitlarning qiymatini 2 ga kamaytiradi. # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # a >> 1 bu bitlarni 1 pozitsiyaga o'ngga siljitish degani # 0101 (5) o'ngga 1 ta siljisa: 0010 bo'ladi # bu 10 lik sanoq sistemasida 2 ga teng # Har bir o'ngga siljitish qiymatni 2 ga kamaytiradi: # 5 >> 1 = 5 // 2 = 2 natija = a >> 1 # natijani ekranga chiqaramiz # natija: 2 print(natija) EXTRA EXAMPLES AND , OR , XOR operatorlari bilan: # a o'zgaruvchiga 12 soni berilmoqda # 12 ning ikkilik (binary) ko\u2018rinishi: 1100 a = 12 # b o'zgaruvchiga 6 soni berilmoqda # 6 ning ikkilik (binary) ko\u2018rinishi: 0110 b = 6 # AND (&) operatori: faqat ikkala bit ham 1 bo\u2018lsa, natija 1 bo\u2018ladi # 1100 # &0110 # ---- # 0100 \u2192 10likda bu 4 ga teng natija_and = a & b # OR (|) operatori: kamida bittasi 1 bo\u2018lsa, natija 1 bo\u2018ladi # 1100 # |0110 # ---- # 1110 \u2192 10likda bu 14 ga teng natija_or = a | b # XOR (^) operatori: agar bitlar turlicha bo\u2018lsa, natija 1 bo\u2018ladi # 1100 # ^0110 # ---- # 1010 \u2192 10likda bu 10 ga teng natija_xor = a ^ b # AND natijani ekranga chiqaramiz print(natija_and) # 4 # OR natijani ekranga chiqaramiz print(natija_or) # 14 # XOR natijani ekranga chiqaramiz print(natija_xor) # 10 NOT , chapga va o'ngga siljitish bilan: # x o'zgaruvchiga 7 qiymati berilmoqda # 7 ning ikkilik (binary) ko\u2018rinishi: 0111 x = 7 # NOT (~) operatori: barcha bitlarni teskari qiladi (1\u21920, 0\u21921) # ~0111 \u2192 1000 (lekin bu -8 bo\u2018ladi, chunki bu bitlar manfiy son sifatida talqin qilinadi) # Pythonda ~x bu -x-1 bo\u2018ladi: ~7 = -7 - 1 = -8 natija_not = ~x # -8 # CHAPGA siljitish (<<): bitlarni chapga siljitadi, har bir siljitish 2 baravar oshadi # 0111 << 2 \u2192 11100 (ya'ni 7 * 2 * 2 = 28) chapga = x << 2 # 28 # O\u2018NGGA siljitish (>>): bitlarni o\u2018ngga siljitadi, har bir siljitish 2 ga kamaytiradi # 0111 >> 2 \u2192 0001 (ya'ni 7 // 2 // 2 = 1) ongga = x >> 2 # 1 # NOT natijani chiqaramiz print(natija_not) # -8 # CHAPGA siljitish natijasini chiqaramiz print(chapga) # 28 # O\u2018NGGA siljitish natijasini chiqaramiz print(ongga) # 1 \u2705 TAYINLASH(ASSIGN) OPERATORALRI \ud83d\udccc Pythonda tayinlash operatorlari yordamida o\u2018zgaruvchiga qiymat beriladi. Shuningdek, ba\u2019zi operatorlar matematik amalni bajarib, natijani o\u2018sha o\u2018zgaruvchining o\u2018ziga yozib qo\u2018yadi. \u2747\ufe0f = \ud83d\udccc Bu operator bilan o\u2018zgaruvchiga qiymat beriladi. x = 10 y = 5 \u2747\ufe0f += \ud83d\udccc Bu operator orqali x ga biror son qo\u2018shiladi va natija yana x ga yoziladi. x = 10 x += 5 # x endi 15 ga teng bo'ladi \u2747\ufe0f -= \ud83d\udccc Bu operator orqali x dan son ayriladi va natija x ga yoziladi. x = 10 x -= 3 # x endi 7 ga teng bo'ladi \u2747\ufe0f *= \ud83d\udccc Bu operator orqali x ga biror son ko\u2018paytiriladi va natija x ga yoziladi. x = 4 x *= 2 # x endi 8 ga teng bo'ladi \u2747\ufe0f /= \ud83d\udccc Bu operator orqali x bo\u2018linadi va natija kasr (float) ko\u2018rinishda saqlanadi. x = 20 x /= 4 # x endi 5.0 ga teng bo'ladi (natija float turida bo'ladi) Bu operator orqali x dan y bo\u2018linadi va qoldiq x ga yoziladi. \u2747\ufe0f %= \ud83d\udccc Bu operator orqali x dan y bo\u2018linadi va qoldiq x ga yoziladi. x = 10 x %= 3 # x endi 1 ga teng bo'ladi (qoldiq) \u2747\ufe0f **= \ud83d\udccc Bu operator orqali x o\u2018zining darajasiga oshiriladi va natija x ga yoziladi. x = 3 x **= 2 # x endi 9 ga teng bo'ladi (3^2 = 9) \u2747\ufe0f //= \ud83d\udccc Bu operator orqali x bo\u2018linadi, lekin faqat butun qismi olinadi. x = 10 x //= 3 # x endi 3 ga teng bo'ladi (butun qismini oladi) A'ZOLIK(MEMBERSHIP) OPERATORLARI Pythonda a'zolik (membership) operatorlari ma'lum bir elementning ketma-ketlik ( sequence ), masalan, ro'yxat ( list ), qator ( string ) yoki to'plam ( set ) ichida mavjudligini tekshirish uchun ishlatiladi. in operatori Bu operator yordamida elementning ma'lum bir ketma-ketlikda mavjudligini tekshirish mumkin. mevalar = ['olma', 'banan', 'nok'] if 'olma' in mevalar: print(\"Olma ro'yxatda mavjud.\") Natija: Olma ro'yxatda mavjud. Bu yerda olma in mevalar ifodasi True qiymatini qaytaradi, chunki olma mevalar ro'yxatida mavjud. not in operatori Bu operator yordamida elementning ma'lum bir ketma-ketlikda mavjud emasligini tekshirish mumkin. mevalar = ['olma', 'banan', 'nok'] if 'uzum' not in mevalar: print(\"Uzum ro'yxatda mavjud emas.\") Natija: Uzum ro'yxatda mavjud emas. Yuqorida uzum not in mevalar ifodasi True qiymatini qaytaradi, chunki 'uzum' mevalar ro'yxatida mavjud emas. Stringlarda misollar A'zolik operatorlari qatorlar ( string ) bilan ham ishlaydi. Kichik qatorning kattaroq qator ichida mavjud yoki mavjud emasligini tekshirish mumkin. matn = \"Salom dunyo\" if 'dunyo' in matn: print(\"'dunyo' matn ichida mavjud.\") IDENTIFIKATSIYA(IDENTYFY) OPERATORLARI Pythonda identifikatsiya (identity) operatorlari ikki ob'ektning bir xil xotira joylashuvida saqlanayotganini aniqlash uchun ishlatiladi. Bu operatorlar ob'ektlarning identifikatorlarini solishtiradi, ya'ni ikki o'zgaruvchining aslida bitta ob'ektga ishora qilayotganini tekshiradi. is operatori is operatori yordamida ikkita o'zgaruvchining bir xil ob'ektga ishora qilayotganligini tekshirish mumkin. a = [1, 2, 3] b = a if a is b: print(\"a va b bir xil ob'ekt.\") Natija: a va b bir xil ob'ekt. Yuqorida a va b bir xil ro'yxatga ishora qilmoqda, shuning uchun a is b ifodasi True qiymatini qaytaradi. is not operatori is not operatori yordamida ikkita o'zgaruvchining bir xil obyektga ishora qilmayotganini tekshirish mumkin. a = [1, 2, 3] b = [1, 2, 3] if a is not b: print(\"a va b bir xil ob'ekt emas.\") Natija: a va b bir xil ob'ekt emas. Yuqorida a va b bir xil qiymatlarni o'z ichiga olgan bo'lsa ham, ular alohida ob'ektlar. Shuning uchun a is not b ifodasi True qiymatini qaytaradi. Identifikatsiya operatorlarining ishlash prinsipi Identifikatsiya operatorlari ob'ektlarning xotira joylashuvini tekshiradi, ya'ni ob'ektlarning ID raqamlarini solishtiradi. a = [1, 2, 3] b = [1, 2, 3] print(id(a)) # a ob'ektining ID raqami print(id(b)) # b ob'ektining ID raqami Agar a va b ID raqamlari turli bo'lsa, demak ular alohida obyektlar. ARALASHTIRILGAN OPERATORLAR(MIXED OPERATORS) Python dasturlash tilida aralashtirilgan operatorlar ( mixed operators ) deganda bir nechta turli operatorlarni bitta ifodada ishlatish tushuniladi. Bu ifodalar matematik va mantiqiy amallarni birlashtirib, ancha murakkab hisob-kitoblar yoki shartlarni aniqlashga yordam beradi. Quyida aralashtirilgan operatorlardan foydalanish misollari keltirilgan: Arifmetik va mantiqiy operatorlar aralashmasi x = 10 y = 5 z = 20 natija = (x + y) * z > 100 and z % y == 0 print(natija) Natija: True Yuqoridagi (x + y) * z > 100 and z % y == 0 ifodasi arifmetik ( +, *, % ) va mantiqiy ( and ) operatorlar aralashmasidan iborat. Ifoda birinchi bo'lib (x + y) * z > 100 qismini hisoblaydi, so'ngra z % y == 0 qismini tekshiradi va oxirida and operatori yordamida natijalarni birlashtiradi. Arifmetik va solishtirish operatorlari aralashmasi a = 7 b = 3 natija = a * 2 > b + 5 print(natija) Natija: True Yuqorida a * 2 > b + 5 ifodasi avval a * 2 va b + 5 qismlarini hisoblaydi, keyin esa ularni > solishtirish operatori bilan solishtiradi. Shartli ( ternary ) ifoda va arifmetik operatorlar a = 10 b = 5 max_qiymat = a if a > b else b print(max_qiymat) Natija: 10 Yuqoridagi misolda a if a > b else b shartli ifoda yordamida aralashtirilgan operatorlar orqali a va b ning maksimal qiymatini aniqlaymiz. AMALIYOT Ikkita o'zgaruvchi yarating va ularning qiymatlarini qo'shib natijani ekranga chiqaruvchi dastur yozing. Foydalanuvchi tomonidan kiritilgan ikkita sonning ayirmasini hisoblab ekranga chiqaruvchi dastur yozing. Ikkita o'zgaruvchi yarating va ularni bo'lgandan keyin butun qismini ekranga chiqaruvchi dastur yozing. Foydalanuvchi tomonidan kiritilgan ikkita sonni bo'lgandan keyin qoldig'ini ekranga chiqaruvchi dastur yozing.","title":"Operatos"},{"location":"python/operators/#3-dars-operators","text":"Python operatorlarini quyidagi guruhlarga bo'lish mumkin: Arifmetik operatorlar Taqqoslash operatorlari Mantiqiy operatorlar Bitwise (Bitli) operatorlar Tayinlash (Assign) operatorlari A'zolik (Membership) operatorlari Identifikatsiya (Identity) operatorlari Aralashtirilgan operatorlar (Mixed Operators)","title":"\ud83e\udde9 3-DARS OPERATORS"},{"location":"python/operators/#arifmetik-operatorlar","text":"\ud83d\udccc Python dasturlash tilida arifmetik operatorlar \u2014 sonlar ustida hisob-kitob qilish uchun ishlatiladigan maxsus belgilar yoki ifodalardir. Ular yordamida qo\u2018shish, ayirish, ko\u2018paytirish, bo\u2018lish kabi oddiy matematik amallarni bajarish mumkin. # a va b o'zgaruvchilariga qiymat beramiz a = 10 b = 3 # Qo\u2018shish amali: a + b yigindi = a + b print(yigindi) # Natija: 13 # Ayirish amali: a - b ayirma = a - b print(ayirma) # Natija: 7 # Ko\u2018paytirish amali: a * b kopaytma = a * b print(kopaytma) # Natija: 30 # Bo\u2018lish amali (natija float): a / b bolish = a / b print(bolish) # Natija: 3.3333333333333335 # Butun qismga bo\u2018lish: a // b (natija butun son) butun_qism = a // b print(butun_qism) # Natija: 3 # Qoldiqni topish: a % b qoldiq = a % b print(qoldiq) # Natija: 1 # Darajaga ko\u2018tarish: a ** b (10 ning 3-darajasi) daraja = a ** b print(daraja) # Natija: 1000","title":"\u2705 ARIFMETIK OPERATORLAR"},{"location":"python/operators/#taqqoslash-operatorlari","text":"\ud83d\udccc Python dasturlash tilida taqqoslash operatorlari (comparison operators) \u2014 ikki qiymatni taqqoslash uchun ishlatiladi. Ular natijada True yoki False (ya'ni mantiqiy qiymat) qaytaradi.","title":"\u2705 TAQQOSLASH OPERATORLARI"},{"location":"python/operators/#1-tengmi","text":"Ikkita qiymat teng bo\u2018lsa, True , aks holda False qaytaradi. # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' va 'b' tengmi degan shart natijasi berilyapti # Bu yerda 5 == 3 bo'lmagani uchun natija False bo'ladi result = (a == b) # False, chunki 5 \u2260 3 # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: False","title":"1. \u2747\ufe0f TENGMI =="},{"location":"python/operators/#2-teng-emas","text":"\ud83d\udccc Qiymatlar bir-biriga teng bo\u2018lmasa, True qaytaradi. # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' va 'b' teng emasmi degan shart natijasi berilyapti # Bu yerda 5 != 3 bo'lgani uchun natija True bo'ladi result = (a != b) # True, chunki 5 \u2260 3 # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: True","title":"2. \u2747\ufe0f TENG EMAS !="},{"location":"python/operators/#3-katta","text":"\ud83d\udccc Chap tomondagi qiymat o\u2018ng tomondagidan katta bo\u2018lsa, True . # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' > 'b' sharti natijasi berilyapti # Bu yerda 5 > 3 bo'lgani uchun natija True bo'ladi result = (a > b) # True, chunki 5 > 3 # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: True","title":"3. \u2747\ufe0f KATTA &gt;"},{"location":"python/operators/#4-kichik","text":"\ud83d\udccc Chap tomondagi qiymat o\u2018ng tomondagidan kichik bo\u2018lsa, True . # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' < 'b' (ya'ni 5 < 3) sharti tekshirilmoqda # Bu shart noto\u2018g\u2018ri, chunki 5 kichik emas 3 dan \u2014 natija: False result = (a < b) # False, chunki 5 < 3 emas # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: False","title":"4. \u2747\ufe0f KICHIK &lt;"},{"location":"python/operators/#5-katta-yoki-teng","text":"\ud83d\udccc Agar chap tomondagi qiymat katta yoki teng bo\u2018lsa, True . # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' >= 'b' (ya'ni 5 katta yoki teng 3) sharti tekshirilmoqda # Bu shart to\u2018g\u2018ri, chunki 5 katta 3 dan \u2014 natija: True result = (a >= b) # True, chunki 5 >= 3 # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: True","title":"5. \u2747\ufe0f KATTA YOKI TENG &gt;="},{"location":"python/operators/#6-kichik-yoki-teng","text":"\ud83d\udccc Agar chap tomondagi qiymat kichik yoki teng bo\u2018lsa, True . # 'a' o'zgaruvchisiga 5 soni berilyapti a = 5 # 'b' o'zgaruvchisiga 3 soni berilyapti b = 3 # 'result' o'zgaruvchisiga 'a' <= 'b' (ya'ni 5 kichik yoki teng 3) sharti tekshirilmoqda # Bu shart noto\u2018g\u2018ri, chunki 5 kichik emas va 5 teng ham emas 3 ga \u2014 natija: False result = (a <= b) # False, chunki 5 <= 3 emas # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: False","title":"6. \u2747\ufe0f KICHIK YOKI TENG (&lt;=)"},{"location":"python/operators/#mantiqiy-operatorlar","text":"\ud83d\udccc Python dasturlash tilida mantiqiy operatorlar (logical operators) shartlarni solishtirishda ishlatiladi va ular True yoki False qiymatlar bilan ishlaydi. Ular bir nechta shartlarni birlashtirish yoki tahlil qilish uchun qo\u02bbllaniladi.","title":"\u2705 MANTIQIY OPERATORLAR"},{"location":"python/operators/#1-and","text":"\ud83d\udccc Bu operator ikkala shart True bo\u02bblsa, True qaytaradi. # 'a' o'zgaruvchisiga True (rost) qiymati berilmoqda a = True # 'b' o'zgaruvchisiga False (yolg'on) qiymati berilmoqda b = False # 'result' o'zgaruvchisiga 'a and b' mantiqiy ifodasi natijasi berilmoqda # AND operatori ikkala qiymat ham True bo'lsa, True qaytaradi. Aks holda False. # Bu yerda: True and False \u2192 natija: False result = a and b # result False ga teng bo'ladi # 'result' ni ekranga chiqaramiz print(result) # Natija: False","title":"1. \u2747\ufe0f AND"},{"location":"python/operators/#2-or","text":"\ud83d\udccc Hech bo'lmaganda bitta shart True bo'lsa, natija True bo'ladi, aks holda False . # 'a' o'zgaruvchisiga True (rost) qiymati berilyapti a = True # 'b' o'zgaruvchisiga False (yolg'on) qiymati berilyapti b = False # 'result' o'zgaruvchisiga 'a or b' mantiqiy ifodasi natijasi berilyapti # OR operatori ikkala qiymatdan hech bo'lmaganda bittasi True bo'lsa, True qaytaradi # Bu yerda: True or False \u2192 natija: True result = a or b # result True ga teng bo'ladi # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: True","title":"2. \u2747\ufe0f OR"},{"location":"python/operators/#3-not","text":"\ud83d\udccc Shartning mantiqiy qiymatini teskariga o'zgartiradi ( True bo'lsa False ga, False bo'lsa True ga). # 'a' o'zgaruvchisiga True (rost) qiymati berilyapti a = True # 'result' o'zgaruvchisiga 'not a' ifodasi natijasi berilmoqda # NOT operatori qiymatni teskarisiga o'zgartiradi: True \u2192 False, False \u2192 True # Bu yerda: not True \u2192 False result = not a # result False ga teng bo'ladi # 'result' o'zgaruvchisini ekranga chiqaramiz print(result) # Natija: False \ud83d\udccc Quyidagi misolda mantiqiy operatorlar qanday ishlashini ko'rishimiz mumkin: # 'a' o'zgaruvchisiga 8 soni berilmoqda a = 8 # 'b' o'zgaruvchisiga 12 soni berilmoqda b = 12 # 'c' o'zgaruvchisiga 8 soni berilmoqda c = 8 # 'd' o'zgaruvchisiga 15 soni berilmoqda d = 15 # AND operatorlari bilan uchta shart tekshirilmoqda: # (a == c) \u2192 8 == 8 \u2192 True # (b > a) \u2192 12 > 8 \u2192 True # (d % 5 == 0) \u2192 15 % 5 == 0 \u2192 0 == 0 \u2192 True # AND operatori bilan bog\u2018langan barcha shartlar True bo\u2018lsa, umumiy natija ham True bo'ladi result = (a == c) and (b > a) and (d % 5 == 0) # True: chunki a va c teng, b a dan katta, d esa 5 ga bo'linadi # Natijani ekranga chiqaramiz print(result) # True # 'x' o'zgaruvchisiga 3 soni berilmoqda x = 3 # 'y' o'zgaruvchisiga 7 soni berilmoqda y = 7 # 'z' o'zgaruvchisiga 10 soni berilmoqda z = 10 # OR operatorlari bilan uchta shart tekshirilmoqda: # (x > y) \u2192 3 > 7 \u2192 False # (z == 10) \u2192 10 == 10 \u2192 True # (y < 5) \u2192 7 < 5 \u2192 False # OR operatorida hech bo\u2018lmaganda bitta shart True bo\u2018lsa, umumiy natija True bo\u2018ladi result = (x > y) or (z == 10) or (y < 5) # True: chunki faqat (z == 10) sharti True # Natijani ekranga chiqaramiz print(result) # True # 'a' o'zgaruvchisiga 4 soni berilmoqda a = 4 # 'b' o'zgaruvchisiga 9 soni berilmoqda b = 9 # Quyidagi ifodada birinchi navbatda AND operatori ishlaydi: # (a < b) \u2192 4 < 9 \u2192 True # (b < 10) \u2192 9 < 10 \u2192 True # Demak: (a < b) and (b < 10) \u2192 True and True \u2192 True # NOT operatori esa ifodani inkor qiladi: not True \u2192 False result = not ((a < b) and (b < 10)) # (a < b) and (b < 10) \u2192 True, lekin not uni False qiladi # Natijani ekranga chiqaramiz print(result) # False # 'x' o'zgaruvchisiga 6 soni berilmoqda x = 6 # 'y' o'zgaruvchisiga 12 soni berilmoqda y = 12 # 'z' o'zgaruvchisiga 6 soni berilmoqda z = 6 # Butun ifoda ikki qismdan iborat: # 1-qism: (x == z or y < 10) # (x == z) \u2192 6 == 6 \u2192 True # (y < 10) \u2192 12 < 10 \u2192 False # OR operatori bor, shuning uchun hech bo\u2018lmaganda bitta shart True bo\u2018lsa, natija: True # 2-qism: not (y % 2 != 0) # (y % 2 != 0) \u2192 12 % 2 \u2192 0 \u2192 0 != 0 \u2192 False # not False \u2192 True # Yakuniy ifoda: # True and True \u2192 natija: True result = (x == z or y < 10) and not (y % 2 != 0) # Natijani ekranga chiqaramiz print(result) # True # 'is_logged_in' \u2014 foydalanuvchi tizimga kirganmi? \u2192 True (ha, kirgan) is_logged_in = True # 'is_admin' \u2014 foydalanuvchi adminmi? \u2192 False (yo\u2018q, admin emas) is_admin = False # 'has_permission' \u2014 foydalanuvchining kerakli ruxsatlari bormi? \u2192 True (ha, bor) has_permission = True # Yakuniy mantiqiy ifoda: # Foydalanuvchi tizimga kirgan bo\u2018lishi kerak (is_logged_in \u2192 True) # Ruxsati bo\u2018lishi kerak (has_permission \u2192 True) # Va admin bo\u2018lmasligi kerak (not is_admin \u2192 not False \u2192 True) # Shartlar: True and True and True \u2192 natija: True result = is_logged_in and has_permission and not is_admin # Natijani ekranga chiqaramiz print(result) # True","title":"3. \u2747\ufe0f NOT"},{"location":"python/operators/#bitwisebitli-operatorlar","text":"\ud83d\udccc Bitwise operatorlar \u2014 bu sonlar ustida 0 va 1 lar bilan ishlaydigan maxsus amallar. Kompyuter har bir sonni ichida faqat 0 va 1 larda saqlaydi (buni ikkilik son deyiladi). Bitwise operatorlar ana shu 0 va 1 larni solishtirib hisob-kitob qiladi.","title":"\u2705 BITWISE(BITLI) OPERATORLAR"},{"location":"python/operators/#and","text":"\ud83d\udccc Bu operator ikkala sonning mos bitlarini AND amali bilan solishtiradi. Ikkala bit ham 1 bo'lsa, natija 1 , aks holda 0 . # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # b o'zgaruvchiga 3 soni berilmoqda # 3 ning ikkilik (binary) ko'rinishi: 0011 b = 3 # a va b o'zgaruvchilari ustida bitwise AND (&) amali bajarilmoqda # a: 0101 # b: 0011 # ---- # & 0001 --> faqat ikkala bit ham 1 bo'lgan joyda natija 1 bo'ladi natija = a & b # natijani ekranga chiqaramiz # 0001 bu 10lik sanoq sistemasida 1 ga teng print(natija)","title":"\u2747\ufe0f AND (&amp;)"},{"location":"python/operators/#or","text":"\ud83d\udccc Bu operator ikkala sonning mos bitlarini OR amali bilan solishtiradi. Kamida bitta bit 1 bo'lsa, natija 1 , aks holda 0 . # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # b o'zgaruvchiga 3 soni berilmoqda # 3 ning ikkilik (binary) ko'rinishi: 0011 b = 3 # a va b ustida bitwise OR (|) operatori bajarilmoqda # a: 0101 # b: 0011 # ---- # | 0111 --> har ikkala bitdan hech bo'lmaganda biri 1 bo'lsa, natijada 1 bo'ladi natija = a | b # natijani ekranga chiqaramiz # 0111 bu 10lik sanoq sistemasida 7 ga teng print(natija)","title":"\u2747\ufe0f OR (|)"},{"location":"python/operators/#xor","text":"\ud83d\udccc Bu operator ikkala sonning mos bitlarini XOR amali bilan solishtiradi. Agar bitta bit 1 , ikkinchisi 0 bo'lsa, natija 1 , aks holda 0 . # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # b o'zgaruvchiga 3 soni berilmoqda # 3 ning ikkilik (binary) ko'rinishi: 0011 b = 3 # a va b ustida bitwise XOR (^) operatori bajarilmoqda # a: 0101 # b: 0011 # ---- # ^ 0110 --> faqat bitta bit 1 bo'lsa (ya'ni faqat 1 yoki faqat 0 bo'lsa), natija 1 bo'ladi # agar ikkala bit bir xil bo\u2018lsa (0-0 yoki 1-1) natija 0 bo\u2018ladi natija = a ^ b # natijani ekranga chiqaramiz # 0110 bu 10lik sanoq sistemasida 6 ga teng print(natija)","title":"\u2747\ufe0f XOR (^)"},{"location":"python/operators/#not","text":"\ud83d\udccc Bu operator bitlarning qarama-qarshi qiymatini qaytaradi. 0 ni 1 ga, 1 ni 0 ga o'zgartiradi. Python tilida ~x = -x-1 deb qabul qilinadi. # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # bitwise NOT (~) operatori a ustida qo'llanilmoqda # ~a bu bitlarning inkori (teskari qiymati) degani # Python tilida bu quyidagicha ishlaydi: ~x = -x - 1 # ~5 = -5 - 1 = -6 # Yoki binary orqali tushuntirsak: # 5 -> 0000 0101 # ~5 -> 1111 1010 (ya'ni 2 ning komplementi orqali -6 bo'ladi) natija = ~a # natijani ekranga chiqaramiz # natija: -6 print(natija)","title":"\u2747\ufe0f NOT (~)"},{"location":"python/operators/#left-shift","text":"\ud83d\udccc Bu operator bitlarni chapga siljitadi va o'ng tomonga 0 qo'shadi. Har bir siljitish operatsiyasi bitlarning qiymatini 2 ga ko'paytiradi. # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # a << 1 bu bitlarni 1 pozitsiyaga chapga siljitish degani # 0101 (5) chapga 1 ta siljisa: 1010 bo'ladi # bu 10 lik sanoq sistemasida 10 ga teng # Har bir chapga siljitish qiymatni 2 ga ko'paytiradi: # 5 << 1 = 5 * 2 = 10 natija = a << 1 # natijani ekranga chiqaramiz # natija: 10 print(natija)","title":"\u2747\ufe0f LEFT SHIFT (&lt;&lt;)"},{"location":"python/operators/#right-shift","text":"\ud83d\udccc Bu operator bitlarni o'ngga siljitadi va chap tomonga 0 yoki sonning ishorasi ( positive / negative sign ) qo'yiladi. Har bir siljitish operatsiyasi bitlarning qiymatini 2 ga kamaytiradi. # a o'zgaruvchiga 5 soni berilmoqda # 5 ning ikkilik (binary) ko'rinishi: 0101 a = 5 # a >> 1 bu bitlarni 1 pozitsiyaga o'ngga siljitish degani # 0101 (5) o'ngga 1 ta siljisa: 0010 bo'ladi # bu 10 lik sanoq sistemasida 2 ga teng # Har bir o'ngga siljitish qiymatni 2 ga kamaytiradi: # 5 >> 1 = 5 // 2 = 2 natija = a >> 1 # natijani ekranga chiqaramiz # natija: 2 print(natija) EXTRA EXAMPLES AND , OR , XOR operatorlari bilan: # a o'zgaruvchiga 12 soni berilmoqda # 12 ning ikkilik (binary) ko\u2018rinishi: 1100 a = 12 # b o'zgaruvchiga 6 soni berilmoqda # 6 ning ikkilik (binary) ko\u2018rinishi: 0110 b = 6 # AND (&) operatori: faqat ikkala bit ham 1 bo\u2018lsa, natija 1 bo\u2018ladi # 1100 # &0110 # ---- # 0100 \u2192 10likda bu 4 ga teng natija_and = a & b # OR (|) operatori: kamida bittasi 1 bo\u2018lsa, natija 1 bo\u2018ladi # 1100 # |0110 # ---- # 1110 \u2192 10likda bu 14 ga teng natija_or = a | b # XOR (^) operatori: agar bitlar turlicha bo\u2018lsa, natija 1 bo\u2018ladi # 1100 # ^0110 # ---- # 1010 \u2192 10likda bu 10 ga teng natija_xor = a ^ b # AND natijani ekranga chiqaramiz print(natija_and) # 4 # OR natijani ekranga chiqaramiz print(natija_or) # 14 # XOR natijani ekranga chiqaramiz print(natija_xor) # 10 NOT , chapga va o'ngga siljitish bilan: # x o'zgaruvchiga 7 qiymati berilmoqda # 7 ning ikkilik (binary) ko\u2018rinishi: 0111 x = 7 # NOT (~) operatori: barcha bitlarni teskari qiladi (1\u21920, 0\u21921) # ~0111 \u2192 1000 (lekin bu -8 bo\u2018ladi, chunki bu bitlar manfiy son sifatida talqin qilinadi) # Pythonda ~x bu -x-1 bo\u2018ladi: ~7 = -7 - 1 = -8 natija_not = ~x # -8 # CHAPGA siljitish (<<): bitlarni chapga siljitadi, har bir siljitish 2 baravar oshadi # 0111 << 2 \u2192 11100 (ya'ni 7 * 2 * 2 = 28) chapga = x << 2 # 28 # O\u2018NGGA siljitish (>>): bitlarni o\u2018ngga siljitadi, har bir siljitish 2 ga kamaytiradi # 0111 >> 2 \u2192 0001 (ya'ni 7 // 2 // 2 = 1) ongga = x >> 2 # 1 # NOT natijani chiqaramiz print(natija_not) # -8 # CHAPGA siljitish natijasini chiqaramiz print(chapga) # 28 # O\u2018NGGA siljitish natijasini chiqaramiz print(ongga) # 1","title":"\u2747\ufe0f RIGHT SHIFT (&gt;&gt;)"},{"location":"python/operators/#tayinlashassign-operatoralri","text":"\ud83d\udccc Pythonda tayinlash operatorlari yordamida o\u2018zgaruvchiga qiymat beriladi. Shuningdek, ba\u2019zi operatorlar matematik amalni bajarib, natijani o\u2018sha o\u2018zgaruvchining o\u2018ziga yozib qo\u2018yadi.","title":"\u2705 TAYINLASH(ASSIGN) OPERATORALRI"},{"location":"python/operators/#_1","text":"\ud83d\udccc Bu operator bilan o\u2018zgaruvchiga qiymat beriladi. x = 10 y = 5","title":"\u2747\ufe0f ="},{"location":"python/operators/#_2","text":"\ud83d\udccc Bu operator orqali x ga biror son qo\u2018shiladi va natija yana x ga yoziladi. x = 10 x += 5 # x endi 15 ga teng bo'ladi","title":"\u2747\ufe0f +="},{"location":"python/operators/#-","text":"\ud83d\udccc Bu operator orqali x dan son ayriladi va natija x ga yoziladi. x = 10 x -= 3 # x endi 7 ga teng bo'ladi","title":"\u2747\ufe0f -="},{"location":"python/operators/#_3","text":"\ud83d\udccc Bu operator orqali x ga biror son ko\u2018paytiriladi va natija x ga yoziladi. x = 4 x *= 2 # x endi 8 ga teng bo'ladi","title":"\u2747\ufe0f *="},{"location":"python/operators/#_4","text":"\ud83d\udccc Bu operator orqali x bo\u2018linadi va natija kasr (float) ko\u2018rinishda saqlanadi. x = 20 x /= 4 # x endi 5.0 ga teng bo'ladi (natija float turida bo'ladi) Bu operator orqali x dan y bo\u2018linadi va qoldiq x ga yoziladi.","title":"\u2747\ufe0f /="},{"location":"python/operators/#_5","text":"\ud83d\udccc Bu operator orqali x dan y bo\u2018linadi va qoldiq x ga yoziladi. x = 10 x %= 3 # x endi 1 ga teng bo'ladi (qoldiq)","title":"\u2747\ufe0f %="},{"location":"python/operators/#_6","text":"\ud83d\udccc Bu operator orqali x o\u2018zining darajasiga oshiriladi va natija x ga yoziladi. x = 3 x **= 2 # x endi 9 ga teng bo'ladi (3^2 = 9)","title":"\u2747\ufe0f **="},{"location":"python/operators/#_7","text":"\ud83d\udccc Bu operator orqali x bo\u2018linadi, lekin faqat butun qismi olinadi. x = 10 x //= 3 # x endi 3 ga teng bo'ladi (butun qismini oladi)","title":"\u2747\ufe0f //="},{"location":"python/operators/#azolikmembership-operatorlari","text":"Pythonda a'zolik (membership) operatorlari ma'lum bir elementning ketma-ketlik ( sequence ), masalan, ro'yxat ( list ), qator ( string ) yoki to'plam ( set ) ichida mavjudligini tekshirish uchun ishlatiladi. in operatori Bu operator yordamida elementning ma'lum bir ketma-ketlikda mavjudligini tekshirish mumkin. mevalar = ['olma', 'banan', 'nok'] if 'olma' in mevalar: print(\"Olma ro'yxatda mavjud.\") Natija: Olma ro'yxatda mavjud. Bu yerda olma in mevalar ifodasi True qiymatini qaytaradi, chunki olma mevalar ro'yxatida mavjud. not in operatori Bu operator yordamida elementning ma'lum bir ketma-ketlikda mavjud emasligini tekshirish mumkin. mevalar = ['olma', 'banan', 'nok'] if 'uzum' not in mevalar: print(\"Uzum ro'yxatda mavjud emas.\") Natija: Uzum ro'yxatda mavjud emas. Yuqorida uzum not in mevalar ifodasi True qiymatini qaytaradi, chunki 'uzum' mevalar ro'yxatida mavjud emas. Stringlarda misollar A'zolik operatorlari qatorlar ( string ) bilan ham ishlaydi. Kichik qatorning kattaroq qator ichida mavjud yoki mavjud emasligini tekshirish mumkin. matn = \"Salom dunyo\" if 'dunyo' in matn: print(\"'dunyo' matn ichida mavjud.\")","title":"A'ZOLIK(MEMBERSHIP) OPERATORLARI"},{"location":"python/operators/#identifikatsiyaidentyfy-operatorlari","text":"Pythonda identifikatsiya (identity) operatorlari ikki ob'ektning bir xil xotira joylashuvida saqlanayotganini aniqlash uchun ishlatiladi. Bu operatorlar ob'ektlarning identifikatorlarini solishtiradi, ya'ni ikki o'zgaruvchining aslida bitta ob'ektga ishora qilayotganini tekshiradi. is operatori is operatori yordamida ikkita o'zgaruvchining bir xil ob'ektga ishora qilayotganligini tekshirish mumkin. a = [1, 2, 3] b = a if a is b: print(\"a va b bir xil ob'ekt.\") Natija: a va b bir xil ob'ekt. Yuqorida a va b bir xil ro'yxatga ishora qilmoqda, shuning uchun a is b ifodasi True qiymatini qaytaradi. is not operatori is not operatori yordamida ikkita o'zgaruvchining bir xil obyektga ishora qilmayotganini tekshirish mumkin. a = [1, 2, 3] b = [1, 2, 3] if a is not b: print(\"a va b bir xil ob'ekt emas.\") Natija: a va b bir xil ob'ekt emas. Yuqorida a va b bir xil qiymatlarni o'z ichiga olgan bo'lsa ham, ular alohida ob'ektlar. Shuning uchun a is not b ifodasi True qiymatini qaytaradi. Identifikatsiya operatorlarining ishlash prinsipi Identifikatsiya operatorlari ob'ektlarning xotira joylashuvini tekshiradi, ya'ni ob'ektlarning ID raqamlarini solishtiradi. a = [1, 2, 3] b = [1, 2, 3] print(id(a)) # a ob'ektining ID raqami print(id(b)) # b ob'ektining ID raqami Agar a va b ID raqamlari turli bo'lsa, demak ular alohida obyektlar.","title":"IDENTIFIKATSIYA(IDENTYFY) OPERATORLARI"},{"location":"python/operators/#aralashtirilgan-operatorlarmixed-operators","text":"Python dasturlash tilida aralashtirilgan operatorlar ( mixed operators ) deganda bir nechta turli operatorlarni bitta ifodada ishlatish tushuniladi. Bu ifodalar matematik va mantiqiy amallarni birlashtirib, ancha murakkab hisob-kitoblar yoki shartlarni aniqlashga yordam beradi. Quyida aralashtirilgan operatorlardan foydalanish misollari keltirilgan: Arifmetik va mantiqiy operatorlar aralashmasi x = 10 y = 5 z = 20 natija = (x + y) * z > 100 and z % y == 0 print(natija) Natija: True Yuqoridagi (x + y) * z > 100 and z % y == 0 ifodasi arifmetik ( +, *, % ) va mantiqiy ( and ) operatorlar aralashmasidan iborat. Ifoda birinchi bo'lib (x + y) * z > 100 qismini hisoblaydi, so'ngra z % y == 0 qismini tekshiradi va oxirida and operatori yordamida natijalarni birlashtiradi. Arifmetik va solishtirish operatorlari aralashmasi a = 7 b = 3 natija = a * 2 > b + 5 print(natija) Natija: True Yuqorida a * 2 > b + 5 ifodasi avval a * 2 va b + 5 qismlarini hisoblaydi, keyin esa ularni > solishtirish operatori bilan solishtiradi. Shartli ( ternary ) ifoda va arifmetik operatorlar a = 10 b = 5 max_qiymat = a if a > b else b print(max_qiymat) Natija: 10 Yuqoridagi misolda a if a > b else b shartli ifoda yordamida aralashtirilgan operatorlar orqali a va b ning maksimal qiymatini aniqlaymiz.","title":"ARALASHTIRILGAN OPERATORLAR(MIXED OPERATORS)"},{"location":"python/operators/#amaliyot","text":"Ikkita o'zgaruvchi yarating va ularning qiymatlarini qo'shib natijani ekranga chiqaruvchi dastur yozing. Foydalanuvchi tomonidan kiritilgan ikkita sonning ayirmasini hisoblab ekranga chiqaruvchi dastur yozing. Ikkita o'zgaruvchi yarating va ularni bo'lgandan keyin butun qismini ekranga chiqaruvchi dastur yozing. Foydalanuvchi tomonidan kiritilgan ikkita sonni bo'lgandan keyin qoldig'ini ekranga chiqaruvchi dastur yozing.","title":"AMALIYOT"},{"location":"python/sets/","text":"\ud83e\udde9 6-DARS SETS \ud83d\udccc Set \u2014 bu noyob (takrorlanmaydigan) elementlar dan tashkil topgan, tartibsiz va indekssiz ma\u2019lumot turi. \u2705 SET YARATISH # Bo'sh set yaratish my_set = set() # Elementlar bilan set yaratish my_set = {1, 2, 3, 4, 5} \u2705 SETGA E'LEMENT QO'SHISH # Set yaratamiz my_set = {1, 2, 3} # Yangi element qo'shamiz my_set.add(4) # 4 element sifatida qo'shiladi print(my_set) # Natija: {1, 2, 3, 4} # Takroriy element qo'shilsa, set o'zgarmaydi my_set.add(3) # 3 allaqachon mavjud, shuning uchun set o'zgarmaydi print(my_set) # Natija: {1, 2, 3, 4} # Bir nechta element qo'shamiz my_set.update([5, 6, 7]) # 5, 6, 7 elementlari qo'shildi print(my_set) # Natija: {1, 2, 3, 4, 5, 6, 7} \u2705 SETDAN E'LEMENT O'CHIRISH # Set yaratamiz my_set = {1, 2, 3, 4, 5} # Ma'lum bir elementni o'chiramiz my_set.remove(3) # 3 elementi o'chiriladi print(my_set) # Natija: {1, 2, 4, 5} # remove() bilan mavjud bo'lmagan elementni o'chirsak xatolik bo'ladi # my_set.remove(10) # KeyError: 10 # discard() bilan element mavjud bo'lmasa ham xatolik bo'lmaydi my_set.discard(10) # Xatolik yo'q, set o'zgarishsiz qoladi print(my_set) # Natija: {1, 2, 4, 5} \u2705 SET OPERATSIYALARI \u2747\ufe0f .intersection() \ud83d\udccc intersection \u2014 bu ikki yoki undan ortiq to\u2018plamdagi umumiy elementlarni topadi. Ya\u2019ni, faqat har ikki setda mavjud bo\u2018lgan elementlargina natijaga olinadi. Agar biror element faqat bir setda bo\u2018lsa, u intersectionga kirmaydi. Bu amal orqali \u201cikkalasi orasida qanday o\u2018xshashlik bor?\u201d degan savolga javob topiladi. # Ikki set yaratamiz set1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Umumiy elementlarni topamiz (& operatori bilan) intersection_result = set1 & set2 # Faqat umumiy elementlar print(intersection_result) # Natija: {3, 4} # intersection() metodi bilan print(set1.intersection(set2)) # Natija: {3, 4} \ud83d\udccc Agar intersection bo\u2018sh set bilan ishlatilsa, natija ham bo\u2018sh bo\u2018ladi. Intersection faqat ikkala setda bir vaqtda mavjud bo\u2018lgan elementlarni qaytaradi. set1 da: {1, 2, 3, 4} empty_set da: hech narsa yo\u2018q \u2192 {} Demak, ikkala setda mavjud bo\u2018lgan hech qanday element yo\u2018q. Shuning uchun natija \u2014 bo\u2018sh set: set() set1 = {1, 2, 3, 4} empty_set = set() result = set1 & empty_set # Bo'sh set bilan kesishish print(result) # Natija: set() \u2747\ufe0f .difference() \ud83d\udccc difference esa farqni topadi. Bu amal birinchi setdagi, lekin ikkinchi setda yo\u2018q bo\u2018lgan elementlarni ajratib beradi. Bunda faqat birinchi setga xos elementlar natijaga olinadi, umumiy yoki ikkinchisida mavjud bo\u2018lganlar olinmaydi. Bu orqali \u201cmenda bor, unda yo\u2018q\u201d degan mantiqqa asoslangan natija olinadi. # Ikkita set yaratamiz set1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # set1 dan set2 farqi (ya'ni, set1 dagi, ammo set2 da yo'q elementlar) diff_result = set1 - set2 print(diff_result) # Natija: {1, 2} # difference() metodi bilan print(set1.difference(set2)) # Natija: {1, 2} \u2747\ufe0f .union() \ud83d\udccc union esa barcha elementlarni birlashtiradi. Ya\u2019ni, har ikki setdagi barcha elementlar bitta setga yig\u2018iladi va takrorlanmas holda saqlanadi. Union orqali \u201cikkovining jamlanmasi\u201d olinadi. Bu amal barcha mavjud ma\u2019lumotlarni umumlashtirish, birlashtirish uchun ishlatiladi. # Ikkita set yaratamiz set1 = {1, 2, 3} set2 = {3, 4, 5} # Barcha elementlarni birlashtiramiz (takroriylar olib tashlanadi) union_result = set1 | set2 print(union_result) # Natija: {1, 2, 3, 4, 5} # union() metodi bilan print(set1.union(set2)) # Natija: {1, 2, 3, 4, 5} \u2705 FROZENSET frozenset nima? frozenset \u2014 bu o\u2018zgarmas set turidir. Ya\u2019ni: Oddiy set bilan bir xil ishlaydi, lekin uni yaratgandan so\u2018ng o\u2018zgartirib bo\u2018lmaydi. Ichiga noyob elementlar saqlanadi. Tartibsiz va indekssiz . Undan .add() , .remove() kabi metodlar ishlamaydi, chunki u o\u2018zgartirilmaydi. \u2705 FROZENSET YARATISH # Oddiy ro'yxat yaratamiz my_list = [1, 2, 3, 4, 5] # Ro'yxatdan frozenset yaratamiz my_frozen_set = frozenset(my_list) print(my_frozen_set) # Natija: frozenset({1, 2, 3, 4, 5}) \u2705 FROZENSETDA .intersection() va .union() .difference() a = frozenset([1, 2, 3]) b = frozenset([2, 3, 4]) # intersection print(a & b) # Natija: frozenset({2, 3}) # union print(a | b) # Natija: frozenset({1, 2, 3, 4}) # difference print(a - b) # Natija: frozenset({1}) \u2705 AMALIYOT \u2705 1-topshiriq: Bo\u2018sh set yarating va unga 10 , 20 , 30 qiymatlarini ketma-ket qo\u2018shing. - add() metodidan foydalaning. - Yakuniy setni ekranga chiqaring. \u2705 2-topshiriq: Quyidagi elementlardan iborat my_set yarating: {1, 2, 2, 3, 3, 3, 4} - Ekranga chiqarilgan setda faqat noyob qiymatlar qoladi. \u2705 3-topshiriq: Set yarating: {5, 10, 15, 20} - remove() metodidan foydalanib, 15 sonini o\u2018chiring. - So\u2018ng setni chop eting. \u2705 4-topshiriq: Set yarating: {100, 200, 300} - discard() yordamida 400 ni o\u2018chirishga harakat qiling. - Xatolik bo\u2018lmasligiga e\u2019tibor bering. Natijani chop eting. \u2705 5-topshiriq: Ikki set yarating: a = {1, 2, 3, 4} b = {3, 4, 5, 6} Ularning kesishmasini & operatori yordamida toping. Natijani intersection_result nomli o\u2018zgaruvchiga saqlang. \u2705 6-topshiriq: Yuqoridagi a va b setlari ustida .intersection() metodini ishlatib, umumiy elementlarni chiqaring. \u2705 7-topshiriq: Setlar: x = {10, 20, 30} y = {30, 40, 50} difference() metodidan foydalanib, x setida bor-u, y da yo\u2018q elementlarni toping. \u2705 8-topshiriq: Setlar: x = {10, 20, 30} y = {30, 40, 50} x - y amali bilan farqni toping. Natijani ekranga chiqaring. \u2705 9-topshiriq: Quyidagi ikki set ustida birlashtirish ( union ) amalini bajaring: a = {\"python\", \"java\"} b = {\"c++\", \"java\", \"go\"} Natijada faqat noyob qiymatlar chiqishi kerak. \u2705 10-topshiriq: Set yarating va update() metodi orqali [100, 200, 300] ro\u2018yxatidagi qiymatlarni qo\u2018shing. \u2705 11-topshiriq: Setni quyidagicha yarating: my_set = {1, 2, 3} add() metodi orqali yana 3 ni qo\u2018shishga urinib ko\u2018ring. Set o\u2018zgarmasligiga ishonch hosil qiling. \u2705 12-topshiriq: frozenset yarating: [1, 2, 3, 4] ro\u2018yxatidan foydalaning. - Ekranga chiqaring. \u2705 13-topshiriq: Quyidagi ikki frozenset ustida intersection bajaring: a = frozenset([1, 2, 3]) b = frozenset([2, 3, 4]) Natijani ekranga chiqaring. \u2705 14-topshiriq: Yuqoridagi a va b ustida union va difference amallarini bajaring. - Har bir natijani alohida chiqarib bering. \u2705 15-topshiriq: Set yaratib, unga True , False , 1 , 0 qiymatlarini joylang. - Ekranga chiqaring va natijani tushuntiring (setda nechta element chiqdi?).","title":"Sets"},{"location":"python/sets/#6-dars-sets","text":"\ud83d\udccc Set \u2014 bu noyob (takrorlanmaydigan) elementlar dan tashkil topgan, tartibsiz va indekssiz ma\u2019lumot turi.","title":"\ud83e\udde9 6-DARS SETS"},{"location":"python/sets/#set-yaratish","text":"# Bo'sh set yaratish my_set = set() # Elementlar bilan set yaratish my_set = {1, 2, 3, 4, 5}","title":"\u2705 SET YARATISH"},{"location":"python/sets/#setga-element-qoshish","text":"# Set yaratamiz my_set = {1, 2, 3} # Yangi element qo'shamiz my_set.add(4) # 4 element sifatida qo'shiladi print(my_set) # Natija: {1, 2, 3, 4} # Takroriy element qo'shilsa, set o'zgarmaydi my_set.add(3) # 3 allaqachon mavjud, shuning uchun set o'zgarmaydi print(my_set) # Natija: {1, 2, 3, 4} # Bir nechta element qo'shamiz my_set.update([5, 6, 7]) # 5, 6, 7 elementlari qo'shildi print(my_set) # Natija: {1, 2, 3, 4, 5, 6, 7}","title":"\u2705 SETGA E'LEMENT QO'SHISH"},{"location":"python/sets/#setdan-element-ochirish","text":"# Set yaratamiz my_set = {1, 2, 3, 4, 5} # Ma'lum bir elementni o'chiramiz my_set.remove(3) # 3 elementi o'chiriladi print(my_set) # Natija: {1, 2, 4, 5} # remove() bilan mavjud bo'lmagan elementni o'chirsak xatolik bo'ladi # my_set.remove(10) # KeyError: 10 # discard() bilan element mavjud bo'lmasa ham xatolik bo'lmaydi my_set.discard(10) # Xatolik yo'q, set o'zgarishsiz qoladi print(my_set) # Natija: {1, 2, 4, 5}","title":"\u2705 SETDAN E'LEMENT O'CHIRISH"},{"location":"python/sets/#set-operatsiyalari","text":"","title":"\u2705 SET OPERATSIYALARI"},{"location":"python/sets/#intersection","text":"\ud83d\udccc intersection \u2014 bu ikki yoki undan ortiq to\u2018plamdagi umumiy elementlarni topadi. Ya\u2019ni, faqat har ikki setda mavjud bo\u2018lgan elementlargina natijaga olinadi. Agar biror element faqat bir setda bo\u2018lsa, u intersectionga kirmaydi. Bu amal orqali \u201cikkalasi orasida qanday o\u2018xshashlik bor?\u201d degan savolga javob topiladi. # Ikki set yaratamiz set1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # Umumiy elementlarni topamiz (& operatori bilan) intersection_result = set1 & set2 # Faqat umumiy elementlar print(intersection_result) # Natija: {3, 4} # intersection() metodi bilan print(set1.intersection(set2)) # Natija: {3, 4} \ud83d\udccc Agar intersection bo\u2018sh set bilan ishlatilsa, natija ham bo\u2018sh bo\u2018ladi. Intersection faqat ikkala setda bir vaqtda mavjud bo\u2018lgan elementlarni qaytaradi. set1 da: {1, 2, 3, 4} empty_set da: hech narsa yo\u2018q \u2192 {} Demak, ikkala setda mavjud bo\u2018lgan hech qanday element yo\u2018q. Shuning uchun natija \u2014 bo\u2018sh set: set() set1 = {1, 2, 3, 4} empty_set = set() result = set1 & empty_set # Bo'sh set bilan kesishish print(result) # Natija: set()","title":"\u2747\ufe0f .intersection()"},{"location":"python/sets/#difference","text":"\ud83d\udccc difference esa farqni topadi. Bu amal birinchi setdagi, lekin ikkinchi setda yo\u2018q bo\u2018lgan elementlarni ajratib beradi. Bunda faqat birinchi setga xos elementlar natijaga olinadi, umumiy yoki ikkinchisida mavjud bo\u2018lganlar olinmaydi. Bu orqali \u201cmenda bor, unda yo\u2018q\u201d degan mantiqqa asoslangan natija olinadi. # Ikkita set yaratamiz set1 = {1, 2, 3, 4} set2 = {3, 4, 5, 6} # set1 dan set2 farqi (ya'ni, set1 dagi, ammo set2 da yo'q elementlar) diff_result = set1 - set2 print(diff_result) # Natija: {1, 2} # difference() metodi bilan print(set1.difference(set2)) # Natija: {1, 2}","title":"\u2747\ufe0f .difference()"},{"location":"python/sets/#union","text":"\ud83d\udccc union esa barcha elementlarni birlashtiradi. Ya\u2019ni, har ikki setdagi barcha elementlar bitta setga yig\u2018iladi va takrorlanmas holda saqlanadi. Union orqali \u201cikkovining jamlanmasi\u201d olinadi. Bu amal barcha mavjud ma\u2019lumotlarni umumlashtirish, birlashtirish uchun ishlatiladi. # Ikkita set yaratamiz set1 = {1, 2, 3} set2 = {3, 4, 5} # Barcha elementlarni birlashtiramiz (takroriylar olib tashlanadi) union_result = set1 | set2 print(union_result) # Natija: {1, 2, 3, 4, 5} # union() metodi bilan print(set1.union(set2)) # Natija: {1, 2, 3, 4, 5}","title":"\u2747\ufe0f .union()"},{"location":"python/sets/#frozenset","text":"frozenset nima? frozenset \u2014 bu o\u2018zgarmas set turidir. Ya\u2019ni: Oddiy set bilan bir xil ishlaydi, lekin uni yaratgandan so\u2018ng o\u2018zgartirib bo\u2018lmaydi. Ichiga noyob elementlar saqlanadi. Tartibsiz va indekssiz . Undan .add() , .remove() kabi metodlar ishlamaydi, chunki u o\u2018zgartirilmaydi.","title":"\u2705 FROZENSET"},{"location":"python/sets/#frozenset-yaratish","text":"# Oddiy ro'yxat yaratamiz my_list = [1, 2, 3, 4, 5] # Ro'yxatdan frozenset yaratamiz my_frozen_set = frozenset(my_list) print(my_frozen_set) # Natija: frozenset({1, 2, 3, 4, 5})","title":"\u2705 FROZENSET YARATISH"},{"location":"python/sets/#frozensetda-intersection-va-union-difference","text":"a = frozenset([1, 2, 3]) b = frozenset([2, 3, 4]) # intersection print(a & b) # Natija: frozenset({2, 3}) # union print(a | b) # Natija: frozenset({1, 2, 3, 4}) # difference print(a - b) # Natija: frozenset({1})","title":"\u2705 FROZENSETDA .intersection() va .union() .difference()"},{"location":"python/sets/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/sets/#1-topshiriq","text":"Bo\u2018sh set yarating va unga 10 , 20 , 30 qiymatlarini ketma-ket qo\u2018shing. - add() metodidan foydalaning. - Yakuniy setni ekranga chiqaring.","title":"\u2705 1-topshiriq:"},{"location":"python/sets/#2-topshiriq","text":"Quyidagi elementlardan iborat my_set yarating: {1, 2, 2, 3, 3, 3, 4} - Ekranga chiqarilgan setda faqat noyob qiymatlar qoladi.","title":"\u2705 2-topshiriq:"},{"location":"python/sets/#3-topshiriq","text":"Set yarating: {5, 10, 15, 20} - remove() metodidan foydalanib, 15 sonini o\u2018chiring. - So\u2018ng setni chop eting.","title":"\u2705 3-topshiriq:"},{"location":"python/sets/#4-topshiriq","text":"Set yarating: {100, 200, 300} - discard() yordamida 400 ni o\u2018chirishga harakat qiling. - Xatolik bo\u2018lmasligiga e\u2019tibor bering. Natijani chop eting.","title":"\u2705 4-topshiriq:"},{"location":"python/sets/#5-topshiriq","text":"Ikki set yarating: a = {1, 2, 3, 4} b = {3, 4, 5, 6} Ularning kesishmasini & operatori yordamida toping. Natijani intersection_result nomli o\u2018zgaruvchiga saqlang.","title":"\u2705 5-topshiriq:"},{"location":"python/sets/#6-topshiriq","text":"Yuqoridagi a va b setlari ustida .intersection() metodini ishlatib, umumiy elementlarni chiqaring.","title":"\u2705 6-topshiriq:"},{"location":"python/sets/#7-topshiriq","text":"Setlar: x = {10, 20, 30} y = {30, 40, 50} difference() metodidan foydalanib, x setida bor-u, y da yo\u2018q elementlarni toping.","title":"\u2705 7-topshiriq:"},{"location":"python/sets/#8-topshiriq","text":"Setlar: x = {10, 20, 30} y = {30, 40, 50} x - y amali bilan farqni toping. Natijani ekranga chiqaring.","title":"\u2705 8-topshiriq:"},{"location":"python/sets/#9-topshiriq","text":"Quyidagi ikki set ustida birlashtirish ( union ) amalini bajaring: a = {\"python\", \"java\"} b = {\"c++\", \"java\", \"go\"} Natijada faqat noyob qiymatlar chiqishi kerak.","title":"\u2705 9-topshiriq:"},{"location":"python/sets/#10-topshiriq","text":"Set yarating va update() metodi orqali [100, 200, 300] ro\u2018yxatidagi qiymatlarni qo\u2018shing.","title":"\u2705 10-topshiriq:"},{"location":"python/sets/#11-topshiriq","text":"Setni quyidagicha yarating: my_set = {1, 2, 3} add() metodi orqali yana 3 ni qo\u2018shishga urinib ko\u2018ring. Set o\u2018zgarmasligiga ishonch hosil qiling.","title":"\u2705 11-topshiriq:"},{"location":"python/sets/#12-topshiriq","text":"frozenset yarating: [1, 2, 3, 4] ro\u2018yxatidan foydalaning. - Ekranga chiqaring.","title":"\u2705 12-topshiriq:"},{"location":"python/sets/#13-topshiriq","text":"Quyidagi ikki frozenset ustida intersection bajaring: a = frozenset([1, 2, 3]) b = frozenset([2, 3, 4]) Natijani ekranga chiqaring.","title":"\u2705 13-topshiriq:"},{"location":"python/sets/#14-topshiriq","text":"Yuqoridagi a va b ustida union va difference amallarini bajaring. - Har bir natijani alohida chiqarib bering.","title":"\u2705 14-topshiriq:"},{"location":"python/sets/#15-topshiriq","text":"Set yaratib, unga True , False , 1 , 0 qiymatlarini joylang. - Ekranga chiqaring va natijani tushuntiring (setda nechta element chiqdi?).","title":"\u2705 15-topshiriq:"},{"location":"python/third-party-packages/","text":"\ud83e\udde9 16-DARS THIRD PARTY PACKAGES \ud83d\udccc Python kutubxonalari 3 guruhga bo\u2018linadi: Standart kutubxonalar \u2013 Python bilan birga keladi. Ikkinchi tomon kutubxonalari \u2013 rasmiy Python jamoasi tashqarisida ishlab chiqilgan, ammo mashhur. Uchinchi tomon kutubxonalari (Third-party) \u2013 mustaqil ishlab chiquvchilar yoki jamoalar tomonidan yaratilgan va keng turdagi loyihalar uchun ishlatiladi. \ud83d\udd0d Third-Party Packages nima? Third-party packages \u2014 bu Pythonning o\u2018zida yo\u2018q, lekin boshqa ishlab chiquvchilar tomonidan ishlab chiqilgan kutubxonalardir. Ular dasturchilarga turli murakkab ishlarni oson bajarishga yordam beradi (masalan: web dasturlash, ma\u2019lumotlar tahlili, sun\u2019iy intellekt, grafikalar chizish va h.k.). \ud83d\ude80 Third-party paketlarni o\u2018rnatish Python\u2019ning pip (Python Package Installer) vositasi yordamida: pip install package_nomi Masalan: pip install requests pip install numpy pip install flask \u2705 Eng ko\u2018p ishlatiladigan third-party kutubxonalar Kutubxona Maqsadi requests HTTP so\u2018rovlar yuborish va javob olish uchun beautifulsoup4 Web sahifalarni tahlil qilish (scraping) pandas Jadval (DataFrame) ko\u2018rinishidagi ma\u2019lumotlar bilan ishlash numpy Katta hajmdagi massivlar va matematik hisoblar matplotlib Grafikalar chizish seaborn Statistik grafiklar chizish (matplotlib ustida ishlaydi) scikit-learn Mashinaviy o\u2018rganish (machine learning) algoritmlari flask Yengil web ilovalar yaratish uchun freymvork django To\u2018liq web freymvork (backend development) pytest Avtomatik test yozish va bajarish uchun opencv-python Rasm va video tahlili, kompyuter ko\u2018rish (Computer Vision) sqlalchemy Ma\u2019lumotlar bazalari bilan ishlash (ORM) celery Asinxron ishlov berish (masalan: xabar yuborish fon rejimida) fastapi Tezkor REST API yaratish uchun zamonaviy web-freymvork transformers Natural Language Processing (NLP) uchun (Hugging Face tomonidan yaratilgan) \ud83d\udd27 Misollar bilan tushuntirish 1. requests bilan API\u2019dan ma\u2019lumot olish: import requests url = \"https://jsonplaceholder.typicode.com/posts\" response = requests.get(url) if response.status_code == 200: data = response.json() print(data[0]) # Birinchi post else: print(\"Xatolik yuz berdi.\") 2. numpy bilan matematik amallar: import numpy as np arr = np.array([1, 2, 3, 4]) print(arr * 2) # Har bir elementni 2 ga ko\u2018paytiradi 3. pandas bilan jadval (DataFrame) ishlatish: import pandas as pd data = { \"Ism\": [\"Umid\", \"Ali\"], \"Yosh\": [25, 30] } df = pd.DataFrame(data) print(df) 4. matplotlib bilan grafik chizish: import matplotlib.pyplot as plt x = [1, 2, 3] y = [2, 4, 6] plt.plot(x, y) plt.title(\"Oddiy Grafik\") plt.show() \ud83d\udcc4 requirements.txt bilan kutubxonalarni boshqarish Loyihada foydalanilgan barcha kutubxonalarni ro\u2018yxatga olish: pip freeze > requirements.txt Keyin boshqa kompyuterda bu fayl orqali hammasini o\u2018rnatish: pip install -r requirements.txt \ud83c\udf10 PyPI (Python Package Index) Python kutubxonalarining asosiy ombori: https://pypi.org Bu yerda har qanday third-party paketni topish, hujjatlari bilan tanishish va o\u2018rnatish mumkin. \ud83d\udccc Third-party kutubxonalarni yangilash va o\u2018chirish Yangilash: pip install --upgrade package_nomi O\u2018chirish: pip uninstall package_nomi \ud83d\udee0\ufe0f Virtual Environment (tavsiya qilinadi) Har bir loyiha uchun alohida muhit yaratish muhim. Misol: python -m venv venv source venv/bin/activate # Linux/Mac venv\\Scripts\\activate # Windows Bu orqali har bir loyiha o\u2018z kutubxonalariga ega bo\u2018ladi. \u2705 AMALIYOT \u2705 1-topshiriq: requests bilan so\u02bbrov yuboring: https://jsonplaceholder.typicode.com/posts sahifasiga GET so\u02bbrovi yuboring va javobdan 5 ta postning sarlavhasini ( title ) chiqaring. \u2705 2-topshiriq: beautifulsoup4 bilan HTML tahlil qilish: https://www.example.com sahifasidan barcha <a> teglarini ajrating va havola ( href ) manzillarini chop eting. \u2705 3-topshiriq: numpy yordamida massiv bilan ishlash: 1 dan 100 gacha bo\u02bblgan sonlar bilan massiv yarating va barcha juft sonlarni chiqaring. \u2705 4-topshiriq: matplotlib bilan grafik chizish: 1 dan 10 gacha sonlarning kvadratlarini chizadigan grafik tuzing. \u2705 5-topshiriq: pandas yordamida ma\u02bclumotlar tahlili: Talabalar haqida ma\u02bclumotlardan iborat DataFrame yarating (Ism, Yoshi, Ball). Yoshi 20 dan katta bo\u02bblganlarni ajrating. \u2705 6-topshiriq: flask bilan oddiy web ilova: Flask yordamida sahifada \"Assalomu alaykum!\" yozuvi chiqadigan web ilova yarating. \u2705 7-topshiriq: pytest bilan test yozish: Ikki sonni qo\u02bbshuvchi funksiya yozing va pytest orqali uni test qiling. \u2705 8-topshiriq: pandas bilan CSV fayl o'qish: data.csv faylini pandas yordamida o'qing va ma\u02bclumotlarni ekranga chiqaring. \u2705 9-topshiriq: requests bilan JSON API dan ma\u02bclumot olish: https://api.coindesk.com/v1/bpi/currentprice.json API dan Bitcoin narxini olib, konsolga chiqaring. \u2705 10-topshiriq: matplotlib bilan histogram chizish: Tasodifiy 100 ta son yarating ( numpy yordamida) va histogram ko'rinishida chizing. \u2705 11-topshiriq: numpy bilan matritsalar ustida amallar: 2 ta 3x3 o'lchamdagi matritsa yarating va ularni qo'shing. \u2705 12-topshiriq: flask bilan parametrli sahifa: URL orqali foydalanuvchi ismini qabul qilib, \"Salom, Ism!\" degan javob qaytaradigan Flask ilova yarating. \u2705 13-topshiriq: beautifulsoup4 bilan sahifa sarlavhasini olish: Web sahifadan <title> tegidagi matnni chiqaradigan dastur tuzing. \u2705 14-topshiriq: pandas bilan ustun qo\u02bbshish: Mavjud jadvalga yangi ustun qo\u02bbshing: talaba baholari asosida \"O\u02bbtdi\" yoki \"O\u02bbtmadi\" degan ustun hosil qiling. \u2705 15-topshiriq: venv yordamida virtual muhit yaratish: Terminal orqali yangi virtual muhit yarating va unga requests , numpy , pandas paketlarini o\u2018rnating.","title":"Third Party Packages"},{"location":"python/third-party-packages/#16-dars-third-party-packages","text":"\ud83d\udccc Python kutubxonalari 3 guruhga bo\u2018linadi: Standart kutubxonalar \u2013 Python bilan birga keladi. Ikkinchi tomon kutubxonalari \u2013 rasmiy Python jamoasi tashqarisida ishlab chiqilgan, ammo mashhur. Uchinchi tomon kutubxonalari (Third-party) \u2013 mustaqil ishlab chiquvchilar yoki jamoalar tomonidan yaratilgan va keng turdagi loyihalar uchun ishlatiladi.","title":"\ud83e\udde9 16-DARS THIRD PARTY PACKAGES"},{"location":"python/third-party-packages/#third-party-packages-nima","text":"Third-party packages \u2014 bu Pythonning o\u2018zida yo\u2018q, lekin boshqa ishlab chiquvchilar tomonidan ishlab chiqilgan kutubxonalardir. Ular dasturchilarga turli murakkab ishlarni oson bajarishga yordam beradi (masalan: web dasturlash, ma\u2019lumotlar tahlili, sun\u2019iy intellekt, grafikalar chizish va h.k.).","title":"\ud83d\udd0d Third-Party Packages nima?"},{"location":"python/third-party-packages/#third-party-paketlarni-ornatish","text":"Python\u2019ning pip (Python Package Installer) vositasi yordamida: pip install package_nomi","title":"\ud83d\ude80 Third-party paketlarni o\u2018rnatish"},{"location":"python/third-party-packages/#masalan","text":"pip install requests pip install numpy pip install flask","title":"Masalan:"},{"location":"python/third-party-packages/#eng-kop-ishlatiladigan-third-party-kutubxonalar","text":"Kutubxona Maqsadi requests HTTP so\u2018rovlar yuborish va javob olish uchun beautifulsoup4 Web sahifalarni tahlil qilish (scraping) pandas Jadval (DataFrame) ko\u2018rinishidagi ma\u2019lumotlar bilan ishlash numpy Katta hajmdagi massivlar va matematik hisoblar matplotlib Grafikalar chizish seaborn Statistik grafiklar chizish (matplotlib ustida ishlaydi) scikit-learn Mashinaviy o\u2018rganish (machine learning) algoritmlari flask Yengil web ilovalar yaratish uchun freymvork django To\u2018liq web freymvork (backend development) pytest Avtomatik test yozish va bajarish uchun opencv-python Rasm va video tahlili, kompyuter ko\u2018rish (Computer Vision) sqlalchemy Ma\u2019lumotlar bazalari bilan ishlash (ORM) celery Asinxron ishlov berish (masalan: xabar yuborish fon rejimida) fastapi Tezkor REST API yaratish uchun zamonaviy web-freymvork transformers Natural Language Processing (NLP) uchun (Hugging Face tomonidan yaratilgan)","title":"\u2705 Eng ko\u2018p ishlatiladigan third-party kutubxonalar"},{"location":"python/third-party-packages/#misollar-bilan-tushuntirish","text":"","title":"\ud83d\udd27 Misollar bilan tushuntirish"},{"location":"python/third-party-packages/#1-requests-bilan-apidan-malumot-olish","text":"import requests url = \"https://jsonplaceholder.typicode.com/posts\" response = requests.get(url) if response.status_code == 200: data = response.json() print(data[0]) # Birinchi post else: print(\"Xatolik yuz berdi.\")","title":"1. requests bilan API\u2019dan ma\u2019lumot olish:"},{"location":"python/third-party-packages/#2-numpy-bilan-matematik-amallar","text":"import numpy as np arr = np.array([1, 2, 3, 4]) print(arr * 2) # Har bir elementni 2 ga ko\u2018paytiradi","title":"2. numpy bilan matematik amallar:"},{"location":"python/third-party-packages/#3-pandas-bilan-jadval-dataframe-ishlatish","text":"import pandas as pd data = { \"Ism\": [\"Umid\", \"Ali\"], \"Yosh\": [25, 30] } df = pd.DataFrame(data) print(df)","title":"3. pandas bilan jadval (DataFrame) ishlatish:"},{"location":"python/third-party-packages/#4-matplotlib-bilan-grafik-chizish","text":"import matplotlib.pyplot as plt x = [1, 2, 3] y = [2, 4, 6] plt.plot(x, y) plt.title(\"Oddiy Grafik\") plt.show()","title":"4. matplotlib bilan grafik chizish:"},{"location":"python/third-party-packages/#requirementstxt-bilan-kutubxonalarni-boshqarish","text":"Loyihada foydalanilgan barcha kutubxonalarni ro\u2018yxatga olish: pip freeze > requirements.txt Keyin boshqa kompyuterda bu fayl orqali hammasini o\u2018rnatish: pip install -r requirements.txt","title":"\ud83d\udcc4 requirements.txt bilan kutubxonalarni boshqarish"},{"location":"python/third-party-packages/#pypi-python-package-index","text":"Python kutubxonalarining asosiy ombori: https://pypi.org Bu yerda har qanday third-party paketni topish, hujjatlari bilan tanishish va o\u2018rnatish mumkin.","title":"\ud83c\udf10 PyPI (Python Package Index)"},{"location":"python/third-party-packages/#third-party-kutubxonalarni-yangilash-va-ochirish","text":"","title":"\ud83d\udccc Third-party kutubxonalarni yangilash va o\u2018chirish"},{"location":"python/third-party-packages/#yangilash","text":"pip install --upgrade package_nomi","title":"Yangilash:"},{"location":"python/third-party-packages/#ochirish","text":"pip uninstall package_nomi","title":"O\u2018chirish:"},{"location":"python/third-party-packages/#virtual-environment-tavsiya-qilinadi","text":"Har bir loyiha uchun alohida muhit yaratish muhim. Misol: python -m venv venv source venv/bin/activate # Linux/Mac venv\\Scripts\\activate # Windows Bu orqali har bir loyiha o\u2018z kutubxonalariga ega bo\u2018ladi.","title":"\ud83d\udee0\ufe0f Virtual Environment (tavsiya qilinadi)"},{"location":"python/third-party-packages/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/third-party-packages/#1-topshiriq","text":"requests bilan so\u02bbrov yuboring: https://jsonplaceholder.typicode.com/posts sahifasiga GET so\u02bbrovi yuboring va javobdan 5 ta postning sarlavhasini ( title ) chiqaring.","title":"\u2705 1-topshiriq:"},{"location":"python/third-party-packages/#2-topshiriq","text":"beautifulsoup4 bilan HTML tahlil qilish: https://www.example.com sahifasidan barcha <a> teglarini ajrating va havola ( href ) manzillarini chop eting.","title":"\u2705 2-topshiriq:"},{"location":"python/third-party-packages/#3-topshiriq","text":"numpy yordamida massiv bilan ishlash: 1 dan 100 gacha bo\u02bblgan sonlar bilan massiv yarating va barcha juft sonlarni chiqaring.","title":"\u2705 3-topshiriq:"},{"location":"python/third-party-packages/#4-topshiriq","text":"matplotlib bilan grafik chizish: 1 dan 10 gacha sonlarning kvadratlarini chizadigan grafik tuzing.","title":"\u2705 4-topshiriq:"},{"location":"python/third-party-packages/#5-topshiriq","text":"pandas yordamida ma\u02bclumotlar tahlili: Talabalar haqida ma\u02bclumotlardan iborat DataFrame yarating (Ism, Yoshi, Ball). Yoshi 20 dan katta bo\u02bblganlarni ajrating.","title":"\u2705 5-topshiriq:"},{"location":"python/third-party-packages/#6-topshiriq","text":"flask bilan oddiy web ilova: Flask yordamida sahifada \"Assalomu alaykum!\" yozuvi chiqadigan web ilova yarating.","title":"\u2705 6-topshiriq:"},{"location":"python/third-party-packages/#7-topshiriq","text":"pytest bilan test yozish: Ikki sonni qo\u02bbshuvchi funksiya yozing va pytest orqali uni test qiling.","title":"\u2705 7-topshiriq:"},{"location":"python/third-party-packages/#8-topshiriq","text":"pandas bilan CSV fayl o'qish: data.csv faylini pandas yordamida o'qing va ma\u02bclumotlarni ekranga chiqaring.","title":"\u2705 8-topshiriq:"},{"location":"python/third-party-packages/#9-topshiriq","text":"requests bilan JSON API dan ma\u02bclumot olish: https://api.coindesk.com/v1/bpi/currentprice.json API dan Bitcoin narxini olib, konsolga chiqaring.","title":"\u2705 9-topshiriq:"},{"location":"python/third-party-packages/#10-topshiriq","text":"matplotlib bilan histogram chizish: Tasodifiy 100 ta son yarating ( numpy yordamida) va histogram ko'rinishida chizing.","title":"\u2705 10-topshiriq:"},{"location":"python/third-party-packages/#11-topshiriq","text":"numpy bilan matritsalar ustida amallar: 2 ta 3x3 o'lchamdagi matritsa yarating va ularni qo'shing.","title":"\u2705 11-topshiriq:"},{"location":"python/third-party-packages/#12-topshiriq","text":"flask bilan parametrli sahifa: URL orqali foydalanuvchi ismini qabul qilib, \"Salom, Ism!\" degan javob qaytaradigan Flask ilova yarating.","title":"\u2705 12-topshiriq:"},{"location":"python/third-party-packages/#13-topshiriq","text":"beautifulsoup4 bilan sahifa sarlavhasini olish: Web sahifadan <title> tegidagi matnni chiqaradigan dastur tuzing.","title":"\u2705 13-topshiriq:"},{"location":"python/third-party-packages/#14-topshiriq","text":"pandas bilan ustun qo\u02bbshish: Mavjud jadvalga yangi ustun qo\u02bbshing: talaba baholari asosida \"O\u02bbtdi\" yoki \"O\u02bbtmadi\" degan ustun hosil qiling.","title":"\u2705 14-topshiriq:"},{"location":"python/third-party-packages/#15-topshiriq","text":"venv yordamida virtual muhit yaratish: Terminal orqali yangi virtual muhit yarating va unga requests , numpy , pandas paketlarini o\u2018rnating.","title":"\u2705 15-topshiriq:"},{"location":"python/tuples/","text":"\ud83e\udde9 5-DARS TUPLES \ud83d\udccc Tuple \u2014 bu Pythonda bir nechta ma\u2019lumotni bitta o\u2018zgaruvchida saqlash uchun ishlatiladigan o\u2018zgarmas tuzilma. U dumaloq qavs ichida yoziladi va elementlar vergul bilan ajratiladi. Tuple yaratilgach, uning ichidagi qiymatlarni o\u2018zgartirib, o\u2018chirib yoki yangisini qo\u2018shib bo\u2018lmaydi. Undagi ma\u2019lumotlar tartib bilan saqlanadi va indeks orqali chaqiriladi. Tuple listga o\u2018xshaydi, lekin o\u2018zgarmasligi bilan farq qiladi. U dasturda tezroq ishlaydi va kamroq xotira egallaydi. O\u2018zgarmas ma\u2019lumotlarni xavfsiz saqlash uchun tuple juda qulay. \u2705 TUPLE XUSUSIYATLARI \ud83d\udccc O\u2018zgarmaydi: Tuple yaratilgandan keyin uning ichidagi ma\u2019lumotlarni o\u2018zgartirib bo\u2018lmaydi. Masalan, yangi element qo\u2018shib yoki mavjudini o\u2018chirib bo\u2018lmaydi. Bu degani \u2014 tuple ichidagi ma\u2019lumotlar doim bir xil bo\u2018lib qoladi. \ud83d\udccc Tartibli: Tuple ichida ma\u2019lumotlar tartib bilan saqlanadi. Har bir element o\u2018z o\u2018rniga ega. Siz bu o\u2018rinni raqam bilan chaqirishingiz mumkin (masalan: birinchi element, ikkinchi element va hokazo). \ud83d\udccc Har xil turdagi ma\u2019lumot bo\u2018lishi mumkin: Tuple ichida sonlar, matnlar, True/False qiymatlar yoki boshqa turdagi ma\u2019lumotlar aralash bo\u2018lishi mumkin. Bularni bir joyda saqlash imkonini beradi. \ud83d\udccc Tez ishlaydi: Tuple \u2014 kompyuter uchun engil va tez tuzilma. Dastur ishlaganda tuplelar ro\u2018yxatlarga qaraganda tezroq ishlaydi va kam xotira ishlatadi. \ud83d\udccc O\u2018zgarmaydigan ma\u2019lumotlar uchun qulay: Agar sizda haftaning kunlari, oylar nomi, davlatlar ro\u2018yxati kabi o\u2018zgarmas ma\u2019lumotlar bo\u2018lsa, tuple juda foydali bo\u2018ladi. \u2705 TUPLE VA LIST FARQI Feature Tuple List O'zgarishi mumkinmi? Yo'q( immutable ) Ha( mutable ) Tezligi Tezroq Sekinroq Qavs turi () [] Xotira sarfi Kamroq Ko'proq Qo'llanilish holati O'zgarmas ma'lumotlar uchun O'zgaruvchi ma'lumotlar uchun \u2705 TUPLE YARATISH \u2747\ufe0f ODDIY TUPLE YARATISH # Uchta meva nomini o\u2018z ichiga olgan tuple yaratamiz fruits = (\"apple\", \"banana\", \"cherry\") # fruits tuple ichidagi barcha elementlarni ekranga chiqaramiz print(fruits) \u2747\ufe0f BITTA E'LEMENTLI TUPLE YARATISH # Faqat bitta elementdan iborat tuple yaratamiz # E\u2019tibor bering, oxirida vergul qo\u2018yilishi shart single_fruit = (\"apple\",) # Bitta elementli tuple ni ekranga chiqaramiz print(single_fruit) # \u274c Bu tuple emas (string bo\u2018lib qoladi) # Bu yerda vergul yo\u2018q, shuning uchun bu oddiy string bo\u2018ladi not_a_tuple = (\"apple\") # O\u2018zgaruvchi turi (type) ni tekshiramiz print(type(not_a_tuple)) # <class 'str'> \u2705 TUPLE E'LEMENTLARIGA MUROJAT QILISH \ud83d\udccc Tuple ichidagi har bir element tartib bilan joylashgan va ularga indekslar orqali murojaat qilish mumkin. Hisoblash 0 dan boshlanadi, ya\u2019ni birinchi elementning indeksi 0 bo\u2018ladi. Bu xuddi listdagi kabi ishlaydi. # Bu yerda 5 ta elementdan iborat tuple yaratilmoqda my_tuple = (10, 20, 30, 40, 50) # [0] \u2014 bu birinchi elementga murojaat, indeks 0 dan boshlanadi print(my_tuple[0]) # 10 # [2] \u2014 bu uchinchi elementga murojaat (0 - 1 - 2), qiymati 30 print(my_tuple[2]) # 30 # [-1] \u2014 bu oxirgi elementga murojaat, -1 doimo oxirgi elementni bildiradi print(my_tuple[-1]) # 50 \u2705 TUPLE USTIDA AMALLAR \ud83d\udccc Tuple \u2014 bu o\u2018zgarmas ma\u2019lumot turi. Ya\u2019ni, yaratilgach, uning ichidagi qiymatlarni o\u2018zgartirib, o\u2018chirib yoki yangisini qo\u2018shib bo\u2018lmaydi. Lekin, siz tuple bilan ikkita amalni bemalol bajara olasiz: Tuplelarni birlashtirish Tupleni takrorlash \u2733\ufe0f + OPERATORI \ud83d\udccc Bu usulda ikkita tuple birga qo\u2018shiladi va yangi tuple hosil bo\u2018ladi. Asl tuplelar o\u2018zgarmaydi. # Birinchi tuple tuple1 = (1, 2) # Ikkinchi tuple tuple2 = (3, 4) # Ikkalasini birlashtiramiz va yangi tuple hosil qilamiz new_tuple = tuple1 + tuple2 # Natijani chiqaramiz print(new_tuple) # (1, 2, 3, 4) \u2757 Yuqorida tuple1 va tuple2 o\u2018zgarmagan holda qoladi, faqat + orqali ularning qiymatlari birga qo\u2018shilib, new_tuple degan yangi tuple yaratiladi. \u2733\ufe0f TAKRORLASH \ud83d\udccc Agar bir tuple ni o\u2018zini o\u2018ziga birlashtirmoqchi bo\u2018lsangiz, uni yana o\u2018zi bilan + orqali birlashtirasiz. # Asl tuple tuple1 = (1, 2, 3) # O\u2018z-o\u2018ziga birlashtirish (ikki marta yozilgan bo\u2018ladi) result = tuple1 + tuple1 # Natijani chiqaramiz print(result) # (1, 2, 3, 1, 2, 3) \u2747\ufe0f TUPLENI KO'PAYTIRISH (TAKRORLASH) \ud83d\udccc Tuple o\u2018zgarmas bo\u2018lsa ham, uni bir nechta marta takrorlab yangi tuple yaratish mumkin. Buning uchun * operatoridan foydalaniladi. # Bitta elementdan iborat tuple yaratilmoqda tuple1 = (\"hello\",) # Bu tuple 3 marta takrorlanmoqda new_tuple = tuple1 * 3 # Natijada yangi tuple hosil bo\u2018ladi print(new_tuple) # ('hello', 'hello', 'hello') \u2747\ufe0f TUPLE UZUNLIGINI ANIQLASH \ud83d\udccc Tuple ichida nechta element borligini bilish uchun len() funksiyasidan foydalaniladi. Bu funksiya tuple uzunligini, ya\u2019ni elementlar sonini qaytaradi. # 5 ta elementdan iborat tuple yaratilmoqda my_tuple = (1, 2, 3, 4, 5) # len() funksiyasi tuple ichidagi elementlar sonini hisoblaydi print(len(my_tuple)) # 5 \u2747\ufe0f in OPERATORI \ud83d\udccc in operatori yordamida biror qiymat tuple ichida bor yoki yo\u2018qligini tekshirish mumkin. Natija True yoki False ko\u2018rinishida chiqadi. # Mevalar saqlangan tuple yaratilmoqda my_tuple = (\"apple\", \"banana\", \"cherry\") # \"banana\" tuple ichida bormi? degan savolga javob tekshirilmoqda print(\"banana\" in my_tuple) # True \u2747\ufe0f TUPLENI QIYMATLARGA AJRATISH( Unpacking ) \ud83d\udccc Tuple ichidagi har bir qiymatni alohida o\u2018zgaruvchiga ajratib olish mumkin. Bunga Pythonda unpacking deyiladi. # 3 ta meva nomidan iborat tuple yaratilmoqda my_tuple = (\"apple\", \"banana\", \"cherry\") # Tuple ichidagi har bir qiymat alohida o\u2018zgaruvchiga ajratilmoqda (fruit1, fruit2, fruit3) = my_tuple # Har bir o\u2018zgaruvchidagi qiymat ekranga chiqariladi print(fruit1) # 'apple' print(fruit2) # 'banana' print(fruit3) # 'cherry' \u2747\ufe0f NESTED TUPLE \ud83d\udccc Tuple ichida yana boshqa tuple ham saqlanishi mumkin. Bunga ichma-ich tuple yoki nested tuple deyiladi. # Bu yerda talaba haqida ma'lumotlar saqlanmoqda: # ism, yosh, va baholar (baholar alohida tuple ichida) student = (\"Ali\", 20, (85, 90, 95)) # Indeks 0 \u2014 ismni beradi print(student[0]) # Ali # Indeks 1 \u2014 yoshni beradi print(student[1]) # 20 # Indeks 2 \u2014 baholar joylashgan ichki tuple print(student[2]) # (85, 90, 95) # Ichki tuple ichidagi ikkinchi bahoni olish print(student[2][1]) # 90 \u2747\ufe0f TUPLE BILAN ISHLASHDA FOYDALI METODLAR \u2733\ufe0f .count() \ud83d\udccc Bu funksiya siz bergan qiymatni tuple ichida qidiradi va nechta marta borligini sanaydi. Agar qiymat topilmasa, 0 qaytaradi. # Bir nechta takrorlanuvchi sonlardan iborat tuple my_tuple = (1, 2, 2, 3, 2) # 2 soni tuple ichida necha marta borligini hisoblaydi print(my_tuple.count(2)) # 3 \u2733\ufe0f .index() \ud83d\udccc Bu metod tuple ichida berilgan qiymat qayerda turganini aniqlaydi, ya\u2019ni indeks raqamini qaytaradi. # Elementlar ketma-ketligi my_tuple = (1, 2, 3, 2, 4) # 2 soni birinchi bo\u2018lib qayerda uchraganini topadi (indeks 1) print(my_tuple.index(2)) # 1 \u2705 AMALIYOT \u2705 1-topshiriq: Quyidagi 3 ta hayvon nomidan iborat animals degan tuple yarating va ekranga chiqaring: - \"quyon\" , \"mushuk\" , \"it\" \u2705 2-topshiriq: Faqat \"apple\" qiymatidan iborat tuple yarating. - Vergul qo\u2018yilmasa, bu oddiy string bo\u2018lib qoladi. To\u2018g\u2018ri tuple yarating. \u2705 3-topshiriq: Quyidagi tupledagi ikkinchi elementni ekranga chiqaring: colors = (\"red\", \"green\", \"blue\") \u2705 4-topshiriq: Quyidagi tupledan oxirgi elementni -1 indeks yordamida chiqaring: numbers = (5, 10, 15, 20) \u2705 5-topshiriq: Quyidagi ikki tupleni + operatori yordamida birlashtiring va yangi result nomli tuple yarating: a = (1, 2) b = (3, 4) \u2705 6-topshiriq: Quyidagi tuple 3 marta takrorlab new_tuple degan yangi tuple yarating: word = (\"Hi\",) \u2705 7-topshiriq: Quyidagi tuple ichida nechta element borligini len() yordamida aniqlang: digits = (1, 2, 3, 4, 5, 6) \u2705 8-topshiriq: Quyidagi tupleda \"banana\" bor yoki yo\u2018qligini in operatori yordamida tekshirib chiqaring: fruits = (\"apple\", \"banana\", \"cherry\") \u2705 9-topshiriq: Quyidagi tupledagi qiymatlarni alohida 3 ta o\u2018zgaruvchiga ajrating ( unpacking qiling): person = (\"Ali\", 25, \"Toshkent\") \u2705 10-topshiriq: Quyidagi nested tupledan 90 sonini alohida olib ekranga chiqaring: student = (\"Ali\", 20, (85, 90, 95)) \u2705 11-topshiriq: Quyidagi tupleda 2 soni nechta marta qatnashganini .count() yordamida aniqlang: data = (1, 2, 3, 2, 4, 2) \u2705 12-topshiriq: Quyidagi tupleda 3 soni birinchi marta qaysi indeksda turganini .index() yordamida aniqlang: nums = (5, 3, 7, 3, 9) \u2705 13-topshiriq: Quyidagi kodda tuple emas, string yaratilgan. Uni tuzatib, haqiqiy tuple holatiga keltiring: item = (\"book\") \u2705 14-topshiriq: Quyidagi tupledan \"Python\" so\u2018zini indeks yordamida ajratib oling: langs = (\"C++\", \"Python\", \"Java\") \u2705 15-topshiriq: Quyidagi ikki tupleni + operatori yordamida birlashtiring va new_tuple nomli yangi tuplega saqlang: tuple1 = (\"a\", \"b\") tuple2 = (\"c\", \"d\", \"e\")","title":"Tuples"},{"location":"python/tuples/#5-dars-tuples","text":"\ud83d\udccc Tuple \u2014 bu Pythonda bir nechta ma\u2019lumotni bitta o\u2018zgaruvchida saqlash uchun ishlatiladigan o\u2018zgarmas tuzilma. U dumaloq qavs ichida yoziladi va elementlar vergul bilan ajratiladi. Tuple yaratilgach, uning ichidagi qiymatlarni o\u2018zgartirib, o\u2018chirib yoki yangisini qo\u2018shib bo\u2018lmaydi. Undagi ma\u2019lumotlar tartib bilan saqlanadi va indeks orqali chaqiriladi. Tuple listga o\u2018xshaydi, lekin o\u2018zgarmasligi bilan farq qiladi. U dasturda tezroq ishlaydi va kamroq xotira egallaydi. O\u2018zgarmas ma\u2019lumotlarni xavfsiz saqlash uchun tuple juda qulay.","title":"\ud83e\udde9 5-DARS TUPLES"},{"location":"python/tuples/#tuple-xususiyatlari","text":"\ud83d\udccc O\u2018zgarmaydi: Tuple yaratilgandan keyin uning ichidagi ma\u2019lumotlarni o\u2018zgartirib bo\u2018lmaydi. Masalan, yangi element qo\u2018shib yoki mavjudini o\u2018chirib bo\u2018lmaydi. Bu degani \u2014 tuple ichidagi ma\u2019lumotlar doim bir xil bo\u2018lib qoladi. \ud83d\udccc Tartibli: Tuple ichida ma\u2019lumotlar tartib bilan saqlanadi. Har bir element o\u2018z o\u2018rniga ega. Siz bu o\u2018rinni raqam bilan chaqirishingiz mumkin (masalan: birinchi element, ikkinchi element va hokazo). \ud83d\udccc Har xil turdagi ma\u2019lumot bo\u2018lishi mumkin: Tuple ichida sonlar, matnlar, True/False qiymatlar yoki boshqa turdagi ma\u2019lumotlar aralash bo\u2018lishi mumkin. Bularni bir joyda saqlash imkonini beradi. \ud83d\udccc Tez ishlaydi: Tuple \u2014 kompyuter uchun engil va tez tuzilma. Dastur ishlaganda tuplelar ro\u2018yxatlarga qaraganda tezroq ishlaydi va kam xotira ishlatadi. \ud83d\udccc O\u2018zgarmaydigan ma\u2019lumotlar uchun qulay: Agar sizda haftaning kunlari, oylar nomi, davlatlar ro\u2018yxati kabi o\u2018zgarmas ma\u2019lumotlar bo\u2018lsa, tuple juda foydali bo\u2018ladi.","title":"\u2705 TUPLE XUSUSIYATLARI"},{"location":"python/tuples/#tuple-va-list-farqi","text":"Feature Tuple List O'zgarishi mumkinmi? Yo'q( immutable ) Ha( mutable ) Tezligi Tezroq Sekinroq Qavs turi () [] Xotira sarfi Kamroq Ko'proq Qo'llanilish holati O'zgarmas ma'lumotlar uchun O'zgaruvchi ma'lumotlar uchun","title":"\u2705 TUPLE VA LIST FARQI"},{"location":"python/tuples/#tuple-yaratish","text":"","title":"\u2705 TUPLE YARATISH"},{"location":"python/tuples/#oddiy-tuple-yaratish","text":"# Uchta meva nomini o\u2018z ichiga olgan tuple yaratamiz fruits = (\"apple\", \"banana\", \"cherry\") # fruits tuple ichidagi barcha elementlarni ekranga chiqaramiz print(fruits)","title":"\u2747\ufe0f ODDIY TUPLE YARATISH"},{"location":"python/tuples/#bitta-elementli-tuple-yaratish","text":"# Faqat bitta elementdan iborat tuple yaratamiz # E\u2019tibor bering, oxirida vergul qo\u2018yilishi shart single_fruit = (\"apple\",) # Bitta elementli tuple ni ekranga chiqaramiz print(single_fruit) # \u274c Bu tuple emas (string bo\u2018lib qoladi) # Bu yerda vergul yo\u2018q, shuning uchun bu oddiy string bo\u2018ladi not_a_tuple = (\"apple\") # O\u2018zgaruvchi turi (type) ni tekshiramiz print(type(not_a_tuple)) # <class 'str'>","title":"\u2747\ufe0f BITTA E'LEMENTLI TUPLE YARATISH"},{"location":"python/tuples/#tuple-elementlariga-murojat-qilish","text":"\ud83d\udccc Tuple ichidagi har bir element tartib bilan joylashgan va ularga indekslar orqali murojaat qilish mumkin. Hisoblash 0 dan boshlanadi, ya\u2019ni birinchi elementning indeksi 0 bo\u2018ladi. Bu xuddi listdagi kabi ishlaydi. # Bu yerda 5 ta elementdan iborat tuple yaratilmoqda my_tuple = (10, 20, 30, 40, 50) # [0] \u2014 bu birinchi elementga murojaat, indeks 0 dan boshlanadi print(my_tuple[0]) # 10 # [2] \u2014 bu uchinchi elementga murojaat (0 - 1 - 2), qiymati 30 print(my_tuple[2]) # 30 # [-1] \u2014 bu oxirgi elementga murojaat, -1 doimo oxirgi elementni bildiradi print(my_tuple[-1]) # 50","title":"\u2705 TUPLE E'LEMENTLARIGA MUROJAT QILISH"},{"location":"python/tuples/#tuple-ustida-amallar","text":"\ud83d\udccc Tuple \u2014 bu o\u2018zgarmas ma\u2019lumot turi. Ya\u2019ni, yaratilgach, uning ichidagi qiymatlarni o\u2018zgartirib, o\u2018chirib yoki yangisini qo\u2018shib bo\u2018lmaydi. Lekin, siz tuple bilan ikkita amalni bemalol bajara olasiz: Tuplelarni birlashtirish Tupleni takrorlash","title":"\u2705 TUPLE USTIDA AMALLAR"},{"location":"python/tuples/#operatori","text":"\ud83d\udccc Bu usulda ikkita tuple birga qo\u2018shiladi va yangi tuple hosil bo\u2018ladi. Asl tuplelar o\u2018zgarmaydi. # Birinchi tuple tuple1 = (1, 2) # Ikkinchi tuple tuple2 = (3, 4) # Ikkalasini birlashtiramiz va yangi tuple hosil qilamiz new_tuple = tuple1 + tuple2 # Natijani chiqaramiz print(new_tuple) # (1, 2, 3, 4) \u2757 Yuqorida tuple1 va tuple2 o\u2018zgarmagan holda qoladi, faqat + orqali ularning qiymatlari birga qo\u2018shilib, new_tuple degan yangi tuple yaratiladi.","title":"\u2733\ufe0f + OPERATORI"},{"location":"python/tuples/#takrorlash","text":"\ud83d\udccc Agar bir tuple ni o\u2018zini o\u2018ziga birlashtirmoqchi bo\u2018lsangiz, uni yana o\u2018zi bilan + orqali birlashtirasiz. # Asl tuple tuple1 = (1, 2, 3) # O\u2018z-o\u2018ziga birlashtirish (ikki marta yozilgan bo\u2018ladi) result = tuple1 + tuple1 # Natijani chiqaramiz print(result) # (1, 2, 3, 1, 2, 3)","title":"\u2733\ufe0f TAKRORLASH"},{"location":"python/tuples/#tupleni-kopaytirish-takrorlash","text":"\ud83d\udccc Tuple o\u2018zgarmas bo\u2018lsa ham, uni bir nechta marta takrorlab yangi tuple yaratish mumkin. Buning uchun * operatoridan foydalaniladi. # Bitta elementdan iborat tuple yaratilmoqda tuple1 = (\"hello\",) # Bu tuple 3 marta takrorlanmoqda new_tuple = tuple1 * 3 # Natijada yangi tuple hosil bo\u2018ladi print(new_tuple) # ('hello', 'hello', 'hello')","title":"\u2747\ufe0f TUPLENI KO'PAYTIRISH (TAKRORLASH)"},{"location":"python/tuples/#tuple-uzunligini-aniqlash","text":"\ud83d\udccc Tuple ichida nechta element borligini bilish uchun len() funksiyasidan foydalaniladi. Bu funksiya tuple uzunligini, ya\u2019ni elementlar sonini qaytaradi. # 5 ta elementdan iborat tuple yaratilmoqda my_tuple = (1, 2, 3, 4, 5) # len() funksiyasi tuple ichidagi elementlar sonini hisoblaydi print(len(my_tuple)) # 5","title":"\u2747\ufe0f TUPLE UZUNLIGINI ANIQLASH"},{"location":"python/tuples/#in-operatori","text":"\ud83d\udccc in operatori yordamida biror qiymat tuple ichida bor yoki yo\u2018qligini tekshirish mumkin. Natija True yoki False ko\u2018rinishida chiqadi. # Mevalar saqlangan tuple yaratilmoqda my_tuple = (\"apple\", \"banana\", \"cherry\") # \"banana\" tuple ichida bormi? degan savolga javob tekshirilmoqda print(\"banana\" in my_tuple) # True","title":"\u2747\ufe0f in OPERATORI"},{"location":"python/tuples/#tupleni-qiymatlarga-ajratishunpacking","text":"\ud83d\udccc Tuple ichidagi har bir qiymatni alohida o\u2018zgaruvchiga ajratib olish mumkin. Bunga Pythonda unpacking deyiladi. # 3 ta meva nomidan iborat tuple yaratilmoqda my_tuple = (\"apple\", \"banana\", \"cherry\") # Tuple ichidagi har bir qiymat alohida o\u2018zgaruvchiga ajratilmoqda (fruit1, fruit2, fruit3) = my_tuple # Har bir o\u2018zgaruvchidagi qiymat ekranga chiqariladi print(fruit1) # 'apple' print(fruit2) # 'banana' print(fruit3) # 'cherry'","title":"\u2747\ufe0f TUPLENI QIYMATLARGA AJRATISH(Unpacking)"},{"location":"python/tuples/#nested-tuple","text":"\ud83d\udccc Tuple ichida yana boshqa tuple ham saqlanishi mumkin. Bunga ichma-ich tuple yoki nested tuple deyiladi. # Bu yerda talaba haqida ma'lumotlar saqlanmoqda: # ism, yosh, va baholar (baholar alohida tuple ichida) student = (\"Ali\", 20, (85, 90, 95)) # Indeks 0 \u2014 ismni beradi print(student[0]) # Ali # Indeks 1 \u2014 yoshni beradi print(student[1]) # 20 # Indeks 2 \u2014 baholar joylashgan ichki tuple print(student[2]) # (85, 90, 95) # Ichki tuple ichidagi ikkinchi bahoni olish print(student[2][1]) # 90","title":"\u2747\ufe0f NESTED TUPLE"},{"location":"python/tuples/#tuple-bilan-ishlashda-foydali-metodlar","text":"","title":"\u2747\ufe0f TUPLE BILAN ISHLASHDA FOYDALI METODLAR"},{"location":"python/tuples/#count","text":"\ud83d\udccc Bu funksiya siz bergan qiymatni tuple ichida qidiradi va nechta marta borligini sanaydi. Agar qiymat topilmasa, 0 qaytaradi. # Bir nechta takrorlanuvchi sonlardan iborat tuple my_tuple = (1, 2, 2, 3, 2) # 2 soni tuple ichida necha marta borligini hisoblaydi print(my_tuple.count(2)) # 3","title":"\u2733\ufe0f .count()"},{"location":"python/tuples/#index","text":"\ud83d\udccc Bu metod tuple ichida berilgan qiymat qayerda turganini aniqlaydi, ya\u2019ni indeks raqamini qaytaradi. # Elementlar ketma-ketligi my_tuple = (1, 2, 3, 2, 4) # 2 soni birinchi bo\u2018lib qayerda uchraganini topadi (indeks 1) print(my_tuple.index(2)) # 1","title":"\u2733\ufe0f .index()"},{"location":"python/tuples/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/tuples/#1-topshiriq","text":"Quyidagi 3 ta hayvon nomidan iborat animals degan tuple yarating va ekranga chiqaring: - \"quyon\" , \"mushuk\" , \"it\"","title":"\u2705 1-topshiriq:"},{"location":"python/tuples/#2-topshiriq","text":"Faqat \"apple\" qiymatidan iborat tuple yarating. - Vergul qo\u2018yilmasa, bu oddiy string bo\u2018lib qoladi. To\u2018g\u2018ri tuple yarating.","title":"\u2705 2-topshiriq:"},{"location":"python/tuples/#3-topshiriq","text":"Quyidagi tupledagi ikkinchi elementni ekranga chiqaring: colors = (\"red\", \"green\", \"blue\")","title":"\u2705 3-topshiriq:"},{"location":"python/tuples/#4-topshiriq","text":"Quyidagi tupledan oxirgi elementni -1 indeks yordamida chiqaring: numbers = (5, 10, 15, 20)","title":"\u2705 4-topshiriq:"},{"location":"python/tuples/#5-topshiriq","text":"Quyidagi ikki tupleni + operatori yordamida birlashtiring va yangi result nomli tuple yarating: a = (1, 2) b = (3, 4)","title":"\u2705 5-topshiriq:"},{"location":"python/tuples/#6-topshiriq","text":"Quyidagi tuple 3 marta takrorlab new_tuple degan yangi tuple yarating: word = (\"Hi\",)","title":"\u2705 6-topshiriq:"},{"location":"python/tuples/#7-topshiriq","text":"Quyidagi tuple ichida nechta element borligini len() yordamida aniqlang: digits = (1, 2, 3, 4, 5, 6)","title":"\u2705 7-topshiriq:"},{"location":"python/tuples/#8-topshiriq","text":"Quyidagi tupleda \"banana\" bor yoki yo\u2018qligini in operatori yordamida tekshirib chiqaring: fruits = (\"apple\", \"banana\", \"cherry\")","title":"\u2705 8-topshiriq:"},{"location":"python/tuples/#9-topshiriq","text":"Quyidagi tupledagi qiymatlarni alohida 3 ta o\u2018zgaruvchiga ajrating ( unpacking qiling): person = (\"Ali\", 25, \"Toshkent\")","title":"\u2705 9-topshiriq:"},{"location":"python/tuples/#10-topshiriq","text":"Quyidagi nested tupledan 90 sonini alohida olib ekranga chiqaring: student = (\"Ali\", 20, (85, 90, 95))","title":"\u2705 10-topshiriq:"},{"location":"python/tuples/#11-topshiriq","text":"Quyidagi tupleda 2 soni nechta marta qatnashganini .count() yordamida aniqlang: data = (1, 2, 3, 2, 4, 2)","title":"\u2705 11-topshiriq:"},{"location":"python/tuples/#12-topshiriq","text":"Quyidagi tupleda 3 soni birinchi marta qaysi indeksda turganini .index() yordamida aniqlang: nums = (5, 3, 7, 3, 9)","title":"\u2705 12-topshiriq:"},{"location":"python/tuples/#13-topshiriq","text":"Quyidagi kodda tuple emas, string yaratilgan. Uni tuzatib, haqiqiy tuple holatiga keltiring: item = (\"book\")","title":"\u2705 13-topshiriq:"},{"location":"python/tuples/#14-topshiriq","text":"Quyidagi tupledan \"Python\" so\u2018zini indeks yordamida ajratib oling: langs = (\"C++\", \"Python\", \"Java\")","title":"\u2705 14-topshiriq:"},{"location":"python/tuples/#15-topshiriq","text":"Quyidagi ikki tupleni + operatori yordamida birlashtiring va new_tuple nomli yangi tuplega saqlang: tuple1 = (\"a\", \"b\") tuple2 = (\"c\", \"d\", \"e\")","title":"\u2705 15-topshiriq:"},{"location":"python/variables/","text":"\ud83e\udde9 01-DARS VARIABLES \u2705 O'ZGARUVCHI NIMA? \ud83d\udccc Python dasturlash tilida o\u2018zgaruvchi (variable) \u2014 bu kompyuterda ma\u2019lumotni vaqtincha saqlab turadigan nomlangan joy . Bu joyga biz har qanday ma\u2019lumotni (masalan, matn, son) joylashtirishimiz mumkin. Keyin bu nom orqali o\u2018sha ma\u2019lumotdan foydalanish, o\u2018zgartirish yoki hisoblash osonlashadi. O\u2018zgaruvchilar bizga dastur ichida ma\u2019lumot bilan ishlashni tartibli va qulay qiladi. Har safar ma\u2019lumotni qayta yozmasdan, nomini chaqirib ishlatishimiz mumkin . \ud83d\udccc Quyidagi misolda 4 ta o'zgaruvchi yaratdik ( x , y , name va is_student ) va ularga har xil ma'lumot yukladik. # Butun sonni (integer) o'zgaruvchiga saqlaymiz x = 5 # Haqiqiy sonni (float) o'zgaruvchiga saqlaymiz y = 3.14 # Matn (string) qiymatni o'zgaruvchiga saqlaymiz name = \"Alice\" # Mantiqiy (boolean) qiymatni o'zgaruvchiga saqlaymiz is_student = True # x o'zgaruvchisining qiymatini chiqaramiz print(x) # y o'zgaruvchisining qiymatini chiqaramiz print(y) # name o'zgaruvchisining qiymatini chiqaramiz print(name) # is_student o'zgaruvchisining qiymatini chiqaramiz print(is_student) \ud83d\udccc variable diyilishini sababi uning qiymati istalgan payt o'zgarishi mumkin: # 'name' o'zgaruvchisiga dastlab 'Alisher' matnini beramiz name = 'Alisher' # name o'zgaruvchisining hozirgi qiymatini chiqaramiz (Alisher) print(name) # name o'zgaruvchisining qiymatini o'zgartiramiz, endi u 'Muhammad' bo'ladi name = \"Muhammad\" # name o'zgaruvchisining yangi qiymatini chiqaramiz (Muhammad) print(name) \u2705 O'ZGARUVCHILARNI NOMLASH \u2757 O'zgaruvchilarga nom berishda quyidagi qoidalarga amal qiling: \u274c O'zgaruvchi nomi harf yoki pastki chiziq ( _ ) bilan boshlanishi kerak \u2705 To\u2018g\u2018ri: # Harflardan tashkil topgan oddiy o'zgaruvchi nomi ism = \"Ali\" # Pastki chiziq (_) bilan boshlangan o'zgaruvchi nomi _yosh = 25 \u274c Noto\u2018g\u2018ri: # \u274c Son bilan boshlanmaydi 1ism = \"Ali\" \u274c O'zgaruvchi nomi raqam bilan boshlanishi mumkin emas \ud83d\udccc Raqam faqat nomning oxirida yoki o\u2018rtasida ishlatilishi mumkin. \u2705 To\u2018g\u2018ri: # O'zgaruvchi nomi harf bilan boshlangan va raqam bilan tugagan \u2014 to'g'ri raqam1 = 10 # O'zgaruvchi nomi harf bilan boshlangan va oxirida raqam ishlatilgan \u2014 to'g'ri sana2025 = 2025 \u274c Noto\u2018g\u2018ri: # \u274c Raqam bilan boshlanmaydi 3dars = \"Python\" \u274c O'zgaruvchi nomida faqatgina ingliz tili alifbosi harflari ( A-z ), raqamlar ( 0-9 ) va pastki chiziq ( _ ) qatnashishi mumkin \ud83d\udccc Maxsus belgilar ( @ , ! , # , - va boshqalar) o\u2018zgaruvchi nomida ishlatilmaydi. \u2705 To\u2018g\u2018ri: # Lotin harflari va pastki chiziq ishlatilgan \u2014 to\u2018g\u2018ri user_name = \"Umid\" # Harf va raqam ishlatilgan \u2014 to\u2018g\u2018ri user1 = \"Ali\" # Pastki chiziq bilan boshlangan nom \u2014 bu ham to\u2018g\u2018ri _max_score = 100 \u274c Noto\u2018g\u2018ri: # O'zgaruvchi nomida '@' belgisi ishlatilgan \u2014 bu noto\u2018g\u2018ri # \u274c Maxsus belgilar (masalan: @) Python'da o'zgaruvchi nomida bo'lmasligi kerak ism@familiya = \"Valijon\" # O'zgaruvchi nomida '!' belgisi ishlatilgan \u2014 bu ham noto\u2018g\u2018ri # \u274c Maxsus belgilar (masalan: !) ruxsat etilmaydi yosh! = 18 \u274c O'zgaruvchi nomida bo'shliq (\u043f\u0440\u043e\u0431\u0435\u043b) bo'lishi mumkin emas \u2705 To\u2018g\u2018ri: # O'zgaruvchi nomida pastki chiziq ishlatilgan \u2014 bu to\u2018g\u2018ri usul ism_familiya = \"Ali Karimov\" \u274c Noto\u2018g\u2018ri: # O'zgaruvchi nomida bo\u2018shliq (space) ishlatilgan \u2014 bu noto\u2018g\u2018ri # \u274c Python'da o'zgaruvchi nomi bo\u2018shliq bilan yozilmaydi ism familiya = \"Ali Karimov\" \u274c O'zgaruvchi nomida katta-kichik harflar turlicha talqin qilinadi ( ism , ISM , va Ism uchta turli o'zgaruvchi) \ud83d\udccc Pythonda ism , ISM va Ism bu uchta alohida o\u2018zgaruvchi hisoblanadi. # kichik harflardan tashkil topgan o'zgaruvchi ism = \"Ali\" # hamma harflari katta bo'lgan o'zgaruvchi \u2014 bu boshqa o'zgaruvchi ISM = \"Vali\" # bosh harfi katta, qolgan kichik bo'lgan o'zgaruvchi \u2014 yana boshqa o'zgaruvchi Ism = \"Sami\" # 'ism' o'zgaruvchisining qiymatini chiqaramiz print(ism) # Ali # 'ISM' o'zgaruvchisining qiymatini chiqaramiz print(ISM) # Vali # 'Ism' o'zgaruvchisining qiymatini chiqaramiz print(Ism) # Sami \u2705 QO'SHIMCHA QOIDALAR \u2747\ufe0f O'zgaruvchi nomini kichik harflar bilan yozing. \ud83d\udccc Python kodini o\u2018qishda va tushunishda qulaylik uchun o\u2018zgaruvchilarni kichik harflar bilan yozish odatiy hisoblanadi. # To'g'ri va tavsiya qilinadigan usul \u2014 o'zgaruvchi nomi kichik harflardan iborat ism = \"Umid\" # Tavsiya qilinmaydi \u2014 bosh harf bilan boshlash kodda chalkashlik keltirib chiqarishi mumkin Ism = \"Umid\" # Tavsiya qilinmaydi \u2014 hamma harflar katta bo\u2018lishi ko\u2018pincha konstantalar uchun ishlatiladi ISM = \"Umid\" \u2747\ufe0f O'zgaruvchi nomida 2 va undan ortiq so'z qatnashsa ularning orasini pastki chiziq ( _ ) bilan ajrating ( ism_sharif=\"Umid G'aybullayev\" ) \ud83d\udccc Bu usul o\u2018zgaruvchi nomini o\u2018qishni osonlashtiradi va kodni yanada tushunarli qiladi. # Ikkita so\u2018zdan tashkil topgan o'zgaruvchi nomi, so\u2018zlar pastki chiziq bilan ajratilgan ism_sharif = \"Umid G'aybullayev\" # Ikkita so\u2018zdan tashkil topgan o'zgaruvchi nomi, so\u2018zlar pastki chiziq yordamida bog\u2018langan tugilgan_yil = 2004 \u2747\ufe0f O'zgaruvchiga tushunarli nom bering ( y=20 emas yosh=20 , d=\"Korea\" emas davlat = \"Korea\" va hokazo) \ud83d\udccc O\u2018zgaruvchi nomi uning ma\u2019nosini ifodalashi kerak, shunda kodni o\u2018qish va tushunish osonlashadi. # Yomon misollar \u2014 nomlar qisqa va ma\u2019nosiz, kodni tushunishni qiyinlashtiradi y = 20 d = \"Korea\" # Yaxshi misollar \u2014 nomlar ma\u2019noli va tushunarli yosh = 20 davlat = \"Korea\" \u2747\ufe0f Shuningdek o'zgaruvchilarga Pythonda ishlatiladigan funksiyalar va maxsus kalit so'zlarning(keywords) nomini bermang. Kalit so'zlar ro'yhatini ko'rish uchun python faylga uyidagi kodni yozamiz: \ud83d\udccc Chunki bu nomlar Python tili tomonidan maxsus ma\u2019noga ega va ular bilan nomlash kodni buzadi yoki xato beradi. # Python kalit so'zlarini ko'rish uchun quyidagilarni yozamiz import keyword # Python kalit so'zlar ro'yxatini chiqaramiz print(keyword.kwlist) \u2705 To\u2018g\u2018ri: # To\u2018g\u2018ri misollar \u2014 kalit so'zlarni o'zgaruvchi nomining bir qismi sifatida ishlatish mumkin def_funksiya = 10 for_son = 20 \u274c Noto\u2018g\u2018ri: # Noto\u2018g\u2018ri misollar \u2014 kalit so\u2018zlarni o\u2018zgaruvchi nomi sifatida ishlatish mumkin emas def = 10 # \u274c 'def' kalit so'z, o'zgaruvchi sifatida ishlatilmaydi for = 20 # \u274c 'for' kalit so'z, o'zgaruvchi sifatida ishlatilmaydi \u2705 AMALIYOT \u2705 1-topshiriq: Quyidagi qiymatlarni o\u2018zgaruvchilarga yuklang va print() orqali ekranga chiqaring: - ismingiz - yoshingiz - sevimli soningiz - talaba ekanligingiz (True yoki False) \u2705 2-topshiriq: Quyidagi ma\u2019lumotlar uchun mos o\u2018zgaruvchilar yarating: kitob_nomi \u2192 \u201cSariq devni minib\u201d muallif \u2192 \u201cXudoyberdi To\u2018xtaboyev\u201d sahifalar_soni \u2192 185 Ularni print() yordamida chiqarib bering. \u2705 3-topshiriq: Quyidagi noto\u2018g\u2018ri o\u2018zgaruvchi nomlarini to\u2018g\u2018rilang: 1kitob = \"Python\" ism familiya = \"Ali Karimov\" davlat@ = \"Uzbekistan\" \u2705 4-topshiriq: Quyidagi qiymatlarni saqlovchi o\u2018zgaruvchilarni yarating va print() bilan ularning turini (type()) chiqaring: yosh = 25 baho = 4.5 ism = \"Dilshod\" is_student = False \u2705 5-topshiriq: Quyidagi kodni yozing: name o\u2018zgaruvchisi yarating va unga ism kiriting. Keyin, uning qiymatini boshqa ism bilan almashtiring. Har ikkala holatda qiymatni ekranga chiqaring. \u2705 6-topshiriq: Quyidagi noto\u2018g\u2018ri o\u2018zgaruvchilarni aniqlang va nega xato ekanligini yozing: for = \"dars\" def = \"funksiya\" yosh! = 20 \u2705 7-topshiriq: Quyidagi ikkita o\u2018zgaruvchini yarating: ism = \"Jamshid\" ISM = \"Anvar\" Ularning ikkalasini print() bilan chiqaring va nima sababdan ikkala qiymat chiqayotganini tushuntiring. \u2705 8-topshiriq: O\u2018zgaruvchi nomlarida pastki chiziq (_) ishlatish kerak bo\u2018lgan 3 ta misol yozing. Masalan: foydalanuvchi_ismi, kitob_soni, manzil_nomi \u2705 9-topshiriq: Tushunarli va tushunarsiz o\u2018zgaruvchi nomlariga 3 tadan misol yozing: Yaxshi: yosh, davlat, kitob_nomi Yomon: x, d, n1 \u2705 10-topshiriq: Quyidagi kodni to\u2018g\u2018ri ko\u2018rinishga keltiring: 3son = 25 user name = \"Ali\" yosh@ = 20 \u2705 11-topshiriq: Quyidagi o\u2018zgaruvchilarni yarating va print() yordamida ularni chiqarib bering: kitob_nomi = \"Yulduzli tunlar\" muallif = \"Pirimqul Qodirov\" narx = 37000 mavjud = True \u2705 12-topshiriq: Kalit so\u2018zlar ro\u2018yxatini ko\u2018rsatadigan kod yozing va uni bajaring. Kod natijasida ekranda Python kalit so\u2018zlari chiqishi kerak. \u2705 13-topshiriq: Quyidagi kodni tahlil qiling. Nima sababdan xatolik borligini tushuntiring: import = \"data\" True = 1 \u2705 14-topshiriq: O\u2018zgaruvchilarni quyidagi ma\u2019nolarga qarab yarating: Foydalanuvchining ismi Parol Email manzili Tug\u2018ilgan yili \u2705 15-topshiriq: Quyidagi qiymatlar uchun mos o\u2018zgaruvchilar yarating va ularni print() yordamida chiqarib, bir satrda type() funksiyasi bilan ularning turlarini ham ko\u2018rsating: ism = \"Sardor\" yosh = 22 talaba = True ball = 4.9","title":"Variables"},{"location":"python/variables/#01-dars-variables","text":"","title":"\ud83e\udde9 01-DARS VARIABLES"},{"location":"python/variables/#ozgaruvchi-nima","text":"\ud83d\udccc Python dasturlash tilida o\u2018zgaruvchi (variable) \u2014 bu kompyuterda ma\u2019lumotni vaqtincha saqlab turadigan nomlangan joy . Bu joyga biz har qanday ma\u2019lumotni (masalan, matn, son) joylashtirishimiz mumkin. Keyin bu nom orqali o\u2018sha ma\u2019lumotdan foydalanish, o\u2018zgartirish yoki hisoblash osonlashadi. O\u2018zgaruvchilar bizga dastur ichida ma\u2019lumot bilan ishlashni tartibli va qulay qiladi. Har safar ma\u2019lumotni qayta yozmasdan, nomini chaqirib ishlatishimiz mumkin . \ud83d\udccc Quyidagi misolda 4 ta o'zgaruvchi yaratdik ( x , y , name va is_student ) va ularga har xil ma'lumot yukladik. # Butun sonni (integer) o'zgaruvchiga saqlaymiz x = 5 # Haqiqiy sonni (float) o'zgaruvchiga saqlaymiz y = 3.14 # Matn (string) qiymatni o'zgaruvchiga saqlaymiz name = \"Alice\" # Mantiqiy (boolean) qiymatni o'zgaruvchiga saqlaymiz is_student = True # x o'zgaruvchisining qiymatini chiqaramiz print(x) # y o'zgaruvchisining qiymatini chiqaramiz print(y) # name o'zgaruvchisining qiymatini chiqaramiz print(name) # is_student o'zgaruvchisining qiymatini chiqaramiz print(is_student) \ud83d\udccc variable diyilishini sababi uning qiymati istalgan payt o'zgarishi mumkin: # 'name' o'zgaruvchisiga dastlab 'Alisher' matnini beramiz name = 'Alisher' # name o'zgaruvchisining hozirgi qiymatini chiqaramiz (Alisher) print(name) # name o'zgaruvchisining qiymatini o'zgartiramiz, endi u 'Muhammad' bo'ladi name = \"Muhammad\" # name o'zgaruvchisining yangi qiymatini chiqaramiz (Muhammad) print(name)","title":"\u2705 O'ZGARUVCHI NIMA?"},{"location":"python/variables/#ozgaruvchilarni-nomlash","text":"","title":"\u2705 O'ZGARUVCHILARNI NOMLASH"},{"location":"python/variables/#ozgaruvchilarga-nom-berishda-quyidagi-qoidalarga-amal-qiling","text":"","title":"\u2757 O'zgaruvchilarga nom berishda quyidagi qoidalarga amal qiling:"},{"location":"python/variables/#ozgaruvchi-nomi-harf-yoki-pastki-chiziq-_-bilan-boshlanishi-kerak","text":"\u2705 To\u2018g\u2018ri: # Harflardan tashkil topgan oddiy o'zgaruvchi nomi ism = \"Ali\" # Pastki chiziq (_) bilan boshlangan o'zgaruvchi nomi _yosh = 25 \u274c Noto\u2018g\u2018ri: # \u274c Son bilan boshlanmaydi 1ism = \"Ali\"","title":"\u274c O'zgaruvchi nomi harf yoki pastki chiziq (_) bilan boshlanishi kerak"},{"location":"python/variables/#ozgaruvchi-nomi-raqam-bilan-boshlanishi-mumkin-emas","text":"\ud83d\udccc Raqam faqat nomning oxirida yoki o\u2018rtasida ishlatilishi mumkin. \u2705 To\u2018g\u2018ri: # O'zgaruvchi nomi harf bilan boshlangan va raqam bilan tugagan \u2014 to'g'ri raqam1 = 10 # O'zgaruvchi nomi harf bilan boshlangan va oxirida raqam ishlatilgan \u2014 to'g'ri sana2025 = 2025 \u274c Noto\u2018g\u2018ri: # \u274c Raqam bilan boshlanmaydi 3dars = \"Python\"","title":"\u274c O'zgaruvchi nomi raqam bilan boshlanishi mumkin emas"},{"location":"python/variables/#ozgaruvchi-nomida-faqatgina-ingliz-tili-alifbosi-harflari-a-z-raqamlar-0-9-va-pastki-chiziq-_-qatnashishi-mumkin","text":"\ud83d\udccc Maxsus belgilar ( @ , ! , # , - va boshqalar) o\u2018zgaruvchi nomida ishlatilmaydi. \u2705 To\u2018g\u2018ri: # Lotin harflari va pastki chiziq ishlatilgan \u2014 to\u2018g\u2018ri user_name = \"Umid\" # Harf va raqam ishlatilgan \u2014 to\u2018g\u2018ri user1 = \"Ali\" # Pastki chiziq bilan boshlangan nom \u2014 bu ham to\u2018g\u2018ri _max_score = 100 \u274c Noto\u2018g\u2018ri: # O'zgaruvchi nomida '@' belgisi ishlatilgan \u2014 bu noto\u2018g\u2018ri # \u274c Maxsus belgilar (masalan: @) Python'da o'zgaruvchi nomida bo'lmasligi kerak ism@familiya = \"Valijon\" # O'zgaruvchi nomida '!' belgisi ishlatilgan \u2014 bu ham noto\u2018g\u2018ri # \u274c Maxsus belgilar (masalan: !) ruxsat etilmaydi yosh! = 18","title":"\u274c O'zgaruvchi nomida faqatgina ingliz tili alifbosi harflari (A-z), raqamlar (0-9) va pastki chiziq (_) qatnashishi mumkin"},{"location":"python/variables/#ozgaruvchi-nomida-boshliq-bolishi-mumkin-emas","text":"\u2705 To\u2018g\u2018ri: # O'zgaruvchi nomida pastki chiziq ishlatilgan \u2014 bu to\u2018g\u2018ri usul ism_familiya = \"Ali Karimov\" \u274c Noto\u2018g\u2018ri: # O'zgaruvchi nomida bo\u2018shliq (space) ishlatilgan \u2014 bu noto\u2018g\u2018ri # \u274c Python'da o'zgaruvchi nomi bo\u2018shliq bilan yozilmaydi ism familiya = \"Ali Karimov\"","title":"\u274c O'zgaruvchi nomida bo'shliq (\u043f\u0440\u043e\u0431\u0435\u043b) bo'lishi mumkin emas"},{"location":"python/variables/#ozgaruvchi-nomida-katta-kichik-harflar-turlicha-talqin-qilinadi-ism-ism-va-ism-uchta-turli-ozgaruvchi","text":"\ud83d\udccc Pythonda ism , ISM va Ism bu uchta alohida o\u2018zgaruvchi hisoblanadi. # kichik harflardan tashkil topgan o'zgaruvchi ism = \"Ali\" # hamma harflari katta bo'lgan o'zgaruvchi \u2014 bu boshqa o'zgaruvchi ISM = \"Vali\" # bosh harfi katta, qolgan kichik bo'lgan o'zgaruvchi \u2014 yana boshqa o'zgaruvchi Ism = \"Sami\" # 'ism' o'zgaruvchisining qiymatini chiqaramiz print(ism) # Ali # 'ISM' o'zgaruvchisining qiymatini chiqaramiz print(ISM) # Vali # 'Ism' o'zgaruvchisining qiymatini chiqaramiz print(Ism) # Sami","title":"\u274c O'zgaruvchi nomida katta-kichik harflar turlicha talqin qilinadi (ism, ISM, va Ism uchta turli o'zgaruvchi)"},{"location":"python/variables/#qoshimcha-qoidalar","text":"","title":"\u2705 QO'SHIMCHA QOIDALAR"},{"location":"python/variables/#ozgaruvchi-nomini-kichik-harflar-bilan-yozing","text":"\ud83d\udccc Python kodini o\u2018qishda va tushunishda qulaylik uchun o\u2018zgaruvchilarni kichik harflar bilan yozish odatiy hisoblanadi. # To'g'ri va tavsiya qilinadigan usul \u2014 o'zgaruvchi nomi kichik harflardan iborat ism = \"Umid\" # Tavsiya qilinmaydi \u2014 bosh harf bilan boshlash kodda chalkashlik keltirib chiqarishi mumkin Ism = \"Umid\" # Tavsiya qilinmaydi \u2014 hamma harflar katta bo\u2018lishi ko\u2018pincha konstantalar uchun ishlatiladi ISM = \"Umid\"","title":"\u2747\ufe0f O'zgaruvchi nomini kichik harflar bilan yozing."},{"location":"python/variables/#ozgaruvchi-nomida-2-va-undan-ortiq-soz-qatnashsa-ularning-orasini-pastki-chiziq-_-bilan-ajrating-ism_sharifumid-gaybullayev","text":"\ud83d\udccc Bu usul o\u2018zgaruvchi nomini o\u2018qishni osonlashtiradi va kodni yanada tushunarli qiladi. # Ikkita so\u2018zdan tashkil topgan o'zgaruvchi nomi, so\u2018zlar pastki chiziq bilan ajratilgan ism_sharif = \"Umid G'aybullayev\" # Ikkita so\u2018zdan tashkil topgan o'zgaruvchi nomi, so\u2018zlar pastki chiziq yordamida bog\u2018langan tugilgan_yil = 2004","title":"\u2747\ufe0f O'zgaruvchi nomida 2 va undan ortiq so'z qatnashsa ularning orasini pastki chiziq (_) bilan ajrating (ism_sharif=\"Umid G'aybullayev\")"},{"location":"python/variables/#ozgaruvchiga-tushunarli-nom-bering-y20-emas-yosh20-dkorea-emas-davlat-korea-va-hokazo","text":"\ud83d\udccc O\u2018zgaruvchi nomi uning ma\u2019nosini ifodalashi kerak, shunda kodni o\u2018qish va tushunish osonlashadi. # Yomon misollar \u2014 nomlar qisqa va ma\u2019nosiz, kodni tushunishni qiyinlashtiradi y = 20 d = \"Korea\" # Yaxshi misollar \u2014 nomlar ma\u2019noli va tushunarli yosh = 20 davlat = \"Korea\"","title":"\u2747\ufe0f O'zgaruvchiga tushunarli nom bering (y=20 emas yosh=20, d=\"Korea\" emas davlat = \"Korea\" va hokazo)"},{"location":"python/variables/#shuningdek-ozgaruvchilarga-pythonda-ishlatiladigan-funksiyalar-va-maxsus-kalit-sozlarningkeywords-nomini-bermang-kalit-sozlar-royhatini-korish-uchun-python-faylga-uyidagi-kodni-yozamiz","text":"\ud83d\udccc Chunki bu nomlar Python tili tomonidan maxsus ma\u2019noga ega va ular bilan nomlash kodni buzadi yoki xato beradi. # Python kalit so'zlarini ko'rish uchun quyidagilarni yozamiz import keyword # Python kalit so'zlar ro'yxatini chiqaramiz print(keyword.kwlist) \u2705 To\u2018g\u2018ri: # To\u2018g\u2018ri misollar \u2014 kalit so'zlarni o'zgaruvchi nomining bir qismi sifatida ishlatish mumkin def_funksiya = 10 for_son = 20 \u274c Noto\u2018g\u2018ri: # Noto\u2018g\u2018ri misollar \u2014 kalit so\u2018zlarni o\u2018zgaruvchi nomi sifatida ishlatish mumkin emas def = 10 # \u274c 'def' kalit so'z, o'zgaruvchi sifatida ishlatilmaydi for = 20 # \u274c 'for' kalit so'z, o'zgaruvchi sifatida ishlatilmaydi","title":"\u2747\ufe0f Shuningdek o'zgaruvchilarga Pythonda ishlatiladigan funksiyalar va maxsus kalit so'zlarning(keywords) nomini bermang. Kalit so'zlar ro'yhatini ko'rish uchun python faylga uyidagi kodni yozamiz:"},{"location":"python/variables/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/variables/#1-topshiriq","text":"Quyidagi qiymatlarni o\u2018zgaruvchilarga yuklang va print() orqali ekranga chiqaring: - ismingiz - yoshingiz - sevimli soningiz - talaba ekanligingiz (True yoki False)","title":"\u2705 1-topshiriq:"},{"location":"python/variables/#2-topshiriq","text":"Quyidagi ma\u2019lumotlar uchun mos o\u2018zgaruvchilar yarating: kitob_nomi \u2192 \u201cSariq devni minib\u201d muallif \u2192 \u201cXudoyberdi To\u2018xtaboyev\u201d sahifalar_soni \u2192 185 Ularni print() yordamida chiqarib bering.","title":"\u2705 2-topshiriq:"},{"location":"python/variables/#3-topshiriq","text":"Quyidagi noto\u2018g\u2018ri o\u2018zgaruvchi nomlarini to\u2018g\u2018rilang: 1kitob = \"Python\" ism familiya = \"Ali Karimov\" davlat@ = \"Uzbekistan\"","title":"\u2705 3-topshiriq:"},{"location":"python/variables/#4-topshiriq","text":"Quyidagi qiymatlarni saqlovchi o\u2018zgaruvchilarni yarating va print() bilan ularning turini (type()) chiqaring: yosh = 25 baho = 4.5 ism = \"Dilshod\" is_student = False","title":"\u2705 4-topshiriq:"},{"location":"python/variables/#5-topshiriq","text":"Quyidagi kodni yozing: name o\u2018zgaruvchisi yarating va unga ism kiriting. Keyin, uning qiymatini boshqa ism bilan almashtiring. Har ikkala holatda qiymatni ekranga chiqaring.","title":"\u2705 5-topshiriq:"},{"location":"python/variables/#6-topshiriq","text":"Quyidagi noto\u2018g\u2018ri o\u2018zgaruvchilarni aniqlang va nega xato ekanligini yozing: for = \"dars\" def = \"funksiya\" yosh! = 20","title":"\u2705 6-topshiriq:"},{"location":"python/variables/#7-topshiriq","text":"Quyidagi ikkita o\u2018zgaruvchini yarating: ism = \"Jamshid\" ISM = \"Anvar\" Ularning ikkalasini print() bilan chiqaring va nima sababdan ikkala qiymat chiqayotganini tushuntiring.","title":"\u2705 7-topshiriq:"},{"location":"python/variables/#8-topshiriq","text":"O\u2018zgaruvchi nomlarida pastki chiziq (_) ishlatish kerak bo\u2018lgan 3 ta misol yozing. Masalan: foydalanuvchi_ismi, kitob_soni, manzil_nomi","title":"\u2705 8-topshiriq:"},{"location":"python/variables/#9-topshiriq","text":"Tushunarli va tushunarsiz o\u2018zgaruvchi nomlariga 3 tadan misol yozing: Yaxshi: yosh, davlat, kitob_nomi Yomon: x, d, n1","title":"\u2705 9-topshiriq:"},{"location":"python/variables/#10-topshiriq","text":"Quyidagi kodni to\u2018g\u2018ri ko\u2018rinishga keltiring: 3son = 25 user name = \"Ali\" yosh@ = 20","title":"\u2705 10-topshiriq:"},{"location":"python/variables/#11-topshiriq","text":"Quyidagi o\u2018zgaruvchilarni yarating va print() yordamida ularni chiqarib bering: kitob_nomi = \"Yulduzli tunlar\" muallif = \"Pirimqul Qodirov\" narx = 37000 mavjud = True","title":"\u2705 11-topshiriq:"},{"location":"python/variables/#12-topshiriq","text":"Kalit so\u2018zlar ro\u2018yxatini ko\u2018rsatadigan kod yozing va uni bajaring. Kod natijasida ekranda Python kalit so\u2018zlari chiqishi kerak.","title":"\u2705 12-topshiriq:"},{"location":"python/variables/#13-topshiriq","text":"Quyidagi kodni tahlil qiling. Nima sababdan xatolik borligini tushuntiring: import = \"data\" True = 1","title":"\u2705 13-topshiriq:"},{"location":"python/variables/#14-topshiriq","text":"O\u2018zgaruvchilarni quyidagi ma\u2019nolarga qarab yarating: Foydalanuvchining ismi Parol Email manzili Tug\u2018ilgan yili","title":"\u2705 14-topshiriq:"},{"location":"python/variables/#15-topshiriq","text":"Quyidagi qiymatlar uchun mos o\u2018zgaruvchilar yarating va ularni print() yordamida chiqarib, bir satrda type() funksiyasi bilan ularning turlarini ham ko\u2018rsating: ism = \"Sardor\" yosh = 22 talaba = True ball = 4.9","title":"\u2705 15-topshiriq:"},{"location":"python/what-is-python/","text":"\ud83e\udde9 WHAT IS PYTHON? \ud83d\udccc Python \u2014 bu yuqori darajadagi, umumiy maqsadli, interpreted dasturlash tili. U soddaligi, oson sintaksisi, o\u2018qilishi qulayligi bilan mashhur. \ud83d\udccc High-Level Programming Language : bu inson o\u2018qishi va tushunishi oson bo\u2018lgan dasturlash tili degani. Kompyuterlar past darajadagi tillarda ishlaydi (masalan: Assembly, Machine Code), ammo bu tillar inson uchun tushunish qiyin. \u2733\ufe0f Python esa odam tiliga yaqin bo\u2018lib yoziladi: print(\"Salom, dunyo!\") # Ekranga matn chiqarish \ud83d\udccc Bu buyruqni har kim tushunadi. Ammo past darajadagi tillarda xuddi shu ishni qilish juda murakkab bo\u2018ladi. \ud83d\udccc Yuqori darajadagi tillarning afzalliklari: Sintaksisi oddiy va oson O\u2018rganish va tushunish qulay Ko\u2018p platformalarda ishlaydi Kam kod bilan ko\u2018p ishni bajaradi \ud83d\udccc General-Purpose Programming Language : bu har xil dasturlarni yaratish uchun ishlatiladigan dasturlash tili. \u2733\ufe0f Python yordamida quyidagilarni qilish mumkin: \ud83c\udf10 Web dasturlar (Django, Flask) \ud83e\udd16 Sun'iy intellekt (AI, ML) \ud83d\udcca Ma\u2019lumotlar tahlili (Pandas, NumPy) \ud83d\udda5\ufe0f Desktop ilovalar \ud83d\udcf1 Mobil ilovalar (Kivy, BeeWare) \ud83c\udfae O\u2018yinlar (Pygame) \ud83e\uddea Ilmiy hisob-kitoblar \ud83d\udee0\ufe0f Avtomatlashtirish va skriptlar Tushuncha Ma'nosi Yuqori darajadagi Inson o\u2018qishi oson, sodda sintaksisga ega dasturlash tili Umumiy maqsadli Turli sohalarda foydalanish mumkin bo\u2018lgan dasturlash tili \u2705 PYTHON TARIXI \u2733\ufe0f Python asoschisi: Guido van Rossum Guido van Rossum \u2014 Gollandiyalik dasturchi. 1980-yillarda CWI (Centrum Wiskunde & Informatica) \u2013 Gollandiyadagi ilmiy markazda ishlagan. U tilni soddaroq, tushunarli va o\u2018qilishi oson bo\u2018lishini istagan. Tilga \u201cPython\u201d deb nom berilishiga sabab esa u juda yoqtirgan \u201cMonty Python\u2019s Flying Circus\u201d nomli komedik TV dasturi edi. \u2705 PYTHON TARIXIY BOSQICHLARI \u2747\ufe0f PYTHON LOYIHASI BOSHLANISHI - 1989-YIL DEKABR \ud83d\udccc Guido dam olish vaqtida yangi til yozishga kirishadi. \ud83d\udccc Maqsadi: ABC dasturlash tilining (CWI tomonidan yaratilgan) soddaligi va foydaliligini yaxshilash. \ud83d\udccc Unga fayl va istalgan tizimga bog\u2018lanish (file handling & OS interfacing) imkoniyatlari qo\u2018shmoqchi bo\u2018ladi. \u2747\ufe0f PYTHON 1.0 - 1991-YIL 20-FEVRAL \u2733\ufe0f Python ilk rasmiy versiyasi: - Funksiya, shart operatorlari ( if , else , elif ) - while , for , break , continue operatorlari - Ma'lumot turlari: str , list , dict , tuple - exception handling (try-except) mavjud edi \u2747\ufe0f PYTHON 2.0 - 2000-YIL 16-DEKABR \u2733\ufe0f Muhim yangiliklar: list comprehensions (ro\u2018yxatlar uchun qisqa yozuv) garbage collection (avtomatik xotira tozalash) Unicode qo\u2018llab-quvvatlash \u2747\ufe0f PYTHON 3.0 - 2008-YIL 3-DEKABR \ud83d\udccc Bu versiya to\u2018liq yangilangan, orqaga mos kelmaydigan versiya edi. \u2733\ufe0f Asosiy o\u2018zgarishlar: print endi funksiya bo\u2018ldi: print(\"Hello\") integer division endi aniq natija beradi: 5/2 = 2.5 Unicode to\u2018liq qo\u2018llab-quvvatlandi Yangi sintaksislar: with , f-string , type hints kiritildi \u2705 PYTHON VERSIYALARI JADVALI Versiya Chiqqan sana Asosiy yangiliklar Python 1.0 1991-yil Birinchi rasmiy nashr Python 2.0 2000-yil Unicode, GC, List comprehensions Python 3.0 2008-yil Unicode, yangi sintaksis Python 3.5 2015-yil async/await , type hinting Python 3.6 2016-yil f-strings Python 3.9 2020-yil Yangi to\u2018plamlar funksiyalari Python 3.10 2021-yil match-case pattern matching Python 3.11 2022-yil Katta tezlik (50% gacha yaxshilangan) Python 3.12 2023-yil Yaxshilangan profiling, diagnostics Python 3.13 2024-yil (beta) Tezlik va sintaktik yaxshilanishlar \u2705 PYTHONNING ASOSIY XUSUSIYATLARI \ud83d\udccc Oson yoziladi va tushuniladi - Python sintaksisi oddiy va inson tiliga o\u2018xshash. Shu sababli uni yangi o\u2018rganayotganlar tez tushunadi va kod yozishni oson o\u2018rganadi. \ud83d\udccc Qatorma-qator bajariladi - Python \u2014 interpreted til. Kodlar yuqoridan pastga qarab birma-bir bajariladi. Har bir qatordagi buyruq navbati bilan bajariladi. \ud83d\udccc Turli operatsion tizimlarda ishlaydi - Python dasturlari Windows, MacOS va Linux tizimlarida bir xil ishlaydi. Hech qanday alohida sozlashlarsiz ko\u2018p platformalarda foydalanish mumkin. \ud83d\udccc Ko\u2018plab tayyor kutubxonalar mavjud - Python juda katta kutubxonalar to\u2018plamiga ega. Ular yordamida murakkab matematik, grafik, internet, ma\u2019lumotlar bilan bog\u2018liq ishlar tez va oson bajariladi. \ud83d\udccc Obyektga yo\u2018naltirilgan dasturlash tili - Python yirik va murakkab dasturlarni modullarga bo\u2018lib yozishga imkon beradi. Bu dasturlarni boshqarishni va ularni rivojlantirishni osonlashtiradi. \ud83d\udccc Boshqa dasturlash tillari bilan birga ishlay oladi - Python boshqa tillar \u2014 masalan, C, C++, Java yoki HTML bilan integratsiya qilib ishlatilishi mumkin. Bu uni yanada kuchli va moslashuvchan qiladi. \u2705 PYTHON QANDAY ISHLAYDI Code Writing : Dastlab Python kodini .py fayl ko'rinishida yozasiz. Interpreter Runs : Python interpretatori ushbu kodni o\u2019qib, uni mashina tushunadigan baytlarga o\u2018zgartiradi. Bu jarayonda kod qatorma-qator tahlil qilinadi va ishlatiladi. Conversion to Bytecode : Kod bytecode ga o\u2018zgartiriladi, bu esa Python PVM da ishlaydi. bytecode \u2014 bu kompyuterga tushunarli bo\u2019lgan oraliq kod, lekin u hali ham yuqori darajali tildir. Python Virtual Machine (PVM) : bytecode PVM orqali ishlaydi, va bu virtual mashina dastur kodini to\u2018liq bajaradi. Bu jarayon kompyuteringiz operatsion tizimi orqali amalga oshiriladi. Output Generated : Kod bajarilishi bilan natijalar ekranga chiqariladi yoki kerakli hisob-kitoblar amalga oshiriladi. Pythonning qo\u2018llanish sohalari: Web Development: Django , Flask kabi freymvorklar orqali veb-saytlar va veb-ilovalar yaratish. Data Analysis and Scientific Computing: NumPy , pandas , SciPy , matplotlib kabi kutubxonalar yordamida. AI(Artificial Intelligence) and Machine Learning: TensorFlow , Keras , PyTorch kabi kutubxonalar yordamida. Automation and Scripting: Turli xil vazifalarni avtomatlashtirish uchun. Game Development: Pygame kabi kutubxonalar yordamida. Python Muhiti va O\u2018rnatish: [!NOTE] Python dasturlash tilida dasturlashni boshlash uchun sizga Python interpretatorini kompyuteringizga o\u2018rnatish kerak bo\u2018ladi. Pythonning rasmiy veb-saytida Pythonning oxirgi versiyasini yuklab olish mumkin. Shuningdek, muhitni boshqarish va kod yozish uchun turli vositalar va muharrirlar mavjud. Python O\u2018rnatilishi: Windows 1. Pythonni yuklab olish: - Pythonni rasmiy web-saytiga kiring. - Downloads bo\u2018limiga o\u2018ting va Windows uchun oxirgi barqaror versiyasini yuklab oling. ![alt text](images/image.png) Pythonni o\u2018rnatish: Yuklab olingan .exe faylini ishga tushiring. Add Python to PATH katagiga belgi qo\u2018ying. Bu belgi Python'ni kompyuteringizdagi barcha joylarda ishlatishga imkon beradi. Install Now tugmasini bosing va o\u2018rnatishni yakunlang. Indikator to'lishini kutamiz. Setup was successfull muvaffaqiyatli o'rnatildi. O\u2018rnatishni tekshirish: Command Prompt yoki PowerShell ni oching. python --version yoki python -V buyrug\u2018ini kiriting. Bu sizga o\u2018rnatilgan Python versiyasini ko\u2018rsatadi. Hello, World! dasturini yozish. print(\"Hello World!\") AMALIYOT Python interpreterini o'rnatish. Hello, World! dasturini yozish va ishga tushirish. print() funksiyasi yordamida turli xabarlarni chiqarish.","title":"What is Python"},{"location":"python/what-is-python/#what-is-python","text":"\ud83d\udccc Python \u2014 bu yuqori darajadagi, umumiy maqsadli, interpreted dasturlash tili. U soddaligi, oson sintaksisi, o\u2018qilishi qulayligi bilan mashhur. \ud83d\udccc High-Level Programming Language : bu inson o\u2018qishi va tushunishi oson bo\u2018lgan dasturlash tili degani. Kompyuterlar past darajadagi tillarda ishlaydi (masalan: Assembly, Machine Code), ammo bu tillar inson uchun tushunish qiyin. \u2733\ufe0f Python esa odam tiliga yaqin bo\u2018lib yoziladi: print(\"Salom, dunyo!\") # Ekranga matn chiqarish \ud83d\udccc Bu buyruqni har kim tushunadi. Ammo past darajadagi tillarda xuddi shu ishni qilish juda murakkab bo\u2018ladi. \ud83d\udccc Yuqori darajadagi tillarning afzalliklari: Sintaksisi oddiy va oson O\u2018rganish va tushunish qulay Ko\u2018p platformalarda ishlaydi Kam kod bilan ko\u2018p ishni bajaradi \ud83d\udccc General-Purpose Programming Language : bu har xil dasturlarni yaratish uchun ishlatiladigan dasturlash tili. \u2733\ufe0f Python yordamida quyidagilarni qilish mumkin: \ud83c\udf10 Web dasturlar (Django, Flask) \ud83e\udd16 Sun'iy intellekt (AI, ML) \ud83d\udcca Ma\u2019lumotlar tahlili (Pandas, NumPy) \ud83d\udda5\ufe0f Desktop ilovalar \ud83d\udcf1 Mobil ilovalar (Kivy, BeeWare) \ud83c\udfae O\u2018yinlar (Pygame) \ud83e\uddea Ilmiy hisob-kitoblar \ud83d\udee0\ufe0f Avtomatlashtirish va skriptlar Tushuncha Ma'nosi Yuqori darajadagi Inson o\u2018qishi oson, sodda sintaksisga ega dasturlash tili Umumiy maqsadli Turli sohalarda foydalanish mumkin bo\u2018lgan dasturlash tili","title":"\ud83e\udde9 WHAT IS PYTHON?"},{"location":"python/what-is-python/#python-tarixi","text":"\u2733\ufe0f Python asoschisi: Guido van Rossum Guido van Rossum \u2014 Gollandiyalik dasturchi. 1980-yillarda CWI (Centrum Wiskunde & Informatica) \u2013 Gollandiyadagi ilmiy markazda ishlagan. U tilni soddaroq, tushunarli va o\u2018qilishi oson bo\u2018lishini istagan. Tilga \u201cPython\u201d deb nom berilishiga sabab esa u juda yoqtirgan \u201cMonty Python\u2019s Flying Circus\u201d nomli komedik TV dasturi edi.","title":"\u2705 PYTHON TARIXI"},{"location":"python/what-is-python/#python-tarixiy-bosqichlari","text":"","title":"\u2705 PYTHON TARIXIY BOSQICHLARI"},{"location":"python/what-is-python/#python-loyihasi-boshlanishi-1989-yil-dekabr","text":"\ud83d\udccc Guido dam olish vaqtida yangi til yozishga kirishadi. \ud83d\udccc Maqsadi: ABC dasturlash tilining (CWI tomonidan yaratilgan) soddaligi va foydaliligini yaxshilash. \ud83d\udccc Unga fayl va istalgan tizimga bog\u2018lanish (file handling & OS interfacing) imkoniyatlari qo\u2018shmoqchi bo\u2018ladi.","title":"\u2747\ufe0f PYTHON LOYIHASI BOSHLANISHI - 1989-YIL DEKABR"},{"location":"python/what-is-python/#python-10-1991-yil-20-fevral","text":"\u2733\ufe0f Python ilk rasmiy versiyasi: - Funksiya, shart operatorlari ( if , else , elif ) - while , for , break , continue operatorlari - Ma'lumot turlari: str , list , dict , tuple - exception handling (try-except) mavjud edi","title":"\u2747\ufe0f PYTHON 1.0 - 1991-YIL 20-FEVRAL"},{"location":"python/what-is-python/#python-20-2000-yil-16-dekabr","text":"\u2733\ufe0f Muhim yangiliklar: list comprehensions (ro\u2018yxatlar uchun qisqa yozuv) garbage collection (avtomatik xotira tozalash) Unicode qo\u2018llab-quvvatlash","title":"\u2747\ufe0f PYTHON 2.0 - 2000-YIL 16-DEKABR"},{"location":"python/what-is-python/#python-30-2008-yil-3-dekabr","text":"\ud83d\udccc Bu versiya to\u2018liq yangilangan, orqaga mos kelmaydigan versiya edi. \u2733\ufe0f Asosiy o\u2018zgarishlar: print endi funksiya bo\u2018ldi: print(\"Hello\") integer division endi aniq natija beradi: 5/2 = 2.5 Unicode to\u2018liq qo\u2018llab-quvvatlandi Yangi sintaksislar: with , f-string , type hints kiritildi","title":"\u2747\ufe0f PYTHON 3.0 - 2008-YIL 3-DEKABR"},{"location":"python/what-is-python/#python-versiyalari-jadvali","text":"Versiya Chiqqan sana Asosiy yangiliklar Python 1.0 1991-yil Birinchi rasmiy nashr Python 2.0 2000-yil Unicode, GC, List comprehensions Python 3.0 2008-yil Unicode, yangi sintaksis Python 3.5 2015-yil async/await , type hinting Python 3.6 2016-yil f-strings Python 3.9 2020-yil Yangi to\u2018plamlar funksiyalari Python 3.10 2021-yil match-case pattern matching Python 3.11 2022-yil Katta tezlik (50% gacha yaxshilangan) Python 3.12 2023-yil Yaxshilangan profiling, diagnostics Python 3.13 2024-yil (beta) Tezlik va sintaktik yaxshilanishlar","title":"\u2705 PYTHON VERSIYALARI JADVALI"},{"location":"python/what-is-python/#pythonning-asosiy-xususiyatlari","text":"\ud83d\udccc Oson yoziladi va tushuniladi - Python sintaksisi oddiy va inson tiliga o\u2018xshash. Shu sababli uni yangi o\u2018rganayotganlar tez tushunadi va kod yozishni oson o\u2018rganadi. \ud83d\udccc Qatorma-qator bajariladi - Python \u2014 interpreted til. Kodlar yuqoridan pastga qarab birma-bir bajariladi. Har bir qatordagi buyruq navbati bilan bajariladi. \ud83d\udccc Turli operatsion tizimlarda ishlaydi - Python dasturlari Windows, MacOS va Linux tizimlarida bir xil ishlaydi. Hech qanday alohida sozlashlarsiz ko\u2018p platformalarda foydalanish mumkin. \ud83d\udccc Ko\u2018plab tayyor kutubxonalar mavjud - Python juda katta kutubxonalar to\u2018plamiga ega. Ular yordamida murakkab matematik, grafik, internet, ma\u2019lumotlar bilan bog\u2018liq ishlar tez va oson bajariladi. \ud83d\udccc Obyektga yo\u2018naltirilgan dasturlash tili - Python yirik va murakkab dasturlarni modullarga bo\u2018lib yozishga imkon beradi. Bu dasturlarni boshqarishni va ularni rivojlantirishni osonlashtiradi. \ud83d\udccc Boshqa dasturlash tillari bilan birga ishlay oladi - Python boshqa tillar \u2014 masalan, C, C++, Java yoki HTML bilan integratsiya qilib ishlatilishi mumkin. Bu uni yanada kuchli va moslashuvchan qiladi.","title":"\u2705 PYTHONNING ASOSIY XUSUSIYATLARI"},{"location":"python/what-is-python/#python-qanday-ishlaydi","text":"Code Writing : Dastlab Python kodini .py fayl ko'rinishida yozasiz. Interpreter Runs : Python interpretatori ushbu kodni o\u2019qib, uni mashina tushunadigan baytlarga o\u2018zgartiradi. Bu jarayonda kod qatorma-qator tahlil qilinadi va ishlatiladi. Conversion to Bytecode : Kod bytecode ga o\u2018zgartiriladi, bu esa Python PVM da ishlaydi. bytecode \u2014 bu kompyuterga tushunarli bo\u2019lgan oraliq kod, lekin u hali ham yuqori darajali tildir. Python Virtual Machine (PVM) : bytecode PVM orqali ishlaydi, va bu virtual mashina dastur kodini to\u2018liq bajaradi. Bu jarayon kompyuteringiz operatsion tizimi orqali amalga oshiriladi. Output Generated : Kod bajarilishi bilan natijalar ekranga chiqariladi yoki kerakli hisob-kitoblar amalga oshiriladi.","title":"\u2705 PYTHON QANDAY ISHLAYDI"},{"location":"python/what-is-python/#pythonning-qollanish-sohalari","text":"Web Development: Django , Flask kabi freymvorklar orqali veb-saytlar va veb-ilovalar yaratish. Data Analysis and Scientific Computing: NumPy , pandas , SciPy , matplotlib kabi kutubxonalar yordamida. AI(Artificial Intelligence) and Machine Learning: TensorFlow , Keras , PyTorch kabi kutubxonalar yordamida. Automation and Scripting: Turli xil vazifalarni avtomatlashtirish uchun. Game Development: Pygame kabi kutubxonalar yordamida.","title":"Pythonning qo\u2018llanish sohalari:"},{"location":"python/what-is-python/#python-muhiti-va-ornatish","text":"[!NOTE] Python dasturlash tilida dasturlashni boshlash uchun sizga Python interpretatorini kompyuteringizga o\u2018rnatish kerak bo\u2018ladi. Pythonning rasmiy veb-saytida Pythonning oxirgi versiyasini yuklab olish mumkin. Shuningdek, muhitni boshqarish va kod yozish uchun turli vositalar va muharrirlar mavjud.","title":"Python Muhiti va O\u2018rnatish:"},{"location":"python/what-is-python/#python-ornatilishi","text":"Windows 1. Pythonni yuklab olish: - Pythonni rasmiy web-saytiga kiring. - Downloads bo\u2018limiga o\u2018ting va Windows uchun oxirgi barqaror versiyasini yuklab oling. ![alt text](images/image.png) Pythonni o\u2018rnatish: Yuklab olingan .exe faylini ishga tushiring. Add Python to PATH katagiga belgi qo\u2018ying. Bu belgi Python'ni kompyuteringizdagi barcha joylarda ishlatishga imkon beradi. Install Now tugmasini bosing va o\u2018rnatishni yakunlang. Indikator to'lishini kutamiz. Setup was successfull muvaffaqiyatli o'rnatildi. O\u2018rnatishni tekshirish: Command Prompt yoki PowerShell ni oching. python --version yoki python -V buyrug\u2018ini kiriting. Bu sizga o\u2018rnatilgan Python versiyasini ko\u2018rsatadi.","title":"Python O\u2018rnatilishi:"},{"location":"python/what-is-python/#hello-world-dasturini-yozish","text":"print(\"Hello World!\")","title":"Hello, World! dasturini yozish."},{"location":"python/what-is-python/#amaliyot","text":"Python interpreterini o'rnatish. Hello, World! dasturini yozish va ishga tushirish. print() funksiyasi yordamida turli xabarlarni chiqarish.","title":"AMALIYOT"},{"location":"python/while-loop/","text":"\ud83e\udde9 10-DARS WHILE LOOP \ud83d\udccc while \u2014 bu tsikl operatori, ya\u2019ni biror shart True bo\u2018lganida kodni qayta-qayta bajaradi. Agar shart False bo\u2018lsa, while tsikli to\u2018xtaydi va keyingi kodga o\u2018tadi. # son degan o'zgaruvchiga 1 qiymatini beramiz son = 1 # while tsikli: son 5 dan kichik yoki teng bo\u2018lguncha davom etadi while son <= 5: # hozirgi son qiymatini ekranga chiqaramiz print(son) # son qiymatini 1 ga oshiramiz, shunda tsikl keyingi son bilan davom etadi son += 1 \ud83c\udfaf Foydalanuvchidan ma'lumot olish (stop deb yozmaguncha) # Foydalanuvchi kiritgan matnni saqlash uchun bo\u2018sh o\u2018zgaruvchi yaratamiz user_input = \"\" # while tsikli: foydalanuvchi 'stop' deb yozmaguncha davom etadi while user_input.lower() != \"stop\": # Foydalanuvchidan matn kiritishni so\u2018raymiz user_input = input(\"So'z kiriting (to\u2018xtatish uchun 'stop'): \") # Foydalanuvchi kiritgan so\u2018zni ekranga chiqaramiz print(f\"Siz '{user_input}' kiritdingiz\") \ud83c\udfaf Foydalanuvchi parolni to\u2018g\u2018ri kiritmaguncha bajariladi. # Foydalanuvchi kiritgan matnni saqlash uchun bo\u2018sh o\u2018zgaruvchi yaratamiz user_input = \"\" # while tsikli: foydalanuvchi 'stop' deb yozmaguncha davom etadi while user_input.lower() != \"stop\": # Foydalanuvchidan matn kiritishni so\u2018raymiz user_input = input(\"So'z kiriting (to\u2018xtatish uchun 'stop'): \") # Foydalanuvchi kiritgan so\u2018zni ekranga chiqaramiz print(f\"Siz '{user_input}' kiritdingiz\") \ud83c\udfaf Ro\u2018yxatda kerakli qiymatni topish (break bilan) # Mahsulotlar ro'yxatini yaratamiz products = [\"apple\", \"banana\", \"lemon\", \"melon\", \"grapes\"] # Indeksni 0 dan boshlaymiz i = 0 # Tsikl: indeks ro'yxat uzunligidan kichik bo\u2018lsa davom etadi while i < len(products): # Agar hozirgi element 'lemon' bo\u2018lsa if products[i] == \"lemon\": # 'lemon' topilganini ekranga chiqaramiz print(\"\u2705 'lemon' mahsuloti topildi!\") # Tsiklni to\u2018xtatamiz break # Indeksni 1 ga oshiramiz, keyingi elementga o\u2018tamiz i += 1 \ud83c\udfaf Manfiy va nol sonlarni tashlab ketish (continue bilan) # Sonlar ro'yxatini yaratamiz numbers = [-3, -1, 0, 2, 4, 6] # Indeksni 0 dan boshlaymiz i = 0 # Tsikl: indeks ro'yxat uzunligidan kichik bo\u2018lsa davom etadi while i < len(numbers): # Agar hozirgi son 0 yoki manfiy bo\u2018lsa if numbers[i] <= 0: # Indeksni 1 ga oshiramiz, keyingi songa o\u2018tamiz i += 1 # Ushbu davrani tashlab, tsikl boshiga qaytamiz continue # Agar son musbat bo\u2018lsa, uni ekranga chiqaramiz print(numbers[i]) # Indeksni 1 ga oshirib, keyingi elementga o\u2018tamiz i += 1 \ud83c\udfaf Foydalanuvchi login tizimi correct_username = \"admin\" # To\u2018g\u2018ri login correct_password = \"12345\" # To\u2018g\u2018ri parol login_attempts = 0 # Urinishlar soni while login_attempts < 3: # Faqat 3 marta urinib ko\u2018rish huquqi username = input(\"Login kiriting: \") # Login so\u2018rashi password = input(\"Parol kiriting: \") # Parol so\u2018rashi if username == correct_username and password == correct_password: print(\"\u2705 Xush kelibsiz, tizimga kirildi!\") break # To\u2018g\u2018ri kirilgan bo\u2018lsa, tsikl tugaydi else: print(\"\u274c Login yoki parol noto\u2018g\u2018ri.\") login_attempts += 1 # Urinishlar sonini oshirish if login_attempts == 3: # 3 marta noto\u2018g\u2018ri kirilgan bo\u2018lsa print(\"\ud83d\udeab Urinishlar tugadi, kirish bloklandi.\") \ud83c\udfaf Infinite Loop (Cheksiz tsikl) va undan himoyalanish \ud83d\udccc Har doim shart o\u2018zgaruvchisini yangilashni unutmang # num o'zgaruvchiga 1 qiymati beriladi num = 1 # Tsikl: num 5 dan kichik bo\u2018lsa davom etadi while num < 5: # num qiymatini chiqaradi print(num) # \u274c Indeks oshirilmayapti, shuning uchun num har doim 1 bo\u2018lib qoladi # num += 1 YO\u2018Q! => bu yerda indeksni oshirish yo\u2018q, shuning uchun bu tsikl hech qachon tugamaydi \u2705 AMALIYOT \u2705 1-topshiriq: Foydalanuvchi kiritgan natural son uchun 1 dan shu songacha bo\u2018lgan sonlar yig\u2018indisini while loop orqali hisoblang. \u2705 2-topshiriq: Quyidagi ro\u2018yxatda nechta elementda eng kamida 2 ta unli harf borligini aniqlang (while loopdan foydalaning): words = [\"apple\", \"sky\", \"queue\", \"book\", \"cry\"] \u2705 3-topshiriq: Ro\u2018yxatda eng katta va eng kichik sonning farqini while loop yordamida toping: numbers = [7, 12, -3, 8, 0, 15] \u2705 4-topshiriq: Foydalanuvchi 10 ta son kiritadi. While loop orqali faqat musbat va toq sonlarni yangi ro\u2018yxatga yozing. \u2705 5-topshiriq: Quyidagi ro\u2018yxatdagi har bir so\u2018zning birinchi va oxirgi harfini birlashtirib yangi ro\u2018yxat hosil qiling (while loop bilan): words = [\"python\", \"apple\", \"code\", \"loop\"] # natija: [\"pn\", \"ae\", \"ce\", \"lp\"] \u2705 6-topshiriq: Ro\u2018yxatdan faqat 3 ga va 5 ga bo\u2018linadigan sonlarni ajratib, ularning o\u2018rtacha qiymatini while loopda hisoblang: nums = [5, 9, 15, 20, 22, 30, 35] \u2705 7-topshiriq: Foydalanuvchi matn kiritadi. While loop yordamida matndagi raqamlarni topib, ularni son sifatida yig\u2018indisini hisoblang. Masalan: \"salom12dunyo3\" => natija: 15 \u2705 8-topshiriq: Berilgan ro\u2018yxatdan elementlarning indekslari juft bo\u2018lganlarini while loop bilan alohida ro\u2018yxatga chiqarib bering: fruits = [\"olma\", \"banan\", \"gilos\", \"anor\", \"nok\", \"shaftoli\"] \u2705 9-topshiriq: Ro\u2018yxatda ketma-ket 2 marta uchraydigan elementlarni while loop yordamida aniqlang: items = [1, 2, 2, 3, 4, 4, 4, 5] # natija: 2, 4 \u2705 10-topshiriq: Foydalanuvchi kiritgan matndan while loop yordamida faqat bosh harflarni ajratib, bitta string qilib chiqaring. Masalan: \"Salom DunYo\" => \"SDY\" \u2705 11-topshiriq: Quyidagi ro\u2018yxatdan palindrom (teskari o\u2018qilganda ham bir xil) so\u2018zlarni while loop bilan ajratib chiqaring: words = [\"anna\", \"python\", \"level\", \"loop\", \"radar\"] \u2705 12-topshiriq: While loop yordamida 100 dan kichik Fibonacci sonlarini ro\u2018yxatga yig\u2018ing. \u2705 13-topshiriq: Ro\u2018yxatda nechta elementda harflar soni raqamlar sonidan ko\u2018p ekanini while loop yordamida hisoblang: elements = [\"abc123\", \"hello\", \"42\", \"py2025\", \"test\"] \u2705 14-topshiriq: Ro\u2018yxatdagi sonlardan har birining raqamlari yig\u2018indisini while loop bilan hisoblab, yangi ro\u2018yxatga joylang: nums = [12, 305, 47, 88] # natija: [3, 8, 11, 16] \u2705 15-topshiriq: Ro\u2018yxatdagi elementlardan faqat birinchi harfi har doim katta, qolganlari kichik bo\u2018lgan yangi ro\u2018yxatni while loop orqali yarating: names = [\"aNVAR\", \"mUROD\", \"dILSHOD\"] # natija: [\"Anvar\", \"Murod\", \"Dilshod\"]","title":"While Loop"},{"location":"python/while-loop/#10-dars-while-loop","text":"\ud83d\udccc while \u2014 bu tsikl operatori, ya\u2019ni biror shart True bo\u2018lganida kodni qayta-qayta bajaradi. Agar shart False bo\u2018lsa, while tsikli to\u2018xtaydi va keyingi kodga o\u2018tadi. # son degan o'zgaruvchiga 1 qiymatini beramiz son = 1 # while tsikli: son 5 dan kichik yoki teng bo\u2018lguncha davom etadi while son <= 5: # hozirgi son qiymatini ekranga chiqaramiz print(son) # son qiymatini 1 ga oshiramiz, shunda tsikl keyingi son bilan davom etadi son += 1 \ud83c\udfaf Foydalanuvchidan ma'lumot olish (stop deb yozmaguncha) # Foydalanuvchi kiritgan matnni saqlash uchun bo\u2018sh o\u2018zgaruvchi yaratamiz user_input = \"\" # while tsikli: foydalanuvchi 'stop' deb yozmaguncha davom etadi while user_input.lower() != \"stop\": # Foydalanuvchidan matn kiritishni so\u2018raymiz user_input = input(\"So'z kiriting (to\u2018xtatish uchun 'stop'): \") # Foydalanuvchi kiritgan so\u2018zni ekranga chiqaramiz print(f\"Siz '{user_input}' kiritdingiz\") \ud83c\udfaf Foydalanuvchi parolni to\u2018g\u2018ri kiritmaguncha bajariladi. # Foydalanuvchi kiritgan matnni saqlash uchun bo\u2018sh o\u2018zgaruvchi yaratamiz user_input = \"\" # while tsikli: foydalanuvchi 'stop' deb yozmaguncha davom etadi while user_input.lower() != \"stop\": # Foydalanuvchidan matn kiritishni so\u2018raymiz user_input = input(\"So'z kiriting (to\u2018xtatish uchun 'stop'): \") # Foydalanuvchi kiritgan so\u2018zni ekranga chiqaramiz print(f\"Siz '{user_input}' kiritdingiz\") \ud83c\udfaf Ro\u2018yxatda kerakli qiymatni topish (break bilan) # Mahsulotlar ro'yxatini yaratamiz products = [\"apple\", \"banana\", \"lemon\", \"melon\", \"grapes\"] # Indeksni 0 dan boshlaymiz i = 0 # Tsikl: indeks ro'yxat uzunligidan kichik bo\u2018lsa davom etadi while i < len(products): # Agar hozirgi element 'lemon' bo\u2018lsa if products[i] == \"lemon\": # 'lemon' topilganini ekranga chiqaramiz print(\"\u2705 'lemon' mahsuloti topildi!\") # Tsiklni to\u2018xtatamiz break # Indeksni 1 ga oshiramiz, keyingi elementga o\u2018tamiz i += 1 \ud83c\udfaf Manfiy va nol sonlarni tashlab ketish (continue bilan) # Sonlar ro'yxatini yaratamiz numbers = [-3, -1, 0, 2, 4, 6] # Indeksni 0 dan boshlaymiz i = 0 # Tsikl: indeks ro'yxat uzunligidan kichik bo\u2018lsa davom etadi while i < len(numbers): # Agar hozirgi son 0 yoki manfiy bo\u2018lsa if numbers[i] <= 0: # Indeksni 1 ga oshiramiz, keyingi songa o\u2018tamiz i += 1 # Ushbu davrani tashlab, tsikl boshiga qaytamiz continue # Agar son musbat bo\u2018lsa, uni ekranga chiqaramiz print(numbers[i]) # Indeksni 1 ga oshirib, keyingi elementga o\u2018tamiz i += 1 \ud83c\udfaf Foydalanuvchi login tizimi correct_username = \"admin\" # To\u2018g\u2018ri login correct_password = \"12345\" # To\u2018g\u2018ri parol login_attempts = 0 # Urinishlar soni while login_attempts < 3: # Faqat 3 marta urinib ko\u2018rish huquqi username = input(\"Login kiriting: \") # Login so\u2018rashi password = input(\"Parol kiriting: \") # Parol so\u2018rashi if username == correct_username and password == correct_password: print(\"\u2705 Xush kelibsiz, tizimga kirildi!\") break # To\u2018g\u2018ri kirilgan bo\u2018lsa, tsikl tugaydi else: print(\"\u274c Login yoki parol noto\u2018g\u2018ri.\") login_attempts += 1 # Urinishlar sonini oshirish if login_attempts == 3: # 3 marta noto\u2018g\u2018ri kirilgan bo\u2018lsa print(\"\ud83d\udeab Urinishlar tugadi, kirish bloklandi.\") \ud83c\udfaf Infinite Loop (Cheksiz tsikl) va undan himoyalanish \ud83d\udccc Har doim shart o\u2018zgaruvchisini yangilashni unutmang # num o'zgaruvchiga 1 qiymati beriladi num = 1 # Tsikl: num 5 dan kichik bo\u2018lsa davom etadi while num < 5: # num qiymatini chiqaradi print(num) # \u274c Indeks oshirilmayapti, shuning uchun num har doim 1 bo\u2018lib qoladi # num += 1 YO\u2018Q! => bu yerda indeksni oshirish yo\u2018q, shuning uchun bu tsikl hech qachon tugamaydi","title":"\ud83e\udde9 10-DARS WHILE LOOP"},{"location":"python/while-loop/#amaliyot","text":"","title":"\u2705 AMALIYOT"},{"location":"python/while-loop/#1-topshiriq","text":"Foydalanuvchi kiritgan natural son uchun 1 dan shu songacha bo\u2018lgan sonlar yig\u2018indisini while loop orqali hisoblang.","title":"\u2705 1-topshiriq:"},{"location":"python/while-loop/#2-topshiriq","text":"Quyidagi ro\u2018yxatda nechta elementda eng kamida 2 ta unli harf borligini aniqlang (while loopdan foydalaning): words = [\"apple\", \"sky\", \"queue\", \"book\", \"cry\"]","title":"\u2705 2-topshiriq:"},{"location":"python/while-loop/#3-topshiriq","text":"Ro\u2018yxatda eng katta va eng kichik sonning farqini while loop yordamida toping: numbers = [7, 12, -3, 8, 0, 15]","title":"\u2705 3-topshiriq:"},{"location":"python/while-loop/#4-topshiriq","text":"Foydalanuvchi 10 ta son kiritadi. While loop orqali faqat musbat va toq sonlarni yangi ro\u2018yxatga yozing.","title":"\u2705 4-topshiriq:"},{"location":"python/while-loop/#5-topshiriq","text":"Quyidagi ro\u2018yxatdagi har bir so\u2018zning birinchi va oxirgi harfini birlashtirib yangi ro\u2018yxat hosil qiling (while loop bilan): words = [\"python\", \"apple\", \"code\", \"loop\"] # natija: [\"pn\", \"ae\", \"ce\", \"lp\"]","title":"\u2705 5-topshiriq:"},{"location":"python/while-loop/#6-topshiriq","text":"Ro\u2018yxatdan faqat 3 ga va 5 ga bo\u2018linadigan sonlarni ajratib, ularning o\u2018rtacha qiymatini while loopda hisoblang: nums = [5, 9, 15, 20, 22, 30, 35]","title":"\u2705 6-topshiriq:"},{"location":"python/while-loop/#7-topshiriq","text":"Foydalanuvchi matn kiritadi. While loop yordamida matndagi raqamlarni topib, ularni son sifatida yig\u2018indisini hisoblang. Masalan: \"salom12dunyo3\" => natija: 15","title":"\u2705 7-topshiriq:"},{"location":"python/while-loop/#8-topshiriq","text":"Berilgan ro\u2018yxatdan elementlarning indekslari juft bo\u2018lganlarini while loop bilan alohida ro\u2018yxatga chiqarib bering: fruits = [\"olma\", \"banan\", \"gilos\", \"anor\", \"nok\", \"shaftoli\"]","title":"\u2705 8-topshiriq:"},{"location":"python/while-loop/#9-topshiriq","text":"Ro\u2018yxatda ketma-ket 2 marta uchraydigan elementlarni while loop yordamida aniqlang: items = [1, 2, 2, 3, 4, 4, 4, 5] # natija: 2, 4","title":"\u2705 9-topshiriq:"},{"location":"python/while-loop/#10-topshiriq","text":"Foydalanuvchi kiritgan matndan while loop yordamida faqat bosh harflarni ajratib, bitta string qilib chiqaring. Masalan: \"Salom DunYo\" => \"SDY\"","title":"\u2705 10-topshiriq:"},{"location":"python/while-loop/#11-topshiriq","text":"Quyidagi ro\u2018yxatdan palindrom (teskari o\u2018qilganda ham bir xil) so\u2018zlarni while loop bilan ajratib chiqaring: words = [\"anna\", \"python\", \"level\", \"loop\", \"radar\"]","title":"\u2705 11-topshiriq:"},{"location":"python/while-loop/#12-topshiriq","text":"While loop yordamida 100 dan kichik Fibonacci sonlarini ro\u2018yxatga yig\u2018ing.","title":"\u2705 12-topshiriq:"},{"location":"python/while-loop/#13-topshiriq","text":"Ro\u2018yxatda nechta elementda harflar soni raqamlar sonidan ko\u2018p ekanini while loop yordamida hisoblang: elements = [\"abc123\", \"hello\", \"42\", \"py2025\", \"test\"]","title":"\u2705 13-topshiriq:"},{"location":"python/while-loop/#14-topshiriq","text":"Ro\u2018yxatdagi sonlardan har birining raqamlari yig\u2018indisini while loop bilan hisoblab, yangi ro\u2018yxatga joylang: nums = [12, 305, 47, 88] # natija: [3, 8, 11, 16]","title":"\u2705 14-topshiriq:"},{"location":"python/while-loop/#15-topshiriq","text":"Ro\u2018yxatdagi elementlardan faqat birinchi harfi har doim katta, qolganlari kichik bo\u2018lgan yangi ro\u2018yxatni while loop orqali yarating: names = [\"aNVAR\", \"mUROD\", \"dILSHOD\"] # natija: [\"Anvar\", \"Murod\", \"Dilshod\"]","title":"\u2705 15-topshiriq:"}]}